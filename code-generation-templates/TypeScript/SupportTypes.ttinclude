<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteCheck(CodeGenerationContext context)
	{
#>
	export function check<T>(value: T, parameterName: string): AssertionScope<T> {
		return new AssertionScope<T>(value, parameterName, false);
	}
	class AssertionScope<T> {
		constructor(
			private readonly value: T,
			private readonly parameterName: string,
			private readonly resultOnFail: boolean) {
		}
		public get not(): AssertionScope<T> {
			if (this.resultOnFail === true) {
				return this;
			} else {
				return new AssertionScope<T>(this.value, this.parameterName, true);
			}
		}
		public get is(): AssertionScope<T> {
			if (this.resultOnFail === true) {
				return new AssertionScope<T>(this.value, this.parameterName, false);
			} else {
				return this;
			}
		}
		public get and() {
			return this;
		}
		public get or() {
			return this;
		}
		public null(): this {
			if ((this.value === null) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be null.`);
			}
			return this;
		}
		public nullOrUndefined(): this {
			if ((this.value === null || this.value === undefined) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be null or undefined.`);
			}
			return this;
		}
		public instanceOf(type: Function) {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if (((this.value instanceof type)) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be '${type.name}' type.`);
			}
			return this;
		}
		public string(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if ((typeof this.value === 'string' || this.value instanceof String) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'string' type.`);
			}
			return this;
		}
		public object(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if ((typeof this.value === 'object' || this.value instanceof Object) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'object' type.`);
			}
			return this;
		}
		public array(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if (Array.isArray(this.value) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'array' type.`);
			}
			return this;
		}
		public numberOrNanOrInfinity(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			const isNumber = (typeof this.value === 'number' || this.value instanceof Number);
			if (isNumber === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'number' type.`);
			}
			return this;
		}
		public number(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			const isNumber = (typeof this.value === 'number' && !Number.isNaN(this.value) && Number.isFinite(this.value)) ||
				(this.value instanceof Number && !Number.isNaN(this.value.valueOf()) && Number.isFinite(this.value.valueOf()));
			if (isNumber === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'number' type and not NaN or Infinity.`);
			}
			return this;
		}
		public bigint(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			const isBigInt = (typeof this.value === 'bigint');
			if (isBigInt === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'bigint' type.`);
			}
			return this;
		}
		public integer(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			const isNumber = (typeof this.value === 'number' && Number.isInteger(this.value)) ||
				(this.value instanceof Number && Number.isInteger(this.value.valueOf()));
			if (isNumber === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be 'integer' type.`);
			}
			return this;
		}
		public enum(enumDefinition: { [index: number]: string }): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if ((!!enumDefinition[Number(this.value)]) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be part of enumeration.`);
			}
			return this;
		}
		public undefined(): this {
			if ((typeof this.value === 'undefined') === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be undefined.`);
			}
			return this;
		}
		public date(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if (this.value instanceof Date && Number.isNaN(this.value.getTime())) {
				throw new Error(`Malformed Date object in '${this.parameterName}'.`);
			}
			const isDate = (this.value instanceof Date);
			if (isDate === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be date.`);
			}
			return this;
		}
		public function(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if ((this.value instanceof Function) === this.resultOnFail) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be function.`);
			}
			return this;
		}
		public empty(): this {
			if (this.value === null || this.value === undefined) {
				return this;
			}
			if (typeof this.value === 'string' && this.value === '') {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be non-empty string.`);
			}
			if (this.value instanceof String && this.value.valueOf() === '') {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be non-empty string.`);
			}
			if (this.value instanceof Array && this.value.length === 0) {
				throw new Error(`An argument '${this.parameterName}' ${this.getModalVerb()} be non-empty array.`);
			}
			return this;
		}
		private getModalVerb(): 'can\'t' | 'should' {
			return this.resultOnFail ? 'can\'t' : 'should';
		}
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteCoerceToFunction(CodeGenerationContext context)
	{
#>
	export function coerceTo(value: any, type: 'any'): any;
	export function coerceTo(value: any, type: 'TimeSpan'): TimeSpan;
	export function coerceTo(value: any, type: 'Date'): Date;
	export function coerceTo(value: any, type: 'boolean'): boolean;
	export function coerceTo(value: any, type: 'object'): object;
	export function coerceTo(value: any, type: 'bigint'): bigint;
	export function coerceTo(value: any, type: 'string'): string;
	export function coerceTo(value: any, type: 'number'): number;
	export function coerceTo(value: any, type: string): any;
	export function coerceTo(value: any, type: string): any {
		check(type, 'type').is.string().and.not.nullOrUndefined();
		switch (type) {
			case 'any':
				return value;
			case 'TimeSpan':
				return new TimeSpan(value);
			case 'Date':
				return new Date(value);
			case 'boolean':
				return Boolean(value);
			case 'object':
				return value === undefined ? null : value;
			case 'bigint':
				return BigInt(value);
			case 'string':
				return value + '';
			case 'number':
				return Number(value);
			default:
				return value;
		}
	}
	export type Enum<E> = Record<keyof E, number | string> & { [k: number]: string };
	export function coerceToEnum<T extends Enum<T>>(value: any, enumType: T): number | string | null {
		let enumValue: number | string | null;
		if (typeof (value) === 'number') {
			enumValue = value;
		} else if (typeof (value) === 'string') {
			enumValue = Number(value);
			if (Number.isNaN(enumValue)) {
				enumValue = value in enumType ? enumType[value as keyof T] : null;
				if (enumValue == null && Object.values(enumType).indexOf(value)) {
					enumValue = value;
				}
			}
		} else {
			return enumValue = null;
		}
		return enumValue;
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentCollection(CodeGenerationContext context)
	{
#>
	export class DocumentCollection<KeyT, DocumentT extends <#= context.TargetLanguage.DocumentClassName #>> {
		public static readonly empty = new DocumentCollection<any, any>([], 'id');
		private readonly documentsByKey: Map<KeyT, DocumentT>;
		private readonly documents: ReadonlyArray<DocumentT>;
		private byKeyCollections?: Map<string, any>;
		public get asList(): ReadonlyArray<DocumentT> {
			return this.documents;
		}
		public get keys(): Iterable<KeyT> {
			return this.documentsByKey.keys();
		}
		public get values(): Iterable<DocumentT> {
			return this.documentsByKey.values();
		}
		public get count(): number {
			return this.documents.length;
		}
		constructor(documents: Iterable<DocumentT>, private readonly keyPropertyName: keyof DocumentT & string) {
			check(documents, 'documents').is.not.nullOrUndefined();
			check(keyPropertyName, 'keyPropertyName').is.string().not.nullOrUndefined();
			const keySelector: (document: DocumentT) => KeyT = (document) => (<any>document)[keyPropertyName];
			this.documentsByKey = new Map();
			const allDocuments: DocumentT[] = [];
			for (const document of documents) {
				allDocuments.push(document);
				const key = keySelector(document);
				if (key === null || key === undefined) {
					continue;
				}
				this.documentsByKey.set(key, document);
			}
			this.documents = allDocuments;
		}
		public find(key: KeyT): DocumentT | undefined {
			check(key, 'key').is.not.nullOrUndefined();
			return this.documentsByKey.get(key);
		}
		public get(key: KeyT): DocumentT {
			check(key, 'key').is.not.nullOrUndefined();
			const documentOrNull = this.documentsByKey.get(key);
			if (documentOrNull === undefined || documentOrNull === null) {
				throw new Error(`Unable to find document with key '${key}'.`);
			}
			return documentOrNull;
		}
		public contains(key: KeyT): boolean {
			check(key, 'key').is.not.nullOrUndefined();
			return this.documentsByKey.has(key);
		}
		/**
		 * @deprecated Use byKey() method due better semantic. This method will be removed after 01.01.2024
		 */
		public withOtherKey<NewKeyT extends keyof DocumentT>(newKeyPropertyName: NewKeyT & string): DocumentCollection<DocumentT[NewKeyT], DocumentT> {
			return this.byKey(newKeyPropertyName);
		}
		public byKey<NewKeyT extends keyof DocumentT>(newKeyPropertyName: NewKeyT & string): DocumentCollection<DocumentT[NewKeyT], DocumentT> {
			if (!this.byKeyCollections) {
				this.byKeyCollections = new Map();
				this.byKeyCollections.set(this.keyPropertyName, this);
			}
			if (this.byKeyCollections.has(newKeyPropertyName)) {
				return this.byKeyCollections.get(newKeyPropertyName) as DocumentCollection<DocumentT[NewKeyT], DocumentT>;
			}
			const newCollection = new DocumentCollection<DocumentT[NewKeyT], DocumentT>(this.documents, newKeyPropertyName);
			newCollection.byKeyCollections = this.byKeyCollections;
			return newCollection;
		}
		public toString() {
			return `Count: ${this.asList.length}`;
		}
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceCollection(CodeGenerationContext context)
	{
#>
	export class DocumentReferenceCollection<DocumentT extends <#= context.TargetLanguage.DocumentClassName #>> {
		public static readonly empty = new DocumentReferenceCollection<any>([]);
		private documentCollection?: DocumentCollection<DocumentT['id'], DocumentT>;
		public get count(): number {
			return this.referenceList.length;
		}
		public get asList(): typeof this.referenceList {
			return this.referenceList;
		}
		constructor(
			private readonly referenceList: ReadonlyArray<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>
		) {
			check(referenceList, 'referenceList').is.array().and.not.nullOrUndefined();
		}
		public dereference(): DocumentCollection<DocumentT['id'], DocumentT> {
			const documents = this.referenceList
				.map(reference => reference.dereference());
			this.documentCollection = new DocumentCollection<DocumentT['id'], DocumentT>(documents, 'id');
			return this.documentCollection;
		}
		public toString() {
			return `Count: ${this.count}`;
		}
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocument(CodeGenerationContext context)
	{
#>
	export abstract class <#= context.TargetLanguage.DocumentClassName #> {
		private _parent: <#= context.TargetLanguage.DocumentClassName #> | undefined;
		declare abstract readonly id: any;
		public get parent(): <#= context.TargetLanguage.DocumentClassName #> | undefined {
			return this._parent;
		}
		protected static setParent(document: <#= context.TargetLanguage.DocumentClassName #> | null | undefined, parent: <#= context.TargetLanguage.DocumentClassName #> | null | undefined) {
			if (!document) {
				return;
			}
			document._parent = parent ?? undefined;
		}
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceBaseClass(CodeGenerationContext context)
	{
#>
	export class <#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT extends <#= context.TargetLanguage.DocumentClassName #>> {
		private document?: DocumentT;
		constructor
		(
			public readonly id: any,
			private readonly schemaNameOrId: string,
			private readonly findFunc: (schemaNameOrId: string, id: any) => <#= context.TargetLanguage.DocumentClassName #>,
		) {
			check(schemaNameOrId, 'schemaNameOrId').is.string().not.nullOrUndefined();
			check(findFunc, 'findFunc').is.function().not.nullOrUndefined();
			check(id, 'id').is.not.nullOrUndefined();
		}
		public dereference(): DocumentT {
			if (this.document) {
				return this.document;
			}
			return this.document = this.findFunc(this.schemaNameOrId, this.id) as DocumentT;
		}
		public toString() {
			return `Id: ${this.id}, Schema: ${this.schemaNameOrId}, Resolved: ${this.document != null}`;
		}
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteGetFunctionParameterNamesFunction(CodeGenerationContext context)
	{
#>
	export function getFunctionParameterNames(fn: Function): Array<string> {
		const stripCommentsRegex = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/mg;
		const parameterNamesRegex = /([^\s,]+)/g;
		const parameterNamesSymbol = Symbol('parameterNames');
		const fnObj = <any>fn;
		if (fnObj.hasOwnProperty(parameterNamesSymbol)) {
			return <Array<string>>fnObj[parameterNamesSymbol];
		}
		const fnStr = fn.toString().replace(stripCommentsRegex, '');
		let parameterNames = [...(fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(parameterNamesRegex) ?? [])];
		if (!parameterNames) {
			parameterNames = [];
		}
		fnObj[parameterNamesSymbol] = parameterNames;
		return parameterNames;
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteLocalizedText(CodeGenerationContext context)
	{
#>
	export class LocalizedText {
		public static empty: LocalizedText;
		private currentValue?: string;
		private currentValueLanguageId?: string;
		public get count(): number {
			return this.textByLanguage.size;
		}
		public get value(): string {
			if (this.languageSwitcher.currentLanguageId != this.currentValueLanguageId) {
				this.currentValueLanguageId = this.languageSwitcher.currentLanguageId;
				switch (this.languageSwitcher.fallbackOption)
				{
					case LocalizedText.FallbackOption.OnNotDefined:
						if (this.textByLanguage.has(this.languageSwitcher.currentLanguageId)) {
							this.currentValue = this.textByLanguage.get(this.languageSwitcher.currentLanguageId) ?? undefined;
						} else if (this.textByLanguage.has(this.languageSwitcher.fallbackLanguageId)) {
							this.currentValue = this.textByLanguage.get(this.languageSwitcher.fallbackLanguageId) ?? undefined;
						} else if (this.textByLanguage.has(this.languageSwitcher.primaryLanguageId)) {
							this.currentValue = this.textByLanguage.get(this.languageSwitcher.primaryLanguageId) ?? undefined;
						}
						this.currentValue = this.currentValue ?? '';
						break;
					default:
					case LocalizedText.FallbackOption.OnNull:
						this.currentValue = this.textByLanguage.get(this.languageSwitcher.currentLanguageId) ??
							this.textByLanguage.get(this.languageSwitcher.fallbackLanguageId) ??
							this.textByLanguage.get(this.languageSwitcher.primaryLanguageId) ??
							'';
						break;
					case LocalizedText.FallbackOption.OnEmpty:
						this.currentValue = this.textByLanguage.get(this.languageSwitcher.currentLanguageId) ?? undefined;
						if (!this.currentValue) {
							this.currentValue = this.textByLanguage.get(this.languageSwitcher.fallbackLanguageId) ?? undefined;
						}
						if (!this.currentValue) {
							this.currentValue = this.textByLanguage.get(this.languageSwitcher.primaryLanguageId) ?? undefined;
						}
						this.currentValue = this.currentValue ?? '';
						break;
				}
			}
			return this.currentValue ?? '';
		}
		constructor(
			private readonly textByLanguage: ReadonlyMap<string, string | null>,
			private readonly languageSwitcher: LocalizedText.LanguageSwitcher
		) {
			check(textByLanguage, 'textByLanguage').is.instanceOf(Map).and.not.nullOrUndefined();
			check(languageSwitcher, 'languageSwitcher').is.instanceOf(LocalizedText.LanguageSwitcher).and.not.nullOrUndefined();
		}
		public find(languageId: string): string | null {
			check(languageId, 'languageId').is.string().and.not.nullOrUndefined();
			return this.textByLanguage.get(languageId) ?? null;
		}
		public toString() {
			return this.value;
		}
	}
	export module LocalizedText {
		export class LanguageSwitcher {
			constructor(
				public currentLanguageId: string,
				public fallbackLanguageId: string,
				public primaryLanguageId: string,
				public fallbackOption: FallbackOption,
			) {
			}
		}
		export enum FallbackOption {
			/**
			 * Fallback when the localized text is null (default)
			 */
			OnNull,
			/**
			 * Fallback when the localized text is an empty string
			 */
			OnEmpty,
			/**
			 * Fallback when the localized text is not defined in the LocalizedText
			 */
			OnNotDefined,
		}
	}
	LocalizedText.empty = new LocalizedText(new Map(), new LocalizedText.LanguageSwitcher('en-US', 'en-US', 'en-US', LocalizedText.FallbackOption.OnNull));
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteStringFormatFunction(CodeGenerationContext context)
	{
#>
	export function formatString(pattern: string, ...parameters: any[]): string {
		return pattern.replace(/{(\d+)}/g, function (match, number) {
			return typeof parameters[number] !== 'undefined'
				? parameters[number] + '' : match;
		});
	}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteTimeSpan(CodeGenerationContext context)
	{
#>
	const ticksPerMillisecond = 10000n;
	const ticksPerSecond = 10000000n;
	const ticksPerMinute = 600000000n;
	const ticksPerHour = 36000000000n;
	const ticksPerDay = 864000000000n;
	const int64MaxValue = 9223372036854775807n;
	const int64MinValue = -9223372036854775808n;
	export class TimeSpan {
		/* eslint-disable @typescript-eslint/naming-convention */
		public static readonly MAX_VALUE: TimeSpan = new TimeSpan(int64MaxValue);
		public static readonly MIN_VALUE: TimeSpan = new TimeSpan(int64MinValue);
		public static readonly ZERO: TimeSpan = new TimeSpan(0n);
		/* eslint-enable @typescript-eslint/naming-convention */
		private readonly _value: bigint;
		public get ticks(): bigint {
			return this._value;
		}
		public get sign(): number {
			return this._value > 0n ? 1 : this._value === 0n ? 0 : -1;
		}
		public get milliseconds(): number {
			return Number(this._value / ticksPerMillisecond);
		}
		constructor(value: bigint | TimeSpan | number | string | boolean) {
			if (value instanceof TimeSpan) {
				this._value = value._value;
			} else if (typeof value === 'bigint') {
				this._value = value;
			} else if (typeof value === 'string') {
				this._value = TimeSpan.parse(value)?._value ?? 0n;
			} else if (!value) {
				this._value = 0n;
			} else {
				this._value = BigInt(value);
			}
		}
		private static parse(value: any): TimeSpan {
			if (typeof (value) === 'bigint' || typeof (value) === 'number') {
				return new TimeSpan(value);
			} else if (value instanceof TimeSpan) {
				return value;
			}
			if (typeof (value) !== 'string' ||
				(/^[\-\d\:\.]+$/).test(value) === false) {
				return TimeSpan.ZERO;
			}
			let isNegative = false;
			if (value.startsWith('-')) {
				value = value.substring(1);
				isNegative = true;
			}
			if (/^\d+$/.test(value)) {
				const ticksFromSeconds = BigInt(value) * ticksPerSecond;
				return new TimeSpan(isNegative ? ticksFromSeconds * -1n : ticksFromSeconds);
			}
			let ticks = 0n;
			if (value.lastIndexOf('.') >= value.indexOf('.') && value.lastIndexOf('.') > value.indexOf(':')) {
				const splitIndex = value.lastIndexOf('.');
				const tickStr = value.substring(splitIndex + 1);
				value = value.substring(0, splitIndex);
				ticks = ticks + BigInt(tickStr);
			}
			const parts = value.split(/[\:\.]/);
			while (parts.length < 4) {
				parts.unshift('0');
			}
			ticks = ticks + BigInt(parts[0]) * ticksPerDay;
			ticks = ticks + BigInt(parts[1]) * ticksPerHour;
			ticks = ticks + BigInt(parts[2]) * ticksPerMinute;
			ticks = ticks + BigInt(parts[3]) * ticksPerSecond;
			return new TimeSpan(isNegative ? ticks * -1n : ticks);
		}
		public static compare(x: any, y: any): number {
			const xIsNull = (x === undefined || x === null);
			const yIsNull = (y === undefined || y === null);
			if (xIsNull && yIsNull) {
				return 0;
			} else if (!xIsNull && yIsNull) {
				return 1;
			} else if (xIsNull && !yIsNull) {
				return -1;
			}
			const xNum = this.parse(x)._value;
			const yNum = this.parse(y)._value;
			return xNum > yNum ? 1 : xNum === yNum ? 0 : -1;
		}
		public static toNumber(x: TimeSpan): number {
			return Number(x._value);
		}
		private static padNumber(value: bigint, total: number): string {
			let valueStr = value.toString();
			while (valueStr.length < total) {
				valueStr = '0' + valueStr;
			}
			return valueStr;
		}
		public toJSON(): string {
			return this.toString();
		}
		public valueOf() {
			return this.toJSON();
		}
		public toString(): string {
			const ticks = this._value % ticksPerSecond;
			const seconds = (this._value / ticksPerSecond) % 60n;
			const minutes = (this._value / ticksPerMinute) % 60n;
			const hours = (this._value / ticksPerHour) % 24n;
			const days = (this._value / ticksPerDay);
			let result = TimeSpan.padNumber(hours, 2) + ':' + TimeSpan.padNumber(minutes, 2) + ':' + TimeSpan.padNumber(seconds, 2);
			if (ticks > 0n) {
				result = result + '.' + TimeSpan.padNumber(ticks, 7);
			}
			if (days > 0n) {
				result = days + '.' + result;
			}
			return result;
		}
	}
<#+ 
	}
#>
