<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormulas(CodeGenerationContext context)
	{
#>
	/* eslint-disable @typescript-eslint/naming-convention */
	export const DEFAULT_CHECKED_SCOPE = true;
	export const enum FormulaConstants {
		// expression attributes
		LINE_NUMBER_OLD_ATTRIBUTE = '$lineNum',
		COLUMN_NUMBER_OLD_ATTRIBUTE = '$columnNum',
		TOKEN_LENGTH_OLD_ATTRIBUTE = '$tokenLength',
		ORIGINAL_C_SHARP_ALT2_ATTRIBUTE = '$originalExpression',
		ORIGINAL_C_SHARP_ALT_ATTRIBUTE = '_src',
		ORIGINAL_C_SHARP_CODE_ATTRIBUTE = '_cs',
		POSITION_ATTRIBUTE = '_pos',
		EXPRESSION_TYPE_ATTRIBUTE = 'expressionType',
		EXPRESSION_ATTRIBUTE = 'expression',
		ARGUMENTS_ATTRIBUTE = 'arguments',
		LEFT_ATTRIBUTE = 'left',
		RIGHT_ATTRIBUTE = 'right',
		TEST_ATTRIBUTE = 'test',
		IF_TRUE_ATTRIBUTE = 'ifTrue',
		IF_FALSE_ATTRIBUTE = 'ifFalse',
		TYPE_ATTRIBUTE = 'type',
		VALUE_ATTRIBUTE = 'value',
		PROPERTY_OR_FIELD_NAME_ATTRIBUTE = 'propertyOrFieldName',
		NAME_ATTRIBUTE = 'name',
		USE_NULL_PROPAGATION_ATTRIBUTE = 'useNullPropagation',
		// expression types
		EXPRESSION_TYPE_PROPERTY_OR_FIELD = 'PropertyOrField',
		EXPRESSION_TYPE_MEMBER_RESOLVE = 'MemberResolve',
		EXPRESSION_TYPE_CONSTANT = 'Constant',
		EXPRESSION_TYPE_CONVERT = 'Convert',
		EXPRESSION_TYPE_CONVERT_CHECKED = 'ConvertChecked',
		EXPRESSION_TYPE_GROUP = 'Group',
		EXPRESSION_TYPE_INVOKE = 'Invoke',
		EXPRESSION_TYPE_LAMBDA = 'Lambda',
		EXPRESSION_TYPE_INDEX = 'Index',
		EXPRESSION_TYPE_UNCHECKED_SCOPE = 'UncheckedScope',
		EXPRESSION_TYPE_CHECKED_SCOPE = 'CheckedScope',
		EXPRESSION_TYPE_TYPE_OF = 'TypeOf',
		EXPRESSION_TYPE_DEFAULT = 'Default',
		EXPRESSION_TYPE_NEW = 'New',
		EXPRESSION_TYPE_NEW_ARRAY_BOUNDS = 'NewArrayBounds',
		EXPRESSION_TYPE_ADD = 'Add',
		EXPRESSION_TYPE_ADD_CHECKED = 'AddChecked',
		EXPRESSION_TYPE_SUBTRACT = 'Subtract',
		EXPRESSION_TYPE_SUBTRACT_CHECKED = 'SubtractChecked',
		EXPRESSION_TYPE_LEFT_SHIFT = 'LeftShift',
		EXPRESSION_TYPE_RIGHT_SHIFT = 'RightShift',
		EXPRESSION_TYPE_GREATER_THAN = 'GreaterThan',
		EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL = 'GreaterThanOrEqual',
		EXPRESSION_TYPE_LESS_THAN = 'LessThan',
		EXPRESSION_TYPE_LESS_THAN_OR_EQUAL = 'LessThanOrEqual',
		EXPRESSION_TYPE_QUOTE = 'Quote',
		EXPRESSION_TYPE_NEGATE = 'Negate',
		EXPRESSION_TYPE_NEGATE_CHECKED = 'NegateChecked',
		EXPRESSION_TYPE_POWER = 'Power',
		EXPRESSION_TYPE_COMPLEMENT = 'Complement',
		EXPRESSION_TYPE_DIVIDE = 'Divide',
		EXPRESSION_TYPE_MULTIPLY = 'Multiply',
		EXPRESSION_TYPE_MULTIPLY_CHECKED = 'MultiplyChecked',
		EXPRESSION_TYPE_MODULO = 'Modulo',
		EXPRESSION_TYPE_TYPE_IS = 'TypeIs',
		EXPRESSION_TYPE_TYPE_AS = 'TypeAs',
		EXPRESSION_TYPE_NOT = 'Not',
		EXPRESSION_TYPE_EQUAL = 'Equal',
		EXPRESSION_TYPE_NOT_EQUAL = 'NotEqual',
		EXPRESSION_TYPE_AND = 'And',
		EXPRESSION_TYPE_OR = 'Or',
		EXPRESSION_TYPE_EXCLUSIVE_OR = 'ExclusiveOr',
		EXPRESSION_TYPE_AND_ALSO = 'AndAlso',
		EXPRESSION_TYPE_OR_ELSE = 'OrElse',
		EXPRESSION_TYPE_COALESCE = 'Coalesce',
		EXPRESSION_TYPE_CONDITION = 'Condition',
		EXPRESSION_TYPE_UNARY_PLUS = 'UnaryPlus',
		EXPRESSION_TYPE_CHECKED_SUFFIX = 'Checked',
		// known types
		KNOWN_TYPE_ARRAY = 'Array',
		KNOWN_TYPE_SYSTEM_VOID = 'System.Void',
		KNOWN_TYPE_SYSTEM_CHAR = 'System.Char',
		KNOWN_TYPE_SYSTEM_BOOL = 'System.Boolean',
		KNOWN_TYPE_SYSTEM_BYTE = 'System.Byte',
		KNOWN_TYPE_SYSTEM_SBYTE = 'System.SByte',
		KNOWN_TYPE_SYSTEM_DECIMAL = 'System.Decimal',
		KNOWN_TYPE_SYSTEM_DOUBLE = 'System.Double',
		KNOWN_TYPE_SYSTEM_SINGLE = 'System.Single',
		KNOWN_TYPE_SYSTEM_INT32 = 'System.Int32',
		KNOWN_TYPE_SYSTEM_UINT32 = 'System.UInt32',
		KNOWN_TYPE_SYSTEM_INT64 = 'System.Int64',
		KNOWN_TYPE_SYSTEM_UINT64 = 'System.UInt64',
		KNOWN_TYPE_SYSTEM_OBJECT = 'System.Object',
		KNOWN_TYPE_SYSTEM_INT16 = 'System.Int16',
		KNOWN_TYPE_SYSTEM_UINT16 = 'System.UInt16',
		KNOWN_TYPE_SYSTEM_STRING = 'System.String',
		KNOWN_TYPE_SYSTEM_TYPE = 'System.Type',
		KNOWN_TYPE_SYSTEM_ARRAY = 'System.Array',
		KNOWN_TYPE_SYSTEM_DATE_TIME = 'System.DateTime',
		KNOWN_TYPE_SYSTEM_TIME_SPAN = 'System.TimeSpan',
		// notations
		NOTATION_TRUE_STRING = 'true',
		NOTATION_FALSE_STRING = 'false',
		NOTATION_NULL_STRING = 'null',
		//
	}
	export enum TokenType {
		None,
		Number,
		Literal,
		Identifier,
		// arithmetic
		Add,
		Plus,
		Subtract,
		Minus,
		Division,
		Multiplication,
		Power,
		Modulo,
		// bitwise
		And,
		Or,
		Xor,
		Complement,
		LeftShift,
		RightShift,
		// logical
		AndAlso,
		OrElse,
		Not,
		GreaterThan,
		GreaterThanOrEquals,
		LesserThan,
		LesserThanOrEquals,
		EqualsTo,
		NotEqualsTo,
		// other
		Conditional,
		Is,
		As,
		Colon,
		Comma,
		Coalesce,
		New,
		// structure
		Resolve,
		NullResolve,
		LeftParentheses,
		RightParentheses,
		LeftBracket,
		NullIndex,
		RightBracket,
		Lambda,
		Call,
		Arguments,
		Convert,
		Typeof,
		Default,
		Group,
		CheckedScope,
		UncheckedScope
	}
	export enum ExpressionType {
		Add = 0,
		AddChecked = 1,
		And = 2,
		AndAlso = 3,
		ArrayLength = 4,
		ArrayIndex = 5,
		Call = 6,
		Coalesce = 7,
		Conditional = 8,
		Constant = 9,
		Convert = 10,
		ConvertChecked = 11,
		Divide = 12,
		Equal = 13,
		ExclusiveOr = 14,
		GreaterThan = 15,
		GreaterThanOrEqual = 16,
		Invoke = 17,
		Lambda = 18,
		LeftShift = 19,
		LessThan = 20,
		LessThanOrEqual = 21,
		ListInit = 22,
		MemberAccess = 23,
		MemberInit = 24,
		Modulo = 25,
		Multiply = 26,
		MultiplyChecked = 27,
		Negate = 28,
		UnaryPlus = 29,
		NegateChecked = 30,
		New = 31,
		NewArrayInit = 32,
		NewArrayBounds = 33,
		Not = 34,
		NotEqual = 35,
		Or = 36,
		OrElse = 37,
		Parameter = 38,
		Power = 39,
		Quote = 40,
		RightShift = 41,
		Subtract = 42,
		SubtractChecked = 43,
		TypeAs = 44,
		TypeIs = 45,
		Assign = 46,
		Block = 47,
		DebugInfo = 48,
		Decrement = 49,
		Dynamic = 50,
		Default = 51,
		Extension = 52,
		Goto = 53,
		Increment = 54,
		Index = 55,
		Label = 56,
		RuntimeVariables = 57,
		Loop = 58,
		Switch = 59,
		Throw = 60,
		Try = 61,
		Unbox = 62,
		AddAssign = 63,
		AndAssign = 64,
		DivideAssign = 65,
		ExclusiveOrAssign = 66,
		LeftShiftAssign = 67,
		ModuloAssign = 68,
		MultiplyAssign = 69,
		OrAssign = 70,
		PowerAssign = 71,
		RightShiftAssign = 72,
		SubtractAssign = 73,
		AddAssignChecked = 74,
		MultiplyAssignChecked = 75,
		SubtractAssignChecked = 76,
		PreIncrementAssign = 77,
		PreDecrementAssign = 78,
		PostIncrementAssign = 79,
		PostDecrementAssign = 80,
		TypeEqual = 81,
		OnesComplement = 82,
		IsTrue = 83,
		IsFalse = 84,
		Noop = 255
	}
	export const expressionTypeByToken = new Map<TokenType, string>();
	expressionTypeByToken.set(TokenType.Resolve, FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE);
	expressionTypeByToken.set(TokenType.NullResolve, FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE);
	expressionTypeByToken.set(TokenType.Identifier, FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE);
	expressionTypeByToken.set(TokenType.Literal, FormulaConstants.EXPRESSION_TYPE_CONSTANT);
	expressionTypeByToken.set(TokenType.Number, FormulaConstants.EXPRESSION_TYPE_CONSTANT);
	expressionTypeByToken.set(TokenType.Convert, FormulaConstants.EXPRESSION_TYPE_CONVERT);
	expressionTypeByToken.set(TokenType.Group, FormulaConstants.EXPRESSION_TYPE_GROUP);
	expressionTypeByToken.set(TokenType.UncheckedScope, FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE);
	expressionTypeByToken.set(TokenType.CheckedScope, FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE);
	expressionTypeByToken.set(TokenType.Plus, FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS);
	expressionTypeByToken.set(TokenType.Minus, FormulaConstants.EXPRESSION_TYPE_NEGATE);
	expressionTypeByToken.set(TokenType.Not, FormulaConstants.EXPRESSION_TYPE_NOT);
	expressionTypeByToken.set(TokenType.Complement, FormulaConstants.EXPRESSION_TYPE_COMPLEMENT);
	expressionTypeByToken.set(TokenType.Division, FormulaConstants.EXPRESSION_TYPE_DIVIDE);
	expressionTypeByToken.set(TokenType.Multiplication, FormulaConstants.EXPRESSION_TYPE_MULTIPLY);
	expressionTypeByToken.set(TokenType.Power, FormulaConstants.EXPRESSION_TYPE_POWER);
	expressionTypeByToken.set(TokenType.Modulo, FormulaConstants.EXPRESSION_TYPE_MODULO);
	expressionTypeByToken.set(TokenType.Add, FormulaConstants.EXPRESSION_TYPE_ADD);
	expressionTypeByToken.set(TokenType.Subtract, FormulaConstants.EXPRESSION_TYPE_SUBTRACT);
	expressionTypeByToken.set(TokenType.LeftShift, FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT);
	expressionTypeByToken.set(TokenType.RightShift, FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT);
	expressionTypeByToken.set(TokenType.GreaterThan, FormulaConstants.EXPRESSION_TYPE_GREATER_THAN);
	expressionTypeByToken.set(TokenType.GreaterThanOrEquals, FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL);
	expressionTypeByToken.set(TokenType.LesserThan, FormulaConstants.EXPRESSION_TYPE_LESS_THAN);
	expressionTypeByToken.set(TokenType.LesserThanOrEquals, FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL);
	expressionTypeByToken.set(TokenType.Is, FormulaConstants.EXPRESSION_TYPE_TYPE_IS);
	expressionTypeByToken.set(TokenType.As, FormulaConstants.EXPRESSION_TYPE_TYPE_AS);
	expressionTypeByToken.set(TokenType.EqualsTo, FormulaConstants.EXPRESSION_TYPE_EQUAL);
	expressionTypeByToken.set(TokenType.NotEqualsTo, FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL);
	expressionTypeByToken.set(TokenType.And, FormulaConstants.EXPRESSION_TYPE_AND);
	expressionTypeByToken.set(TokenType.Or, FormulaConstants.EXPRESSION_TYPE_OR);
	expressionTypeByToken.set(TokenType.Xor, FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR);
	expressionTypeByToken.set(TokenType.AndAlso, FormulaConstants.EXPRESSION_TYPE_AND_ALSO);
	expressionTypeByToken.set(TokenType.OrElse, FormulaConstants.EXPRESSION_TYPE_OR_ELSE);
	expressionTypeByToken.set(TokenType.Coalesce, FormulaConstants.EXPRESSION_TYPE_COALESCE);
	expressionTypeByToken.set(TokenType.Conditional, FormulaConstants.EXPRESSION_TYPE_CONDITION);
	expressionTypeByToken.set(TokenType.Call, FormulaConstants.EXPRESSION_TYPE_INVOKE);
	expressionTypeByToken.set(TokenType.Typeof, FormulaConstants.EXPRESSION_TYPE_TYPE_OF);
	expressionTypeByToken.set(TokenType.Default, FormulaConstants.EXPRESSION_TYPE_DEFAULT);
	expressionTypeByToken.set(TokenType.New, FormulaConstants.EXPRESSION_TYPE_NEW);
	expressionTypeByToken.set(TokenType.LeftBracket, FormulaConstants.EXPRESSION_TYPE_INDEX);
	expressionTypeByToken.set(TokenType.Lambda, FormulaConstants.EXPRESSION_TYPE_LAMBDA);
	export const typeAliases = new Map<string, string>();
	typeAliases.set('void', FormulaConstants.KNOWN_TYPE_SYSTEM_VOID);
	typeAliases.set('char', FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR);
	typeAliases.set('bool', FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL);
	typeAliases.set('byte', FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE);
	typeAliases.set('sbyte', FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE);
	typeAliases.set('decimal', FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL);
	typeAliases.set('double', FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE);
	typeAliases.set('float', FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE);
	typeAliases.set('int', FormulaConstants.KNOWN_TYPE_SYSTEM_INT32);
	typeAliases.set('uint', FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32);
	typeAliases.set('long', FormulaConstants.KNOWN_TYPE_SYSTEM_INT64);
	typeAliases.set('ulong', FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64);
	typeAliases.set('object', FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT);
	typeAliases.set('short', FormulaConstants.KNOWN_TYPE_SYSTEM_INT16);
	typeAliases.set('ushort', FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16);
	typeAliases.set('string', FormulaConstants.KNOWN_TYPE_SYSTEM_STRING);
	export const systemTypes = new Set<string>();
	systemTypes.add('Void');
	systemTypes.add('Char');
	systemTypes.add('Boolean');
	systemTypes.add('Byte');
	systemTypes.add('SByte');
	systemTypes.add('Decimal');
	systemTypes.add('Double');
	systemTypes.add('Single');
	systemTypes.add('Int32');
	systemTypes.add('UInt32');
	systemTypes.add('Int64');
	systemTypes.add('UInt64');
	systemTypes.add('Object');
	systemTypes.add('Int16');
	systemTypes.add('UInt16');
	systemTypes.add('String');
	systemTypes.add('Type');
	systemTypes.add('Array');
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable */
	export class ExpressionResources {
		// Binding Errors
		public static readonly EXCEPTION_BIND_CALLMEMBERISNOTMETHOD: string = "Member '{0}' on type '{1}' is not a method and cannot be invoked.";
		public static readonly EXCEPTION_BIND_CLOSEDDELEGATETYPEISEXPECTED: string = "Lambda type '{0}' must be a closed generic delegate type.";
		public static readonly EXCEPTION_BIND_FAILEDTOBIND: string = "Failed to build expression '{0}': {1}";
		public static readonly EXCEPTION_BIND_FAILEDTOBINDGENERICARGUMENTSTOTYPE: string = "Generic arguments '{0}' are not valid for type '{1}'.";
		public static readonly EXCEPTION_BIND_FAILEDTOBINDLISTINITIALIZERS: string = "Failed to bind list initializer expression.";
		public static readonly EXCEPTION_BIND_FAILEDTOBINDMEMBERBINDINGS: string = "Failed to bind member initializers.";
		public static readonly EXCEPTION_BIND_FAILEDTOBINDNEWEXPRESSION: string = "Failed to bind object creation expression.";
		public static readonly EXCEPTION_BIND_INVALIDCHARLITERAL: string = "Character literal '{0}' must contain exactly one character.";
		public static readonly EXCEPTION_BIND_INVALIDCONSTANTEXPRESSION: string = "Type '{0}' cannot be represented as a constant literal.";
		public static readonly EXCEPTION_BIND_INVALIDLAMBDAARGUMENTS: string = "Argument types or count do not match lambda type '{0}'.";
		public static readonly EXCEPTION_BIND_INVALIDLAMBDABODYTYPE: string = "Lambda body type '{1}' is not convertible to expected return type '{0}'.";
		public static readonly EXCEPTION_BIND_INVALIDLAMBDAPARAMETERTYPE: string = "Lambda parameter type '{0}' does not match expected type '{1}'.";
		public static readonly EXCEPTION_BIND_MEMBERISNOTMETHOD: string = "Member '{0}' on type '{1}' is not a method.";
		public static readonly EXCEPTION_BIND_MISSINGATTRONNODE: string = "Required attribute '{0}' is missing or invalid on expression node.";
		public static readonly EXCEPTION_BIND_MISSINGMETHOD: string = "Type '{0}' does not contain method '{1}'.";
		public static readonly EXCEPTION_BIND_MISSINGMETHODPARAMETER: string = "Required parameter for method/indexer '{0}' is missing.";
		public static readonly EXCEPTION_BIND_MISSINGORWRONGARGUMENT: string = "Argument '{0}' is missing or invalid.";
		public static readonly EXCEPTION_BIND_RESTRICTED_MEMBER_INVOCATION: string = "Member '{1}.{0}' is restricted. Add type '{1}' to known types in '{2}' to enable access.";
		public static readonly EXCEPTION_BIND_TOOMANYARGUMENTS: string = "Argument count exceeds maximum supported limit of {0}.";
		public static readonly EXCEPTION_BIND_UNABLEREMAPPARAMETERSCOUNTMISMATCH: string = "Parameter count mismatch during lambda parameter remapping.";
		public static readonly EXCEPTION_BIND_UNABLETOAPPLYNULLCONDITIONALOPERATORONTYPEREF: string = "Null-conditional operator cannot be applied to type '{0}'.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDCALL: string = "No method '{0}' on type '{1}' accepts {2} arguments.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDCONSTRUCTOR: string = "No constructor on type '{0}' matches the provided arguments.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDDELEG: string = "Delegate {0}({1}) cannot be invoked with the provided arguments.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDINDEXER: string = "No indexer on type '{0}' accepts the provided arguments.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDMEMBER: string = "Member '{0}' on type '{1}' cannot be bound due to visibility, static context, or parameter mismatch.";
		public static readonly EXCEPTION_BIND_UNABLETOBINDMETHOD: string = "Method '{0}' on type '{1}' cannot be bound with {2} arguments.";
		public static readonly EXCEPTION_BIND_UNABLETOCREATEEXPRWITHPARAMS: string = "Expression '{0}' cannot be created with {1} parameters.";
		public static readonly EXCEPTION_BIND_UNABLETOINVOKENONDELEG: string = "Type '{0}' is not a delegate and cannot be invoked.";
		public static readonly EXCEPTION_BIND_UNABLETORESOLVEMEMBERONTYPE: string = "Member '{0}' not found on type '{1}'. Available members: {2}.";
		public static readonly EXCEPTION_BIND_UNABLETORESOLVEMETHODONTYPE: string = "Method '{0}' could not be resolved.";
		public static readonly EXCEPTION_BIND_UNABLETORESOLVENAME: string = "Name '{0}' could not be resolved. Available parameters and variables: {1}.";
		public static readonly EXCEPTION_BIND_UNABLETORESOLVETYPE: string = "Type '{0}' could not be resolved.";
		public static readonly EXCEPTION_BIND_UNABLETORESOLVETYPEMULTIPLE: string = "Type '{0}' is ambiguous. Candidates: {1}.";
		public static readonly EXCEPTION_BIND_UNKNOWNEXPRTYPE: string = "Unknown expression type '{0}'.";
		public static readonly EXCEPTION_BIND_VALIDDELEGATETYPEISEXPECTED: string = "Lambda type '{0}' must be a valid delegate type.";
		// Bound Expression Errors
		public static readonly EXCEPTION_BOUNDEXPR_ARGSDOESNTMATCHPARAMS: string = "Argument count does not match parameter count.";
		public static readonly EXCEPTION_BOUNDEXPR_BODYRESULTDOESNTMATCHRESULTTYPE: string = "Expression body result type does not match expected return type.";
		public static readonly EXCEPTION_BOUNDEXPR_CANTCONVERTARG: string = "Argument '{0}' of type '{2}' cannot be converted to required type '{1}'.";
		public static readonly EXCEPTION_BOUNDEXPR_WRONGNUMPARAMS: string = "Parameter count does not match expression signature.";
		public static readonly EXCEPTION_BOUNDEXPR_WRONGPARAMETERTYPE: string = "One or more parameter types do not match expression signature.";
		// Compilation Errors
		public static readonly EXCEPTION_COMPIL_NOBINARYOPONTYPE: string = "Binary operator '{0}' is not defined for types '{1}' and '{2}'.";
		public static readonly EXCEPTION_COMPIL_NOCONVERTIONBETWEENTYPES: string = "No conversion exists from type '{0}' to '{1}'.";
		public static readonly EXCEPTION_COMPIL_NOUNARYOPONTYPE: string = "Unary operator '{0}' is not defined for type '{1}'.";
		public static readonly EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE: string = "Unknown binary expression type '{0}'.";
		public static readonly EXCEPTION_BIND_INVALID_LOGICAL_EXPRESSION: string = "Logical operator '{1}' requires a boolean operand. Actual type: '{2}'.";
		public static readonly EXCEPTION_COMPIL_UNKNOWNEXPRTYPE: string = "Unknown expression type '{0}'.";
		public static readonly EXCEPTION_COMPIL_UNKNOWNUNARYEXPRTYPE: string = "Unknown unary expression type '{0}'.";
		// Execution Errors
		public static readonly EXCEPTION_EXECUTION_CANTDONULLVALUE: string = "Cannot perform operation '{1}' on null value from expression '{0}'.";
		public static readonly EXCEPTION_EXECUTION_EXPRESSIONGIVESNULLRESULT: string = "Expression '{0}' evaluated to null.";
		public static readonly EXCEPTION_EXECUTION_INVALIDMEMBERFOREXPRESSION: string = "Member type '{0}' is not valid for MemberAccess expression.";
		public static readonly EXCEPTION_EXECUTION_MULTIPARAMETERINDEXERNOTSUPPORTED: string = "Indexers with multiple parameters are not supported.";
		// General Errors
		public static readonly EXCEPTION_LIST_LISTISEMPTY: string = "List cannot be empty.";
		// Parsing Errors
		public static readonly EXCEPTION_PARSER_BINARYOPREQOPERAND: string = "Binary operator requires two operands.";
		public static readonly EXCEPTION_PARSER_COLONISEXPRECTED: string = "Colon ':' expected in conditional expression.";
		public static readonly EXCEPTION_PARSER_EXPRESSIONISEMPTY: string = "Expression is empty.";
		public static readonly EXCEPTION_PARSER_INVALIDCHILDCOUNTOFNODE: string = "Node '{0}' has invalid child count {1}. Expected: {2}.";
		public static readonly EXCEPTION_PARSER_INVALIDCHILDTYPESOFNODE: string = "Node '{0}' has invalid child type '{1}'. Expected: '{2}'.";
		public static readonly EXCEPTION_PARSER_MISSING_OPERATOR: string = "Missing operator between expressions.";
		public static readonly EXCEPTION_PARSER_OPREQUIRESOPERAND: string = "Operator '{0}' requires an operand.";
		public static readonly EXCEPTION_PARSER_OPREQUIRESSECONDOPERAND: string = "Operator '{0}' requires a second operand.";
		public static readonly EXCEPTION_PARSER_TERNARYOPREQOPERAND: string = "Ternary operator requires three operands.";
		public static readonly EXCEPTION_PARSER_TYPENAMEEXPECTED: string = "Type name expected.";
		public static readonly EXCEPTION_PARSER_UNARYOPREQOPERAND: string = "Unary operator requires one operand.";
		public static readonly EXCEPTION_PARSER_UNEXPECTEDTOKEN: string = "Unexpected token '{0}' in current context.";
		public static readonly EXCEPTION_PARSER_UNEXPECTEDTOKENTYPE: string = "Unexpected token type '{0}'.";
		public static readonly EXCEPTION_PARSER_UNEXPECTEDTOKENWHILEBUILDINGTREE: string = "Unexpected node '{0}' encountered while building expression tree.";
		public static readonly EXCEPTION_PARSER_UNEXPECTEDTOKENWHILEOTHEREXPECTED: string = "Expected one of: {0}.";
		// Utility Errors
		public static readonly EXCEPTION_STRINGUTILS_UNEXPECTEDESCAPESEQ: string = "Unknown escape sequence '{0}'.";
		public static readonly EXCEPTION_TOKENIZER_INVALIDCHARLITERAL: string = "Invalid character literal.";
		public static readonly EXCEPTION_TOKENIZER_INVALIDSTRINGLITERAL: string = "Invalid string literal.";
		public static readonly EXCEPTION_TOKENIZER_UNEXPECTEDSYMBOL: string = "Unexpected symbol '{0}'.";
		// Unbound Expression Errors
		public static readonly EXCEPTION_UNBOUNDEXPR_DUPLICATEPARAMNAME: string = "Duplicate parameter name '{0}'.";
		public static readonly EXCEPTION_UNBOUNDEXPR_INVALIDPARAMCOUNT: string = "Invalid parameter count.";
		public static readonly EXCEPTION_UNBOUNDEXPR_TYPESDOESNTMATCHNAMES: string = "Parameter types array length does not match names array length.";
	}
	/* eslint-enable */
	export class FormulaError extends Error {
		public readonly position?: string;
		public readonly value?: string;
		public readonly innerError?: Error;
		constructor(message: string, info?: Partial<LineInfo>, innerError?: Error) {
			super(message);
			this.innerError = innerError;
			if (info?._pos) {
				this.position = info._pos;
				this.value = (<any>info).value;
			}
		}
	}
	type ExpressionConstructorFunc = new (expressionObj: any) => FormulaExpression;
	const typeMap: Map<string, ExpressionConstructorFunc> = new Map();
	export function registerExpressionType(expressionType: string, constructor: ExpressionConstructorFunc) {
		check(expressionType, 'expressionType').is.string().and.not.nullOrUndefined();
		check(constructor, 'constructor').is.function().and.not.nullOrUndefined();
		typeMap.set(expressionType, constructor);
	}
	export function getExpressionType(expressionType: string): ExpressionConstructorFunc {
		check(expressionType, 'expressionType').is.string().and.not.nullOrUndefined();
		const expressionConstructor = typeMap.get(expressionType);
		if (!expressionConstructor) {
			throw new FormulaError(formatString(ExpressionResources.EXCEPTION_BIND_UNKNOWNEXPRTYPE, expressionType));
		}
		return expressionConstructor;
	}
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetObject extends Object {
		public Equals(other: any) {
			return this === other;
		}
		public GetHashCode() {
			return 0;
		}
		public GetType(): Function {
			return Object.getPrototypeOf(this);
		}
		public ToString(): string {
			return this.toString() || '';
		}
		public static ReferenceEquals(objA: any, objB: any) {
			return Object.is(objA, objB);
		}
		public static Equals(objA: any, objB: any) {
			return objA === objB;
		}
	}
	export function inheritFromDotNetObject(type: Function) {
		// copy static functions
		for (const member in DotNetObject) {
			if (Object.prototype.hasOwnProperty.call(DotNetObject, member)) {
				const objectStaticFunc = (<any>DotNetObject)[member];
				if (!(member in type)) {
					(<any>type)[member] = objectStaticFunc;
				}
			}
		}
		// copy instance functions
		for (const member in DotNetObject.prototype) {
			if (Object.prototype.hasOwnProperty.call(DotNetObject.prototype, member)) {
				const objectInstanceFunc = (<any>DotNetObject)[member];
				if (!(member in type)) {
					(<any>type)[member] = objectInstanceFunc;
				}
			}
		}
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetArray extends Array {
		public get Count(): number {
			return this.length;
		}
		public get Length(): number {
			return this.length;
		}
		public Join(separator?: string): string {
			return this.join(separator);
		}
	}
	inheritFromDotNetObject(DotNetArray);
	export function inheritFromDotNetArray(type: Function) {
		// copy static functions
		for (const member in DotNetArray) {
			if (Object.prototype.hasOwnProperty.call(DotNetArray, member)) {
				const arrayStaticFunc = (<any>DotNetArray)[member];
				if (!(member in type)) {
					(<any>type)[member] = arrayStaticFunc;
				}
			}
		}
		// copy instance functions
		for (const member in DotNetArray.prototype) {
			if (Object.prototype.hasOwnProperty.call(DotNetArray.prototype, member)) {
				const arrayInstanceFunc = (<any>DotNetArray)[member];
				if (!(member in type)) {
					(<any>type)[member] = arrayInstanceFunc;
				}
			}
		}
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetBigInteger implements BigInt {
		[Symbol.toStringTag]: 'BigInt' = 'BigInt';
		declare static MaxValue: bigint;
		declare static MinValue: bigint;
		public static new(value: any): bigint {
			return BigInt(value);
		}
		public static is(value: any): boolean {
			return typeof (value) === 'bigint';
		}
		public static Abs(value: bigint): bigint {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return (value < 0) ? -value : value;
		}
		public static Clamp(value: bigint, min: bigint, max: bigint): bigint {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			check(min, 'min').is.bigint().and.not.nullOrUndefined();
			check(max, 'max').is.bigint().and.not.nullOrUndefined();
			return value < min ? min : value > max ? max : value;
		}
		public CompareTo(value?: bigint): number {
			if (typeof value !== 'bigint') {
				return 1;
			}
			const thisValue = DotNetBigInteger.toBigInt(this);
			return thisValue > value ? 1 : thisValue === value ? 0 : -1;
		}
		public Equals(value?: bigint): boolean {
			if (typeof value !== 'bigint') {
				return false;
			}
			return DotNetBigInteger.toBigInt(this) === value;
		}
		public static CopySign(value: bigint, sign: bigint): bigint {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			check(sign, 'sign').is.bigint().and.not.nullOrUndefined();
			let num = value;
			if (num < 0) {
				num = -num;
			}
			if (sign >= 0) {
				return num;
			}
			return -num;
		}
		public static IsEvenInteger(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return (value & 1n) === 0n;
		}
		public static IsNegative(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return value < 0n;
		}
		public static IsOddInteger(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return (value & 1n) !== 0n;
		}
		public static IsPositive(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return value >= 0n;
		}
		public static IsPow2(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			if ((value & (value - 1n)) === 0n) {
				return value > 0n;
			}
			return false;
		}
		public static Log2(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			let result = 0n, i, v;
			for (i = 1n; value >> (1n << i); i <<= 1n) { }
			while (value > 1n) {
				v = 1n << --i;
				if (value >> v) {
					result += v;
					value >>= v;
				}
			}
			return result;
		}
		public static Max(x: bigint, y: bigint) {
			check(x, 'x').is.bigint().and.not.nullOrUndefined();
			check(y, 'y').is.bigint().and.not.nullOrUndefined();
			return x > y ? x : y;
		}
		public static MaxMagnitude(x: bigint, y: bigint) {
			check(x, 'x').is.bigint().and.not.nullOrUndefined();
			check(y, 'y').is.bigint().and.not.nullOrUndefined();
			const num = DotNetBigInteger.Abs(x);
			const num2 = DotNetBigInteger.Abs(y);
			if (num > num2) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return x;
				}
				return y;
			}
			return y;
		}
		public static Min(x: bigint, y: bigint) {
			check(x, 'x').is.bigint().and.not.nullOrUndefined();
			check(y, 'y').is.bigint().and.not.nullOrUndefined();
			return x < y ? x : y;
		}
		public static MinMagnitude(x: bigint, y: bigint) {
			check(x, 'x').is.bigint().and.not.nullOrUndefined();
			check(y, 'y').is.bigint().and.not.nullOrUndefined();
			const num = DotNetBigInteger.Abs(x);
			const num2 = DotNetBigInteger.Abs(y);
			if (num < num2 || Number.isNaN(num)) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return y;
				}
				return x;
			}
			return y;
		}
		public static Parse(s: string): bigint {
			check(s, 's').is.string().and.not.nullOrUndefined();
			return BigInt(s);
		}
		public static Sign(value: bigint) {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return value === 0n ? 0n : value < 0n ? -1n : 1n;
		}
		toString(radix?: number | undefined): string {
			return DotNetBigInteger.toBigInt(this).toString(radix);
		}
		toLocaleString(locales?: Intl.LocalesArgument, options?: BigIntToLocaleStringOptions | undefined): string {
			return DotNetBigInteger.toBigInt(this).toLocaleString(locales, options);
		}
		valueOf(): bigint {
			return DotNetBigInteger.toBigInt(this).valueOf();
		}
		static toBigInt(arg0: BigInt | bigint | number) {
			if (arg0 instanceof BigInt) {
				return arg0.valueOf();
			} else if (typeof (arg0) === 'bigint') {
				return arg0;
			} else {
				return BigInt(arg0);
			}
		}
		public ToString() {
			return DotNetBigInteger.toBigInt(this).toString(10);
		}
	}
	inheritFromDotNetObject(DotNetBigInteger);
	export class DotNetInt64 extends DotNetBigInteger {
		public static MaxValue = 9223372036854775807n;
		public static MinValue = -9223372036854775808n;
	}
	export class DotNetUInt64 extends DotNetBigInteger {
		public static MaxValue = 18446744073709551615n;
		public static MinValue = 0n;
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetBoolean extends Boolean {
		public static new(value: any): boolean {
			return Boolean(value);
		}
		public static is(value: any): boolean {
			return typeof value === 'boolean';
		}
		public CompareTo(value?: boolean): number {
			if (typeof value !== 'boolean') {
				return 1;
			}
			const thisValue = typeof (this) === 'boolean' ? this : this.valueOf();
			return thisValue > value ? 1 : thisValue === value ? 0 : -1;
		}
		public Equals(value?: boolean): boolean {
			if (typeof value !== 'boolean') {
				return false;
			}
			const thisValue = typeof (this) === 'boolean' ? this : this.valueOf();
			return thisValue === value;
		}
		public ToString(): string {
			const thisValue = typeof (this) === 'boolean' ? this : this.valueOf();
			return thisValue ? 'True' : 'False';
		}
		public static Parse(value: string): boolean {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			return Boolean(value);
		}
	}
	inheritFromDotNetObject(DotNetBoolean);
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	const nanosecondsPerMillisecond = 1000000n;
	const microsecondsPerMillisecond = 1000n;
	const ticksPerMillisecond = 10000n;
	export class DotNetDate extends Date {
		public static MaxValue = new Date(8640000000000000);
		public static MinValue = new Date(-8640000000000000);
		public static UnixEpoch = new Date(0);
		public static toDate(value: any): Date {
			return value instanceof Date ? value : new Date(value);
		}
		public static new(value: any): Date {
			return DotNetDate.toDate(value);
		}
		public static is(value: any): boolean {
			return value instanceof Date;
		}
		public get Date(): Date {
			const date = new Date(DotNetDate.toDate(this).getTime());
			date.setUTCHours(0, 0, 0, 0);
			return date;
		}
		public get Day(): number {
			return DotNetDate.toDate(this).getUTCDay();
		}
		public get DayOfWeek(): DayOfWeek {
			const time = DotNetDate.toDate(this).getTime();
			const ticks = BigInt(time) * ticksPerMillisecond;
			const dayOfWeek = ((ticks / 864000000000n) + 1n) % 7n;
			return Number(dayOfWeek) as DayOfWeek;
		}
		public get DayOfYear(): number {
			const time = DotNetDate.toDate(this).getTime();
			const ticks = BigInt(time) * ticksPerMillisecond;
			const dayOfYear = (1n + ((((ticks / 216000000000n) | 3n) % 146097n) | 3n) * 2939745n / 11758980n);
			return Number(dayOfYear);
		}
		public get Hour(): number {
			return DotNetDate.toDate(this).getUTCHours();
		}
		public get Microsecond(): bigint {
			const time = DotNetDate.toDate(this).getMilliseconds();
			return BigInt(time) * microsecondsPerMillisecond;
		}
		public get Millisecond(): number {
			return DotNetDate.toDate(this).getUTCMilliseconds();
		}
		public get Minute(): number {
			return DotNetDate.toDate(this).getUTCMinutes();
		}
		public get Month(): number {
			return DotNetDate.toDate(this).getUTCMonth();
		}
		public get Nanosecond(): bigint {
			const time = DotNetDate.toDate(this).getMilliseconds();
			return BigInt(time) * nanosecondsPerMillisecond;
		}
		public get Second(): number {
			return DotNetDate.toDate(this).getUTCSeconds();
		}
		public get Ticks(): bigint {
			const time = DotNetDate.toDate(this).getTime();
			return BigInt(time) * ticksPerMillisecond;
		}
		public get TimeOfDay(): TimeSpan {
			const time = DotNetDate.toDate(this).getTime();
			const day = new Date(time);
			day.setUTCHours(0, 0, 0, 0);
			const msDiff = BigInt(time - day.getTime());
			return new TimeSpan(msDiff * ticksPerMillisecond);
		}
		public get Year(): number {
			return DotNetDate.toDate(this).getUTCFullYear();
		}
		public static get Today(): Date {
			const now = new Date();
			now.setUTCHours(0, 0, 0, 0);
			return now;
		}
		public static get UtcNow(): Date {
			return new Date();
		}
		public static get Now(): Date {
			return new Date();
		}
		public CompareTo(value?: Date): number {
			if (!(value instanceof Date)) {
				return 1;
			}
			const thisValue = DotNetDate.toDate(this);
			return thisValue > value ? 1 : thisValue === value ? 0 : -1;
		}
		public Equals(value?: Date): boolean {
			if (!(value instanceof Date)) {
				return false;
			}
			const thisValue = DotNetDate.toDate(this);
			return thisValue === value;
		}
		public ToString(): string {
			const thisValue = DotNetDate.toDate(this);
			return thisValue.toISOString();
		}
		public static Parse(value: string): Date {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			return new Date(value);
		}
	}
	inheritFromDotNetObject(DotNetDate);
	export enum DayOfWeek {
		Sunday,
		Monday,
		Tuesday,
		Wednesday,
		Thursday,
		Friday,
		Saturday
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	type Enum<E> = Record<keyof E, number | string> & { [k: number]: string };
	interface AnyEnum { [k: string | number]: number | string }
	export class DotNetEnum<T extends Enum<T>> {
		public static Parse(enumType: AnyEnum, value: string, ignoreCase?: boolean) {
			if (typeof value === 'string' && ignoreCase === true) {
				for (const label in enumType) {
					if (!Object.prototype.hasOwnProperty.call(enumType, label)) {
						continue;
					}
					if (value.toLowerCase() !== label) {
						continue;
					}
					return enumType[label];
				}
			}
			if (typeof value === 'string' && value in enumType) {
				return enumType[value];
			} if (typeof value === 'number' && value in enumType) {
				return value;
			} else {
				throw new Error(`Unexpected value '${value}'[${typeof value}] for enum.`);
			}
		}
		public Equals(other?: any) {
			return this === other;
		}
		public ToString() {
			return this.toString();
		}
	}
	export function createDotNetEnum<T extends Enum<T>>(enumType: T): Function {
		const newEnumType = function DotNetEnumInstance() {
			return 0;
		};
		newEnumType.prototype = DotNetEnum;
		newEnumType.new = function (value: any) {
			return DotNetEnum.Parse(enumType, value, true);
		};
		newEnumType.is = function (value: any) {
			return typeof value === 'number';
		};
		inheritFromDotNetObject(newEnumType);
		// copy labels
		for (const label of Object.keys(enumType)) {
			if (/^\+?(0|[1-9]\d*)$/.test(label)) {
				continue;
			}
			(<any>newEnumType)[label] = enumType[label as keyof T];
		}
		return newEnumType;
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetMath {
		public static E = 2.71828175;
		public static PI = 3.14159274;
		public static Tau = 6.28318548;
		public static Abs(value: number): number {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return Math.abs(value);
		}
		public static Acos(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.acos(d);
		}
		public static Acosh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.acosh(d);
		}
		public static Asin(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.asin(d);
		}
		public static Asinh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.asinh(d);
		}
		public static Atan(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.atan(d);
		}
		public static Atan2(y: number, x: number): number {
			check(y, 'y').is.number().and.not.nullOrUndefined();
			check(x, 'x').is.number().and.not.nullOrUndefined();
			return Math.atan2(y, x);
		}
		public static Atanh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.atanh(d);
		}
		public static BigMul(a: bigint, b: bigint): bigint;
		public static BigMul(a: number | bigint, b: number | bigint): number | bigint {
			if (typeof (a) === 'bigint' || typeof (b) === 'bigint') {
				return BigInt(a) * BigInt(b);
			} else {
				check(a, 'a').is.number().and.not.nullOrUndefined();
				check(b, 'b').is.number().and.not.nullOrUndefined();
				return a * b;
			}
		}
		public static Cbrt(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.cbrt(d);
		}
		public static Ceiling(a: number): number {
			check(a, 'a').is.number().and.not.nullOrUndefined();
			return Math.ceil(a);
		}
		public static Clamp(value: number, min: number, max: number): number {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			check(min, 'min').is.number().and.not.nullOrUndefined();
			check(max, 'max').is.number().and.not.nullOrUndefined();
			if (value < min) {
				return min;
			} else if (value > max) {
				return max;
			} else {
				return value;
			}
		}
		public static CopySign(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			if (y < 0 && x > 0) {
				return -x;
			} else if (y > 0 && x < 0) {
				return -x;
			} else {
				return x;
			}
		}
		public static MaxMagnitude(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			const num = Math.abs(x);
			const num2 = Math.abs(y);
			if (num > num2 || Number.isNaN(num)) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return x;
				}
				return y;
			}
			return y;
		}
		public static MinMagnitude(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			const num = Math.abs(x);
			const num2 = Math.abs(y);
			if (num < num2 || Number.isNaN(num)) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return y;
				}
				return x;
			}
			return y;
		}
		public static Cos(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.cos(d);
		}
		public static Cosh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.cosh(d);
		}
		public static DivRem(left: number, right: number): [number, number] {
			check(left, 'left').is.number().and.not.nullOrUndefined();
			check(right, 'right').is.number().and.not.nullOrUndefined();
			const num = (left / right) | 0;
			return [num, (left - num * right) | 0];
		}
		public static Exp(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.exp(d);
		}
		public static Floor(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.floor(d);
		}
		public static FusedMultiplyAdd(x: number, y: number, z: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			check(z, 'z').is.number().and.not.nullOrUndefined();
			return (x * y) + z;
		}
		public static IEEERemainder(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			if (Number.isNaN(x)) {
				return x;
			}
			if (Number.isNaN(y)) {
				return y;
			}
			const num = x % y;
			if (Number.isNaN(num)) {
				return Number.NaN;
			}
			if (num === 0.0 && Math.sign(x) < 0) {
				return -0.0;
			}
			const num2 = num - Math.abs(y) * Math.sign(x);
			if (Math.abs(num2) === Math.abs(num)) {
				const num3 = x / y;
				const value = Math.round(num3);
				if (Math.abs(value) > Math.abs(num3)) {
					return num2;
				}
				return num;
			}
			if (Math.abs(num2) < Math.abs(num)) {
				return num2;
			}
			return num;
		}
		public static Log(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.log(d);
		}
		public static Log2(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.log2(d);
		}
		public static Log10(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.log10(d);
		}
		public static Max(val1: number, val2: number): number {
			check(val1, 'val1').is.number().and.not.nullOrUndefined();
			check(val2, 'val2').is.number().and.not.nullOrUndefined();
			return val1 < val2 ? val2 : val1;
		}
		public static Min(val1: number, val2: number): number {
			check(val1, 'val1').is.number().and.not.nullOrUndefined();
			check(val2, 'val2').is.number().and.not.nullOrUndefined();
			return val1 < val2 ? val1 : val2;
		}
		public static Pow(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return Math.pow(x, y);
		}
		public static ReciprocalEstimate(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return 1.0 / d;
		}
		public static ReciprocalSqrtEstimate(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return 1.0 / Math.sqrt(d);
		}
		public static Round(d: number, digits?: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			if (typeof digits === 'number' && digits > 0) {
				const scale = 10 ** digits;
				return Math.round((d + Number.EPSILON) * scale) / scale;
			} else {
				check(digits, 'digits').is.nullOrUndefined();
				return Math.round(d);
			}
		}
		public static Sign(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.sign(d);
		}
		public static Sin(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.sin(d);
		}
		public static SinCos(d: number): [number, number] {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return [Math.sin(d), Math.cos(d)];
		}
		public static Sinh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.sinh(d);
		}
		public static Sqrt(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.sqrt(d);
		}
		public static Tan(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.tan(d);
		}
		public static Tanh(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.tanh(d);
		}
		public static Truncate(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Math.trunc(d);
		}
	}
	inheritFromDotNetObject(DotNetMath);
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetInteger extends Number {
		declare static MaxValue: number;
		declare static MinValue: number;
		public static new(value: any): number {
			return Number.parseInt(value, 10);
		}
		public static is(value: any): boolean {
			return typeof (value) === 'number';
		}
		public static Abs(value: number): number {
			return DotNetMath.Abs(value);
		}
		public static Clamp(value: number, min: number, max: number): number {
			return DotNetMath.Clamp(value, min, max);
		}
		public CompareTo(value?: number): number {
			if (typeof value !== 'number') {
				return 1;
			}
			const thisValue = typeof (this) === 'number' ? this : this.valueOf();
			if (Number.isNaN(thisValue)) {
				if (!Number.isNaN(value)) {
					return -1;
				}
				return 0;
			}
			return thisValue > value ? 1 : thisValue === value ? 0 : -1;
		}
		public Equals(value?: number): boolean {
			if (typeof value !== 'number') {
				return false;
			}
			const thisValue = typeof (this) === 'number' ? this : this.valueOf();
			return thisValue === value;
		}
		public static CopySign(value: number, sign: number): number {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			check(sign, 'sign').is.number().and.not.nullOrUndefined();
			let num = value;
			if (num < 0) {
				num = -num;
			}
			if (sign >= 0) {
				return num;
			}
			return -num;
		}
		public static IsEvenInteger(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return (value & 1) === 0;
		}
		public static IsNegative(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return value < 0;
		}
		public static IsOddInteger(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return (value & 1) !== 0;
		}
		public static IsPositive(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return value >= 0;
		}
		public static IsPow2(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			if ((value & (value - 1)) === 0) {
				return value > 0;
			}
			return false;
		}
		public static Log2(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetMath.Log2(value) | 0;
		}
		public static Max(x: number, y: number) {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return DotNetMath.Max(x, y) | 0;
		}
		public static MaxMagnitude(x: number, y: number) {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return DotNetMath.MaxMagnitude(x, y) | 0;
		}
		public static Min(x: number, y: number) {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return DotNetMath.Min(x, y) | 0;
		}
		public static MinMagnitude(x: number, y: number) {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return DotNetMath.MinMagnitude(x, y) | 0;
		}
		public static Parse(s: string): number {
			check(s, 's').is.string().and.not.nullOrUndefined();
			return Number.parseInt(s, 10);
		}
		public static Sign(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetMath.Sign(value) | 0;
		}
		public ToString() {
			const thisValue = typeof (this) === 'number' ? this : this.valueOf();
			return (thisValue | 0).toString(10);
		}
	}
	inheritFromDotNetObject(DotNetInteger);
	export class DotNetInt8 extends DotNetInteger {
		public static MaxValue = 127;
		public static MinValue = -128;
	}
	export class DotNetUInt8 extends DotNetInteger {
		public static MaxValue = 255;
		public static MinValue = 0;
	}
	export class DotNetInt16 extends DotNetInteger {
		public static MaxValue = 32767;
		public static MinValue = -32768;
	}
	export class DotNetUInt16 extends DotNetInteger {
		public static MaxValue = 65535;
		public static MinValue = 0;
	}
	export class DotNetChar extends DotNetInteger {
		public static MaxValue = 65535;
		public static MinValue = 0;
		public ToString() {
			return DotNetChar.prototype.toString.apply(this);
		}
		public toString(): string {
			const thisValue = typeof (this) === 'number' ? this : this.valueOf();
			return String.fromCharCode(thisValue);
		}
	}
	export class DotNetInt32 extends DotNetInteger {
		public static MaxValue = 2147483647;
		public static MinValue = -2147483648;
	}
	export class DotNetUInt32 extends DotNetInteger {
		public static MaxValue = 4294967295;
		public static MinValue = 0;
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetFloat32 extends DotNetInteger {
		public static MaxValue = 3.40282347E+38;
		public static MinValue = -3.40282347E+38;
		public static E = 2.71828175;
		public static Epsilon = 1.401298E-45;
		public static NegativeInfinity = -1.0 / 0.0;
		public static NegativeZero = -0;
		public static Pi = 3.14159274;
		public static PositiveInfinity = 1.0 / 0.0;
		public static Tau = 6.28318548;
		public static new(value: any): number {
			return Number(value);
		}
		public static Acos(d: number): number {
			return DotNetMath.Acos(d);
		}
		public static Acosh(d: number): number {
			return DotNetMath.Acosh(d);
		}
		public static AcosPi(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return DotNetMath.Acos(d) / DotNetMath.PI;
		}
		public static Asin(d: number): number {
			return DotNetMath.Asin(d);
		}
		public static Asinh(d: number): number {
			return DotNetMath.Asinh(d);
		}
		public static AsinPi(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return DotNetMath.Asin(d) / DotNetMath.PI;
		}
		public static Atan(d: number): number {
			return DotNetMath.Atan(d);
		}
		public static Atan2(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return Math.atan2(x, y);
		}
		public static Atan2Pi(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return Math.atan2(x, y) / DotNetMath.PI;
		}
		public static Atanh(d: number): number {
			return DotNetMath.Atanh(d);
		}
		public static AtanPi(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return DotNetMath.Atan(d) / DotNetMath.PI;
		}
		public static Cbrt(d: number): number {
			return DotNetMath.Cbrt(d);
		}
		public static Ceiling(d: number): number {
			return DotNetMath.Ceiling(d);
		}
		public static Clamp(value: number, min: number, max: number): number {
			return DotNetMath.Clamp(value, min, max);
		}
		public static Cos(d: number): number {
			return DotNetMath.Cos(d);
		}
		public static Cosh(d: number): number {
			return DotNetMath.Cosh(d);
		}
		public static CosPi(d: number): number {
			return DotNetMath.Cos(d) / DotNetMath.PI;
		}
		public static Exp(d: number): number {
			return DotNetMath.Exp(d);
		}
		public static Exp2(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d ** 2;
		}
		public static Exp2M1(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return (d ** 2) - 1;
		}
		public static Exp10(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d ** 10;
		}
		public static Exp10M1(d: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return (d ** 10) - 1;
		}
		public static ExpM1(d: number): number {
			return DotNetMath.Exp(d) - 1;
		}
		public static Floor(d: number): number {
			return DotNetMath.Floor(d);
		}
		public static FusedMultiplyAdd(x: number, y: number, z: number): number {
			return DotNetMath.FusedMultiplyAdd(x, y, z);
		}
		public static Hypot(x: number, y: number): number {
			if (Number.isFinite(x) && Number.isFinite(y)) {
				const num = DotNetMath.Abs(x);
				const num2 = DotNetMath.Abs(y);
				if (num === 0) {
					return num2;
				}
				if (num2 === 0) {
					return num;
				}
				let num3 = num;
				num3 *= num3;
				let num4 = num2;
				num4 *= num4;
				return DotNetMath.Sqrt(num3 + num4);
			}
			if (!Number.isFinite(x) || !Number.isFinite(y)) {
				return DotNetFloat32.PositiveInfinity;
			}
			return DotNetFloat32.NaN;
		}
		public static Ieee754Remainder(left: number, right: number): number {
			return DotNetMath.IEEERemainder(left, right);
		}
		public static IsEvenInteger(value: number) {
			if (DotNetFloat32.IsInteger(value)) {
				return DotNetMath.Abs(value % 2) === 0;
			}
			return false;
		}
		public static IsFinite(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return Number.isFinite(d);
		}
		public static IsInfinity(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return !Number.isFinite(d);
		}
		public static IsInteger(value: number) {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			if (Number.isFinite(value)) {
				return value === (value | 0);
			}
			return false;
		}
		public static IsNaN(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return !Number.isNaN(d);
		}
		public static IsNegative(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d < 0;
		}
		public static IsNegativeInfinity(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d === Number.NEGATIVE_INFINITY;
		}
		public static IsOddInteger(value: number) {
			if (DotNetFloat32.IsInteger(value)) {
				return DotNetMath.Abs(value % 2) === 1;
			}
			return false;
		}
		public static IsPositive(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d >= 0;
		}
		public static IsPositiveInfinity(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d === Number.NEGATIVE_INFINITY;
		}
		public static IsRealNumber(d: number) {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			return d === d;
		}
		public static Log(d: number, newBase?: number): number {
			check(d, 'd').is.number().and.not.nullOrUndefined();
			if (typeof newBase === 'number') {
				if (Number.isNaN(d)) {
					return d;
				}
				if (Number.isNaN(newBase)) {
					return newBase;
				}
				if (newBase === 1) {
					return Number.NaN;
				}
				if (d !== 1 && (newBase === 0 || newBase === Number.POSITIVE_INFINITY)) {
					return Number.NaN;
				}
				return DotNetMath.Log(d) / DotNetMath.Log(newBase);
			} else {
				return DotNetMath.Log(d);
			}
		}
		public static Log2(d: number): number {
			return DotNetMath.Log2(d);
		}
		public static Log2P1(d: number): number {
			return DotNetMath.Log2(d + 1);
		}
		public static Log10(d: number): number {
			return DotNetMath.Log10(d);
		}
		public static Log10P1(d: number): number {
			return DotNetMath.Log10(d + 1);
		}
		public static LogP1(d: number): number {
			return DotNetMath.Log(d + 1);
		}
		public static Max(x: number, y: number): number {
			return DotNetMath.Max(x, y);
		}
		public static MaxNumber(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			if (x !== y) {
				if (!Number.isNaN(y)) {
					if (!(y < x)) {
						return y;
					}
					return x;
				}
				return x;
			}
			if (y >= 0) {
				return y;
			}
			return x;
		}
		public static MaxMagnitude(x: number, y: number): number {
			return DotNetMath.MaxMagnitude(x, y);
		}
		public static MaxMagnitudeNumber(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			const num = DotNetMath.Abs(x);
			const num2 = DotNetMath.Abs(y);
			if (num > num2 || Number.isNaN(num2)) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return x;
				}
				return y;
			}
			return y;
		}
		public static Min(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			return DotNetMath.Min(x, y);
		}
		public static MinNumber(x: number, y: number): number {
			check(x, 'x').is.number().and.not.nullOrUndefined();
			check(y, 'y').is.number().and.not.nullOrUndefined();
			if (x !== y) {
				if (!Number.isNaN(y)) {
					if (!(x < y)) {
						return y;
					}
					return x;
				}
				return x;
			}
			if (x >= 0) {
				return y;
			}
			return x;
		}
		public static MinMagnitude(x: number, y: number): number {
			return DotNetMath.MinMagnitude(x, y);
		}
		public static MinMagnitudeNumber(x: number, y: number): number {
			const num = DotNetMath.Abs(x);
			const num2 = DotNetMath.Abs(y);
			if (num < num2 || Number.isNaN(num2)) {
				return x;
			}
			if (num === num2) {
				if (x >= 0) {
					return y;
				}
				return x;
			}
			return y;
		}
		public static Parse(s: string): number {
			check(s, 's').is.string().and.not.nullOrUndefined();
			return Number.parseFloat(s);
		}
		public static Pow(x: number, y: number): number {
			return DotNetMath.Pow(x, y);
		}
		public static Round(x: number, digits?: number): number {
			return DotNetMath.Round(x, digits);
		}
		public static Sign(d: number): number {
			return DotNetMath.Sign(d);
		}
		public static Sin(d: number): number {
			return DotNetMath.Sin(d);
		}
		public static SinCos(d: number) {
			return DotNetMath.SinCos(d);
		}
		public static Sinh(d: number): number {
			return DotNetMath.Sinh(d);
		}
		public static SinPi(d: number): number {
			return DotNetMath.Sin(d) / DotNetMath.PI;
		}
		public static Sqrt(d: number): number {
			return DotNetMath.Sqrt(d);
		}
		public static Tan(d: number): number {
			return DotNetMath.Tan(d);
		}
		public static Tanh(d: number): number {
			return DotNetMath.Tanh(d);
		}
		public static TanPi(d: number): number {
			return DotNetMath.Tan(d) / DotNetMath.PI;
		}
		public static Truncate(d: number): number {
			return DotNetMath.Truncate(d);
		}
		public ToString() {
			const thisValue = typeof (this) === 'number' ? this : this.valueOf();
			return thisValue.toString();
		}
	}
	export class DotNetFloat64 extends DotNetFloat32 {
		public static MaxValue = 1.7976931348623157E+308;
		public static MinValue = -1.7976931348623157E+308;
		public static E = 2.7182818284590451;
		public static Epsilon = 4.94065645841247E-324;
		public static NegativeInfinity = -1.0 / 0.0;
		public static NegativeZero = -0;
		public static Pi = 3.1415926535897931;
		public static PositiveInfinity = 1.0 / 0.0;
		public static Tau = 6.2831853071795862;
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetString extends String {
		// used in constructor
		public static new(value: any): string {
			return value + '';
		}
		// used in 'type is' expression
		public static is(value: any): boolean {
			return typeof (value) === 'string';
		}
		public CompareTo(value: any): number {
			return this.toString().localeCompare(value);
		}
		public Contains(value: string, comparisonType?: StringComparison): boolean {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			value = changeStringCasing(value, comparisonType) ?? '';
			const thisValue = changeStringCasing(this.toString(), comparisonType) ?? '';
			return thisValue.indexOf(value) >= 0;
		}
		public EndsWith(value: string, comparisonType?: StringComparison): boolean {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			value = changeStringCasing(value, comparisonType) ?? '';
			const thisValue = changeStringCasing(this.toString(), comparisonType) ?? '';
			return thisValue.endsWith(value);
		}
		public Equals(value: any, comparisonType?: StringComparison): boolean {
			if (typeof value === 'string') {
				const thisValue = this.toString() ?? '';
				if (comparisonType === StringComparison.Ordinal ||
					comparisonType === StringComparison.OrdinalIgnoreCase) {
					return DotNetString.CompareOrdinal(thisValue, value) === 0;
				} else {
					return DotNetString.Compare(thisValue, value, comparisonType) === 0;
				}
			}
			return false;
		}
		public GetHashCode(comparisonType?: StringComparison): number {
			const value = changeStringCasing(this.toString(), comparisonType) ?? '';
			if (!value) {
				return 0;
			}
			let hashCode = 0;
			for (let i = 0, len = value.length; i < len; i++) {
				// eslint-disable-next-line no-bitwise
				hashCode = (31 * hashCode + value.charCodeAt(i)) << 0;
			}
			return hashCode;
		}
		public IndexOf(value: string, comparisonType?: StringComparison): number {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			value = changeStringCasing(this.toString(), comparisonType) ?? '';
			const thisValue = changeStringCasing(this.toString(), comparisonType) ?? '';
			return thisValue.indexOf(value);
		}
		public LastIndexOf(value: string, comparisonType?: StringComparison): number {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			value = changeStringCasing(this.toString(), comparisonType) ?? '';
			const thisValue = changeStringCasing(this.toString(), comparisonType) ?? '';
			return thisValue.lastIndexOf(value);
		}
		public IndexOfAny(...values: string[]): number {
			const thisValue = this.toString();
			for (const value of values) {
				const index = thisValue.indexOf(value);
				if (index >= 0) {
					return index;
				}
			}
			return -1;
		}
		public LastIndexOfAny(...values: string[]): number {
			const thisValue = this.toString();
			for (const value of values) {
				const index = thisValue.lastIndexOf(value);
				if (index >= 0) {
					return index;
				}
			}
			return -1;
		}
		public Insert(index: number, value: string): string {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			check(index, 'index').is.number().and.not.nullOrUndefined();
			const thisValue = this.toString();
			return thisValue.substring(0, index) + value + thisValue.substring(index);
		}
		public static Format(format: string, ...args: any[]): string {
			check(format, 'format').is.string().and.not.nullOrUndefined();
			return formatString(format, args);
		}
		public static Equals(value1: string | null | undefined, value2: string | null | undefined,
			comparisonType?: boolean | StringComparison): boolean {
			value1 = changeStringCasing(value1, comparisonType);
			value2 = changeStringCasing(value2, comparisonType);
			if (comparisonType === StringComparison.Ordinal ||
				comparisonType === StringComparison.OrdinalIgnoreCase) {
				return DotNetString.CompareOrdinal(value1, value2) === 0;
			}
			return (value1 ?? '').localeCompare(value2 ?? '') === 0;
		}
		public static Compare(value1: string | null | undefined, value2: string | null | undefined,
			comparisonType?: boolean | StringComparison): number {
			value1 = changeStringCasing(value1, comparisonType);
			value2 = changeStringCasing(value2, comparisonType);
			if (comparisonType === StringComparison.Ordinal ||
				comparisonType === StringComparison.OrdinalIgnoreCase) {
				return DotNetString.CompareOrdinal(value1, value2);
			}
			return (value1 ?? '').localeCompare(value2 ?? '');
		}
		public static CompareOrdinal(value1: string | null | undefined, value2: string | null | undefined) {
			const xIsNull = (value1 === undefined || value1 === null);
			const yIsNull = (value2 === undefined || value2 === null);
			if (xIsNull && yIsNull) {
				return 0;
			} else if (!xIsNull && yIsNull) {
				return 1;
			} else if (xIsNull && !yIsNull) {
				return -1;
			}
			value1 = value1 ?? '';
			value2 = value2 ?? '';
			return value1 > value2 ? 1 : value1 === value2 ? 0 : -1;
		}
		public static Concat(...args: any[]) {
			let result = '';
			for (const argument of args) {
				result += (argument ?? '') + '';
			}
			return result;
		}
		public static IsNullOrEmpty(value: string | null | undefined): boolean {
			return value === '' || typeof (value) !== 'string';
		}
		public static IsNullOrWhiteSpace(value: string | null | undefined): boolean {
			return typeof (value) !== 'string' || value.trim().length === 0;
		}
		public static Join(separator: string, values: string[], startIndex?: number, count?: number): string {
			check(separator, 'separator').is.string().and.not.nullOrUndefined();
			if (typeof startIndex != 'number') {
				startIndex = 0;
			}
			if (typeof count != 'number') {
				count = values.length - startIndex;
			}
			if (startIndex !== 0 || count !== values.length) {
				values = values.slice(startIndex, startIndex + count);
			}
			return values.join(separator);
		}
		public PadLeft(totalWidth: number, paddingChar: string): string {
			check(totalWidth, 'totalWidth').is.number().and.not.nullOrUndefined();
			const thisValue = this.toString();
			return thisValue.padStart(totalWidth, paddingChar);
		}
		public PadRight(totalWidth: number, paddingChar: string): string {
			check(totalWidth, 'totalWidth').is.number().and.not.nullOrUndefined();
			const thisValue = this.toString();
			return thisValue.padEnd(totalWidth, paddingChar);
		}
		public Remove(startIndex: number, count?: number): string {
			check(startIndex, 'startIndex').is.number().and.not.nullOrUndefined();
			const thisValue = this.toString();
			const left = thisValue.substring(0, startIndex);
			let right = '';
			if (typeof count == 'number') {
				right = thisValue.substring(startIndex + count);
			}
			return left + right;
		}
		public Replace(oldValue: string, newValue: string, comparisonType?: boolean | StringComparison): string {
			check(oldValue, 'oldValue').is.string().and.not.nullOrUndefined();
			check(newValue, 'newValue').is.string().and.not.nullOrUndefined();
			const thisValue = this.toString();
			const flags = isCaseInsensitive(comparisonType) ? 'gi' : 'g';
			return thisValue.replace(new RegExp(oldValue, flags), newValue);
		}
		public ReplaceLineEndings(replacementText?: string): string {
			replacementText = replacementText ?? '\r\n';
			const thisValue = this.toString();
			return thisValue.replace(/\r\n/g, '\n').replace(/\n/g, replacementText);
		}
		public Split(separator: string | string[], options?: StringSplitOptions) {
			if (typeof separator == 'string') {
				separator = [separator];
			}
			check(separator, 'separator').is.array().and.not.empty().nullOrUndefined();
			let thisValue = this.toString();
			for (let index = 1; index < separator.length; index++) {
				thisValue = thisValue.replace(separator[index], separator[0]);
			}
			let splitted = thisValue.split(separator[0]);
			if (options && (options & StringSplitOptions.TrimEntries) !== 0) {
				splitted = splitted.map(value => value?.trim()).filter(value => typeof value === 'string');
			}
			if (options && (options & StringSplitOptions.RemoveEmptyEntries) !== 0) {
				splitted = splitted.filter(value => typeof value === 'string' && value.length > 0);
			}
			return splitted;
		}
		public StartsWith(value: string, comparisonType?: boolean | StringComparison): boolean {
			check(value, 'value').is.string().and.not.nullOrUndefined();
			value = changeStringCasing(value, comparisonType) ?? value;
			const thisValue = changeStringCasing(this.toString(), comparisonType) ?? '';
			return thisValue.startsWith(value);
		}
		public Substring(startIndex: number, length?: number): string {
			check(startIndex, 'startIndex').is.number().and.not.nullOrUndefined();
			const thisValue = this.toString();
			if (typeof length === 'number') {
				return thisValue.substring(startIndex, startIndex + length);
			} else {
				return thisValue.substring(startIndex);
			}
		}
		public ToCharArray(startIndex?: number, length?: number): string[] {
			const chars = this.toString().split('');
			if (typeof startIndex === 'number' && typeof length === 'number') {
				return chars.slice(startIndex, startIndex + length);
			}
			return chars;
		}
		public ToLower(): string {
			return this.toString().toLocaleLowerCase();
		}
		public ToLowerInvariant(): string {
			return this.toString().toLowerCase();
		}
		public ToString(): string {
			return this.toString();
		}
		public ToUpper(): string {
			return this.toString().toLocaleUpperCase();
		}
		public ToUpperInvariant(): string {
			return this.toString().toUpperCase();
		}
		public Trim(chars?: string | string[]): string {
			if (!chars) {
				return this.toString().trim();
			}
			if (typeof chars === 'string') {
				chars = [chars];
			}
			const thisValue = this.toString();
			let fromStart = 0;
			let fromEnd = thisValue.length;
			for (let index = 0; index < thisValue.length; index++) {
				const char = thisValue[index];
				if (chars.indexOf(char) < 0) {
					break;
				}
				fromStart++;
			}
			for (let index = thisValue.length - 1; index >= 0; index--) {
				const char = thisValue[index];
				if (chars.indexOf(char) < 0) {
					break;
				}
				fromEnd--;
			}
			if (fromEnd <= fromStart) {
				return '';
			}
			return thisValue.substring(fromStart, fromEnd);
		}
		public TrimEnd(chars?: string | string[]): string {
			if (!chars) {
				return this.toString().trimEnd();
			}
			if (typeof chars === 'string') {
				chars = [chars];
			}
			const thisValue = this.toString();
			let fromEnd = thisValue.length;
			for (let index = thisValue.length - 1; index >= 0; index--) {
				const char = thisValue[index];
				if (chars.indexOf(char) < 0) {
					break;
				}
				fromEnd--;
			}
			if (fromEnd <= 0) {
				return '';
			}
			return thisValue.substring(0, fromEnd);
		}
		public TrimStart(chars?: string | string[]): string {
			if (!chars) {
				return this.toString().trim();
			}
			if (typeof chars === 'string') {
				chars = [chars];
			}
			const thisValue = this.toString();
			let fromStart = 0;
			for (let index = 0; index < thisValue.length; index++) {
				const char = thisValue[index];
				if (chars.indexOf(char) < 0) {
					break;
				}
				fromStart++;
			}
			return thisValue.substring(fromStart);
		}
	}
	function isCaseInsensitive(comparisonType?: StringComparison | boolean): boolean {
		return comparisonType === true || comparisonType === StringComparison.CurrentCultureIgnoreCase ||
			comparisonType === StringComparison.InvariantCultureIgnoreCase || comparisonType === StringComparison.OrdinalIgnoreCase;
	}
	function changeStringCasing(value: string | null | undefined, comparisonType?: StringComparison | boolean): string | null | undefined {
		if (comparisonType === true) {
			comparisonType = StringComparison.OrdinalIgnoreCase;
		} else if (comparisonType == null || comparisonType === undefined || comparisonType === false) {
			comparisonType = StringComparison.Ordinal;
		}
		if (!value) {
			return value;
		}
		switch (comparisonType) {
			case StringComparison.InvariantCultureIgnoreCase:
			case StringComparison.OrdinalIgnoreCase:
				value = value.toLowerCase();
				break;
			default:
				value = value.toLocaleLowerCase();
				break;
		}
		return value;
	}
	inheritFromDotNetObject(DotNetString);
	export enum StringComparison {
		CurrentCulture = 0,
		CurrentCultureIgnoreCase,
		InvariantCulture,
		InvariantCultureIgnoreCase,
		Ordinal,
		OrdinalIgnoreCase
	}
	export enum StringSplitOptions {
		None = 0,
		RemoveEmptyEntries = 1,
		TrimEntries = 2
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	/* eslint-disable @typescript-eslint/naming-convention */
	export class DotNetTimeSpan extends TimeSpan {
		public static readonly Zero = new TimeSpan(0n);
		public static new(value: any): TimeSpan {
			return new TimeSpan(value);
		}
		public static is(value: any): boolean {
			return value instanceof TimeSpan;
		}
		public get Hours() {
			return this.ticks / 36000000000n % 24n;
		}
		public get Microseconds() {
			return this.ticks / 10n % 1000n;
		}
		public get Milliseconds() {
			return this.ticks / 10000n % 1000n;
		}
		public get Minutes() {
			return this.ticks / 600000000n % 60n;
		}
		public get Nanoseconds() {
			return this.ticks / 10n * 100n;
		}
		public get Seconds() {
			return this.ticks / 10000000n % 60n;
		}
		public get Ticks() {
			return this.ticks;
		}
		public get TotalDays() {
			return Number(this.ticks / 864000000000n);
		}
		public get TotalHours() {
			return Number(this.ticks / 36000000000n);
		}
		public get TotalMicroseconds() {
			return Number(this.ticks / 10n);
		}
		public get TotalMilliseconds() {
			return Number(this.ticks / 10000n);
		}
		public get TotalMinutes() {
			return Number(this.ticks / 600000000n);
		}
		public get TotalNanoseconds() {
			return Number(this.ticks) * 100;
		}
		public get TotalSeconds() {
			return Number(this.ticks / 10000000n);
		}
		public static Compare(t1: TimeSpan, t2: TimeSpan): number {
			check(t1, 't1').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			check(t2, 't2').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			return t1.ticks > t2.ticks ? 1 : t1.ticks === t2.ticks ? 0 : -1;
		}
		public static Equals(t1: TimeSpan, t2: TimeSpan): boolean {
			check(t1, 't1').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			check(t2, 't2').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			return t1.ticks === t2.ticks;
		}
		public static FromDays(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 864000000000);
		}
		public static FromHours(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 36000000000);
		}
		public static FromMicroseconds(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 10);
		}
		public static FromMilliseconds(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 10000);
		}
		public static FromMinutes(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 600000000);
		}
		public static FromSeconds(value: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			return DotNetTimeSpan.Interval(value, 10000000);
		}
		public static FromTicks(value: bigint): TimeSpan {
			check(value, 'value').is.bigint().and.not.nullOrUndefined();
			return new TimeSpan(value);
		}
		public static Interval(value: number, scale: number): TimeSpan {
			check(value, 'value').is.number().and.not.nullOrUndefined();
			check(scale, 'scale').is.number().and.not.nullOrUndefined();
			return new TimeSpan(BigInt(Math.round(value * scale)));
		}
		public CompareTo(value?: TimeSpan): number {
			if (!(value instanceof TimeSpan)) {
				return 1;
			}
			return this.ticks > value.ticks ? 1 : this.ticks === value.ticks ? 0 : -1;
		}
		public Add(ts: TimeSpan): TimeSpan {
			check(ts, 'ts').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			return new TimeSpan(this.ticks + ts.ticks);
		}
		public Divide(divisor: TimeSpan): number;
		public Divide(divisor: number): TimeSpan;
		public Divide(divisor: number | TimeSpan): TimeSpan | number {
			if (divisor instanceof TimeSpan) {
				check(divisor, 'divisor').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
				return new TimeSpan(this.ticks / divisor.ticks);
			} else {
				check(divisor, 'divisor').is.number().and.not.nullOrUndefined();
				return new TimeSpan(BigInt(Math.round(Number(this.ticks) / divisor)));
			}
		}
		public Duration(): TimeSpan {
			return new TimeSpan(this.ticks >= 0n ? this.ticks : -this.ticks);
		}
		public Equals(value?: TimeSpan): boolean {
			if (!(value instanceof TimeSpan)) {
				return false;
			}
			return this.ticks === value.ticks;
		}
		public Multiply(factor: number): TimeSpan {
			check(factor, 'factor').is.number().and.not.nullOrUndefined();
			return new TimeSpan(BigInt(Math.round(Number(this.ticks) * factor)));
		}
		public Negate(): TimeSpan {
			return new TimeSpan(-this.ticks);
		}
		public Parse(s: string): TimeSpan {
			return new TimeSpan(s);
		}
		public Subtract(ts: TimeSpan): TimeSpan {
			check(ts, 'ts').is.instanceOf(TimeSpan).and.not.nullOrUndefined();
			return new TimeSpan(this.ticks - ts.ticks);
		}
		public ToString(): string {
			return this.toString();
		}
	}
	/* eslint-enable @typescript-eslint/naming-convention */
	export interface LineInfo {
		readonly _pos: string;
	}
	export interface LinePosition {
		readonly lineNumber: number;
		readonly columnNumber: number;
		readonly tokenLength: number;
	}
	export function parsePosition(position: string): LinePosition {
		const parts = position.split(/[\+\:]/);
		const lineNumber = parseInt(parts[0], 10);
		const columnNumber = parseInt(parts[1], 10);
		const tokenLength = parseInt(parts[2], 10);
		if (parts.length !== 3 || typeof (lineNumber) !== 'number' ||
			typeof (columnNumber) !== 'number' || typeof (tokenLength) !== 'number') {
			throw new Error(`Invalid format of line position value "${position}". It should be "LINE:COLUMN+LENGTH".`);
		}
		return { lineNumber, columnNumber, tokenLength };
	}
	export function formatPosition(line: number, col: number, length: number): string {
		return line + ':' + col + '+' + length;
	}
	interface TypeReferenceObj {
		name: string;
		expressionType?: string | FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE;
		expression?: FormulaTypeReference;
		arguments?: TypeArgumentCollection;
	}
	export class FormulaTypeReference implements LineInfo {
		private readonly expressionType: string;
		private readonly name: string;
		private readonly expression?: FormulaTypeReference;
		private readonly arguments?: TypeArgumentCollection;
		public readonly _pos: string;
		constructor(values: (ExpressionObjOrImpl<FormulaTypeReferenceObj> | TypeReferenceObj) & Partial<LineInfo>) {
			// backward compability with old version of parser
			if (FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE in <any>values) {
				const newValues = { ...values };
				newValues.name = values.name || (<any>values)[FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE];
				values = newValues;
			}
			check(values, 'values').not.nullOrUndefined();
			check(values.name, 'values.name').not.nullOrUndefined();
			this.expressionType = values.expressionType || FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE;
			this.name = String(values.name);
			this.expression = values.expression ? FormulaTypeReference.create(values.expression) : undefined;
			this.arguments = objectToTypeArgumentsIfNotNull(values.arguments);
			this._pos = values?._pos ?? formatPosition(0, 0, 0);
		}
		public static create(value: string | FormulaTypeReference | FormulaTypeReferenceObj): FormulaTypeReference {
			if (typeof (value) === 'string') {
				return new FormulaTypeReference({ name: String(value) });
			} else if (value instanceof FormulaTypeReference) {
				return value;
			} else {
				return new FormulaTypeReference(value);
			}
		}
		public getFullName(): string {
			let fullName = this.name;
			if (this.isPlainName()) {
				fullName = typeAliases.get(fullName) || fullName;
			} else {
				fullName = this.toString();
			}
			if (systemTypes.has(fullName)) {
				return 'System.' + fullName;
			} else {
				return fullName;
			}
		}
		public toObject(): FormulaTypeReferenceObj | string {
			if (this.isPlainName()) {
				return this.name;
			}
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionType,
				[FormulaConstants.NAME_ATTRIBUTE]: this.name,
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: this.expression ? this.expression.toObject() : undefined,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: typeArgumentsToObjectIfNotNull(this.arguments),
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			let result = '';
			if (!this.expression && this.name === FormulaConstants.KNOWN_TYPE_ARRAY &&
				this.arguments &&
				Object.keys(this.arguments).length === 1) {
				return this.arguments['0'].toString() + '[]';
			} else {
				const typeArgumentsStr = this.hasTypeArguments() ? '<' + this.typeArguments() + '>' : '';
				if (this.expression) {
					result += this.expression.toString() + '.';
				}
				result += this.name + typeArgumentsStr;
				return result;
			}
		}
		private hasTypeArguments(): boolean {
			return this.arguments != null && Object.getOwnPropertyNames(this.arguments).length > 0;
		}
		private typeArguments(): string {
			const result = [];
			for (const argumentNumber in this.arguments) {
				if (this.arguments.hasOwnProperty(argumentNumber) === false) {
					continue;
				}
				const argument = this.arguments[argumentNumber];
				if (!argument) {
					result.push('');
				} else {
					result.push(argument.toString());
				}
			}
			return result.toString();
		}
		private isPlainName(): boolean {
			return this.expressionType === FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE &&
				!this.expression &&
				!this.arguments;
		}
	}
	export interface TypeArgumentCollection {
		[name: string]: FormulaTypeReference;
	}
	export function objectToTypeArgumentsIfNotNull(
		argumentCollection?: TypeArgumentCollection | FormulaTypeArgumentCollectionObj | null
	): TypeArgumentCollection | undefined {
		if (argumentCollection === null || argumentCollection === undefined) {
			return undefined;
		}
		return objectToTypeArguments(argumentCollection);
	}
	export function objectToTypeArguments(
		argumentCollection: TypeArgumentCollection | FormulaTypeArgumentCollectionObj
	): TypeArgumentCollection {
		check(argumentCollection, 'argumentCollection').is.not.nullOrUndefined();
		const typeArgumentCollection: TypeArgumentCollection = {};
		for (const argumentName in argumentCollection) {
			if (argumentCollection.hasOwnProperty(argumentName)) {
				const argument = argumentCollection[argumentName];
				if (!argument) {
					throw new Error(`Unexpected null type argument with name '${argumentName}'.`);
				}
				typeArgumentCollection[argumentName] = FormulaTypeReference.create(argument);
			}
		}
		return typeArgumentCollection;
	}
	export function typeArgumentsToObjectIfNotNull(
		argumentCollection: TypeArgumentCollection | null | undefined
	): FormulaTypeArgumentCollectionObj | undefined {
		if (argumentCollection === null || argumentCollection === undefined) {
			return undefined;
		}
		return typeArgumentsToObject(argumentCollection);
	}
	export function typeArgumentsToObject(argumentCollection: TypeArgumentCollection): FormulaTypeArgumentCollectionObj {
		check(argumentCollection, 'argumentCollection').is.not.nullOrUndefined();
		const result: FormulaTypeArgumentCollectionObj = {};
		for (const argumentName in argumentCollection) {
			if (argumentCollection.hasOwnProperty(argumentName)) {
				const argument = argumentCollection[argumentName];
				result[argumentName] = argument.toObject();
			}
		}
		return result;
	}
	export class DotnetFormulaTypeResolver implements FormulaTypeResolver {
		public resolveType(type: FormulaTypeReference): Function | undefined {
			switch (type.getFullName()) {
				case 'Math':
				case 'System.Math':
					return DotNetMath;
				case 'bool':
				case 'Boolean':
				case 'System.Boolean':
					return DotNetBoolean;
				case 'TimeSpan':
				case 'System.TimeSpan':
					return DotNetTimeSpan;
				case 'Date':
				case 'DateTime':
				case 'System.DateTime':
					return DotNetDate;
				case 'Array':
				case 'System.Array':
					return DotNetArray;
				case 'char':
				case 'Char':
				case 'System.Char':
					return DotNetChar;
				case 'sbyte':
				case 'SByte':
				case 'System.SByte':
					return DotNetInt8;
				case 'short':
				case 'Int16':
				case 'System.Int16':
					return DotNetInt16;
				case 'int':
				case 'Int32':
				case 'System.Int32':
					return DotNetInt32;
				case 'long':
				case 'Int64':
				case 'System.Int64':
					return DotNetInt64;
				case 'byte':
				case 'Byte':
				case 'System.Byte':
					return DotNetUInt8;
				case 'ushort':
				case 'UInt16':
				case 'System.UInt16':
					return DotNetUInt16;
				case 'uint':
				case 'UInt32':
				case 'System.UInt32':
					return DotNetUInt32;
				case 'ulong':
				case 'UInt64':
				case 'System.UInt64':
					return DotNetUInt64;
				case 'float':
				case 'Single':
				case 'System.Single':
					return DotNetFloat32;
				case 'double':
				case 'Double':
				case 'System.Double':
					return DotNetFloat64;
				case 'string':
				case 'String':
				case 'System.String':
					return DotNetString;
				case 'Enum':
				case 'System.Enum':
					return DotNetEnum;
				case 'object':
				case 'Object':
				case 'System.Object':
					return DotNetObject;
				case 'Number':
					return Number;
				case 'BigInt':
					return BigInt;
				case 'Symbol':
					return Symbol;
				case 'DayOfWeek':
				case 'System.DayOfWeek':
					return createDotNetEnum(DayOfWeek);
				case 'StringComparison':
				case 'System.StringComparison':
					return createDotNetEnum(StringComparison);
				case 'StringSplitOptions':
				case 'System.StringSplitOptions':
					return createDotNetEnum(StringSplitOptions);
			}
			return undefined;
		}
	}
	export class KnownTypeResolver extends DotnetFormulaTypeResolver {
		public constructor(
			private readonly knownTypes: Map<string, Function>
		) {
			super();
		}
		public resolveType(type: FormulaTypeReference): Function | undefined {
			const knownType = this.knownTypes.get(type.getFullName());
			if (knownType) {
				return knownType;
			}
			return super.resolveType(type);
		}
	}
	export class FormulaExecutionContext implements FormulaTypeResolver {
		private readonly arguments: Map<string, any>;
		public strictEquality?: boolean;
		public get argumentNames(): Iterable<string> {
			return this.arguments.keys();
		}
		constructor(args?: Map<string, any>,
			private readonly typeResolver?: FormulaTypeResolver,
			public readonly autoNullPropagation?: boolean,
			public readonly globalObject?: any,
			private readonly parentContext?: FormulaExecutionContext,
		) {
			this.arguments = args || new Map<string, any>();
			this.autoNullPropagation = autoNullPropagation || false;
			this.typeResolver = this.typeResolver ?? new KnownTypeResolver(new Map());
		}
		public setArgument(name: string, value: any) {
			this.arguments.set(name, value);
		}
		public getArgument(name: string): any {
			if (!this.arguments.has(name) && this.parentContext) {
				return this.parentContext.getArgument(name);
			}
			return this.arguments.get(name);
		}
		public hasArgument(name: string): any {
			if (!this.arguments.has(name) && this.parentContext) {
				return this.parentContext.hasArgument(name);
			}
			return this.arguments.has(name);
		}
		public createSubContext(): FormulaExecutionContext {
			return new FormulaExecutionContext(undefined, this.typeResolver, this.autoNullPropagation, this.globalObject, this);
		}
		resolveType(type: FormulaTypeReference): Function | undefined {
			if (this.typeResolver) {
				return this.typeResolver.resolveType(type);
			}
			return undefined;
		}
	}
	export abstract class FormulaExpression implements LineInfo {
		public cSharpSourceCode?: string;
		public readonly expressionTypeName: string;
		public readonly _pos: string;
		constructor(
			public readonly expressionType: ExpressionType,
			public readonly expressionObject: Readonly<FormulaExpressionObj>) {
			this.expressionTypeName = expressionObject[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE];
			this._pos = expressionObject[FormulaConstants.POSITION_ATTRIBUTE] ?? formatPosition(0, 0, 0);
			this.cSharpSourceCode = expressionObject[FormulaConstants.ORIGINAL_C_SHARP_ALT2_ATTRIBUTE] ??
				expressionObject[FormulaConstants.ORIGINAL_C_SHARP_ALT_ATTRIBUTE] ??
				expressionObject[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE];
		}
		public static createIfNotNull(value: FormulaExpressionObj | FormulaExpression | null | undefined) {
			if (value === null || value === undefined) {
				return null;
			}
			return this.create(value);
		}
		public static create(value: FormulaExpressionObj | FormulaExpression): FormulaExpression {
			check(value, 'value').instanceOf(Object).and.not.nullOrUndefined();
			if (value instanceof FormulaExpression) {
				return <FormulaExpression>value;
			}
			const formulaExpressionObj: any = value;
			const expressionType = formulaExpressionObj[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE];
			if (!expressionType) {
				throw new FormulaError(formatString(ExpressionResources.EXCEPTION_BIND_MISSINGATTRONNODE,
					FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE), <LineInfo>formulaExpressionObj);
			}
			const constructor = getExpressionType(String(expressionType));
			const expression = new constructor(formulaExpressionObj);
			return expression;
		}
		public valueOf(): string {
			return this.toString();
		}
		public abstract execute(context: FormulaExecutionContext): any;
		public abstract toObject(): FormulaExpressionObj;
		public abstract toString(): string;
	}
	export function expressionToObjectIfNotNull(value: FormulaExpression | null | undefined): FormulaExpressionObj | null {
		if (value === null || value === undefined) {
			return null;
		} else {
			return value.toObject();
		}
	}
	export function expressionToObject(value: FormulaExpression): FormulaExpressionObj {
		check(value, 'value').is.not.nullOrUndefined();
		return value.toObject();
	}
	export type ExpressionObjOrImpl<ExpressionObjT> = {
		readonly [key in keyof ExpressionObjT]: PickImplT<ExpressionObjT[key]>
	};
	type PickImplT<T> = T extends FormulaTypeReferenceObj ? T | FormulaTypeReference :
		T extends FormulaArgumentCollectionObj ? T | ArgumentCollection :
		T extends FormulaTypeArgumentCollectionObj ? T | TypeArgumentCollection :
		T extends FormulaExpressionObj ? T | FormulaExpression :
		T;
	export class ConstantExpression extends FormulaExpression {
		public readonly value: any;
		public readonly type: FormulaTypeReference;
		constructor(values: ExpressionObjOrImpl<FormulaConstantExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.Constant, values);
			this.value = values.value;
			this.type = FormulaTypeReference.create(values.type);
			if (this.value === undefined) {
				this.value = null;
			}
		}
		public execute(context: FormulaExecutionContext): any {
			if (this.value === null || this.value === undefined) {
				return null;
			}
			switch (this.type.getFullName()) {
				case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return formatString(this.value)[0] ?? '\0';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return !!this.value;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return parseInt(this.value, 10);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return BigInt(this.value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return parseFloat(this.value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_TYPE: return context.resolveType(FormulaTypeReference.create(this.value));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_STRING: return String(this.value ?? '');
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return new Date(this.value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return new TimeSpan(this.value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT:
				default: return this.value;
			}
		}
		public toObject(): FormulaExpressionObj & FormulaConstantExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_CONSTANT,
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.VALUE_ATTRIBUTE]: this.value,
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			const fullValueType = this.type.getFullName();
			switch (fullValueType) {
				case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return '\'' + JSON.stringify(this.value).substr(1, 1) + '\'';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return this.value ? FormulaConstants.NOTATION_TRUE_STRING :
					FormulaConstants.NOTATION_FALSE_STRING;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE: return JSON.stringify(parseInt(this.value, 10)) + 'U';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE: return JSON.stringify(parseInt(this.value, 10));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16: return JSON.stringify(parseInt(this.value, 10));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16: return JSON.stringify(parseInt(this.value, 10)) + 'U';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32: return JSON.stringify(parseInt(this.value, 10));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return JSON.stringify(parseInt(this.value, 10)) + 'U';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64: return JSON.stringify(BigInt(this.value)) + 'L';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return JSON.stringify(BigInt(this.value)) + 'UL';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return JSON.stringify(parseFloat(this.value)) + 'D';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE: return JSON.stringify(parseFloat(this.value)) + 'F';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return JSON.stringify(parseFloat(this.value)) + 'M';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_TYPE: return this.value === null ? 'null' :
					'typeof(' + String(this.value) + ')';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_STRING: return this.value === null ? 'null' : JSON.stringify(String(this.value ?? ''));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT: return this.value === null ? 'null' : JSON.stringify(String(this.value ?? ''));
				default: return this.value === null ? 'default(' + fullValueType + ')' : JSON.stringify(String(this.value ?? ''));
			}
		}
		public static nullObjectExpression: ConstantExpression = new ConstantExpression({
			expressionType: FormulaConstants.EXPRESSION_TYPE_CONSTANT,
			type: 'object',
			value: null
		});
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_CONSTANT, ConstantExpression);
	export interface ArgumentCollection {
		[name: string]: FormulaExpression;
	}
	export function argumentsToObjectIfNotNull(
		argumentCollection: ArgumentCollection | null | undefined
	): FormulaArgumentCollectionObj | undefined {
		if (argumentCollection === null || argumentCollection === undefined) {
			return undefined;
		}
		return argumentsToObject(argumentCollection);
	}
	export function argumentsToObject(argumentCollection: ArgumentCollection): FormulaArgumentCollectionObj {
		check(argumentCollection, 'argumentCollection').is.not.nullOrUndefined();
		const result: FormulaArgumentCollectionObj = {};
		for (const argumentName in argumentCollection) {
			if (argumentCollection.hasOwnProperty(argumentName)) {
				const argument = argumentCollection[argumentName];
				result[argumentName] = argument ? argument.toObject() : null;
			}
		}
		return result;
	}
	export function objectToArgumentsIfNotNull(
		argumentCollection: ArgumentCollection | FormulaArgumentCollectionObj | null | undefined
	): ArgumentCollection | undefined {
		if (argumentCollection === null || argumentCollection === undefined) {
			return undefined;
		}
		return objectToArguments(argumentCollection);
	}
	export function objectToArguments(argumentCollection: ArgumentCollection | FormulaArgumentCollectionObj): ArgumentCollection {
		check(argumentCollection, 'argumentCollection').is.not.nullOrUndefined();
		const newArgumentCollection: ArgumentCollection = {};
		for (const argumentName in argumentCollection) {
			if (argumentCollection.hasOwnProperty(argumentName)) {
				const argument = argumentCollection[argumentName];
				newArgumentCollection[argumentName] = argument ? FormulaExpression.create(argument) : ConstantExpression.nullObjectExpression;
			}
		}
		return newArgumentCollection ?? argumentCollection;
	}
	export function coerceToString(value: any): string {
	    if (typeof value === 'undefined' || value === null) {
	        return '';
	    } else if (typeof value === 'boolean') {
	        return value ? 'True' : 'False';
	    } else {
	        return String(value);
	    }
	}
	export interface FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: string;
		// backward compability with old version of parser
		[FormulaConstants.ORIGINAL_C_SHARP_ALT2_ATTRIBUTE]?: string;
		[FormulaConstants.ORIGINAL_C_SHARP_ALT_ATTRIBUTE]?: string;
		//
		[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]?: string;
		[FormulaConstants.POSITION_ATTRIBUTE]?: string;
	}
	export type UnaryExpressionType = FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE | FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE |
		FormulaConstants.EXPRESSION_TYPE_GROUP | FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS |
		FormulaConstants.EXPRESSION_TYPE_NEGATE | FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED |
		FormulaConstants.EXPRESSION_TYPE_NOT | FormulaConstants.EXPRESSION_TYPE_COMPLEMENT;
	export interface FormulaUnaryExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: UnaryExpressionType;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
	}
	export type BinaryExpressionType = FormulaConstants.EXPRESSION_TYPE_DIVIDE | FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED |
		FormulaConstants.EXPRESSION_TYPE_MULTIPLY | FormulaConstants.EXPRESSION_TYPE_POWER |
		FormulaConstants.EXPRESSION_TYPE_MODULO | FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED |
		FormulaConstants.EXPRESSION_TYPE_ADD | FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED |
		FormulaConstants.EXPRESSION_TYPE_SUBTRACT | FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT |
		FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT | FormulaConstants.EXPRESSION_TYPE_GREATER_THAN |
		FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL | FormulaConstants.EXPRESSION_TYPE_LESS_THAN |
		FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL | FormulaConstants.EXPRESSION_TYPE_EQUAL |
		FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL | FormulaConstants.EXPRESSION_TYPE_AND |
		FormulaConstants.EXPRESSION_TYPE_OR | FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR |
		FormulaConstants.EXPRESSION_TYPE_AND_ALSO | FormulaConstants.EXPRESSION_TYPE_OR_ELSE |
		FormulaConstants.EXPRESSION_TYPE_COALESCE;
	export interface FormulaBinaryExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: BinaryExpressionType;
		[FormulaConstants.LEFT_ATTRIBUTE]: FormulaExpressionObj;
		[FormulaConstants.RIGHT_ATTRIBUTE]: FormulaExpressionObj;
	};
	export interface FormulaConditionExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_CONDITION;
		[FormulaConstants.TEST_ATTRIBUTE]: FormulaExpressionObj;
		[FormulaConstants.IF_TRUE_ATTRIBUTE]: FormulaExpressionObj;
		[FormulaConstants.IF_FALSE_ATTRIBUTE]: FormulaExpressionObj;
	}
	export interface FormulaConstantExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_CONSTANT;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
		[FormulaConstants.VALUE_ATTRIBUTE]: any;
	};
	export interface FormulaConvertExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: string;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
	}
	export interface FormulaDefaultExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_DEFAULT;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
	}
	export interface FormulaIndexExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_INDEX;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]: FormulaArgumentCollectionObj;
		[FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE]: boolean;
	}
	export interface FormulaInvokeExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_INVOKE;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]: FormulaArgumentCollectionObj;
	}
	export interface FormulaLambdaExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_LAMBDA;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]: FormulaArgumentCollectionObj;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
	}
	export interface FormulaMemberExpressionObj extends FormulaExpressionObj {
		// backward compability with old version of parser
		[FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE]?: string;
		//
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE;
		[FormulaConstants.NAME_ATTRIBUTE]: string;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]?: FormulaTypeArgumentCollectionObj;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]?: FormulaExpressionObj | null;
		[FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE]: boolean;
	};
	export interface FormulaNewArrayBoundExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]: FormulaArgumentCollectionObj;
	};
	export interface FormulaNewExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_NEW;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]: FormulaArgumentCollectionObj;
	}
	export interface FormulaTypeIsExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_TYPE_IS;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]: FormulaExpressionObj;
	}
	export interface FormulaTypeOfExpressionObj extends FormulaExpressionObj {
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: FormulaConstants.EXPRESSION_TYPE_TYPE_OF;
		[FormulaConstants.TYPE_ATTRIBUTE]: FormulaTypeReferenceObj | string;
	}
	export interface FormulaTypeReferenceObj extends Partial<FormulaExpressionObj> {
		[FormulaConstants.NAME_ATTRIBUTE]: string;
		[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]?: string | FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE;
		[FormulaConstants.EXPRESSION_ATTRIBUTE]?: FormulaTypeReferenceObj | string;
		[FormulaConstants.ARGUMENTS_ATTRIBUTE]?: FormulaTypeArgumentCollectionObj;
	}
	export interface FormulaTypeArgumentCollectionObj {
		[name: string]: FormulaTypeReferenceObj | string;
	}
	export interface FormulaArgumentCollectionObj {
		[name: string]: FormulaExpressionObj | null;
	}
	export class BinaryExpression extends FormulaExpression {
		public readonly right: FormulaExpression;
		public readonly left: FormulaExpression;
		constructor(values: ExpressionObjOrImpl<FormulaBinaryExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.left, 'values.left').not.nullOrUndefined();
			check(values.right, 'values.right').not.nullOrUndefined();
			/* eslint-disable max-len */
			switch (values.expressionType) {
				case FormulaConstants.EXPRESSION_TYPE_DIVIDE: super(ExpressionType.Divide, values); break;
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED: super(ExpressionType.MultiplyChecked, values); break;
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY: super(ExpressionType.Multiply, values); break;
				case FormulaConstants.EXPRESSION_TYPE_POWER: super(ExpressionType.Power, values); break;
				case FormulaConstants.EXPRESSION_TYPE_MODULO: super(ExpressionType.Modulo, values); break;
				case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED: super(ExpressionType.AddChecked, values); break;
				case FormulaConstants.EXPRESSION_TYPE_ADD: super(ExpressionType.Add, values); break;
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED: super(ExpressionType.SubtractChecked, values); break;
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: super(ExpressionType.Subtract, values); break;
				case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT: super(ExpressionType.LeftShift, values); break;
				case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: super(ExpressionType.RightShift, values); break;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: super(ExpressionType.GreaterThan, values); break;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: super(ExpressionType.GreaterThanOrEqual, values); break;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: super(ExpressionType.LessThan, values); break;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: super(ExpressionType.LessThanOrEqual, values); break;
				case FormulaConstants.EXPRESSION_TYPE_EQUAL: super(ExpressionType.Equal, values); break;
				case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: super(ExpressionType.NotEqual, values); break;
				case FormulaConstants.EXPRESSION_TYPE_AND: super(ExpressionType.And, values); break;
				case FormulaConstants.EXPRESSION_TYPE_OR: super(ExpressionType.Or, values); break;
				case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: super(ExpressionType.ExclusiveOr, values); break;
				case FormulaConstants.EXPRESSION_TYPE_AND_ALSO: super(ExpressionType.AndAlso, values); break;
				case FormulaConstants.EXPRESSION_TYPE_OR_ELSE: super(ExpressionType.OrElse, values); break;
				case FormulaConstants.EXPRESSION_TYPE_COALESCE: super(ExpressionType.Coalesce, values); break;
				default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE, values.expressionType), values);
			}
			/* eslint-enable max-len */
			this.left = FormulaExpression.create(values.left);
			this.right = FormulaExpression.create(values.right);
		}
		/* eslint-disable eqeqeq */
		/* eslint-disable no-bitwise */
		public execute(context: FormulaExecutionContext) {
			if (this.expressionType === ExpressionType.Coalesce) {
				return this.executeCoalesce(context);
			} else if (this.expressionType === ExpressionType.AndAlso) {
				return this.executeAndAlso(context);
			} else if (this.expressionType === ExpressionType.OrElse) {
				return this.executeOrElse(context);
			} else if (this.expressionType === ExpressionType.Power) {
				return this.executePower(context);
			}
			const leftValue = this.left.execute(context);
			const rightValue = this.right.execute(context);
			if ((typeof leftValue === 'string' || typeof rightValue === 'string') &&
				(this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_ADD ||
					this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED)) {
				return this.executeConcat(leftValue, rightValue);
			} else if (leftValue === null || leftValue === undefined || rightValue === null || rightValue === undefined) {
				if (typeof leftValue === 'boolean' || typeof rightValue === 'boolean') {
					return this.executeNullLiftedBoolean(leftValue, rightValue, context);
				} else {
					return this.executeNullLifted(leftValue, rightValue, context);
				}
			} else if (leftValue instanceof Date && rightValue instanceof TimeSpan &&
				(this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_ADD ||
					this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED ||
					this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_SUBTRACT ||
					this.expressionTypeName === FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED)) {
				return this.executeDateAndTimeSpan(leftValue, rightValue);
			} else if (leftValue instanceof TimeSpan && rightValue instanceof TimeSpan) {
				return this.executTimeSpan(leftValue, rightValue, context);
			} else {
				const [promotedLeftValue, promotedRightValue] = this.promoteOperands(leftValue, rightValue);
				switch (this.expressionTypeName as BinaryExpressionType) {
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE: return promotedLeftValue / promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY: return promotedLeftValue * promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_POWER: return promotedLeftValue ** promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_MODULO: return promotedLeftValue % promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_ADD: return promotedLeftValue + promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: return promotedLeftValue - promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT: return promotedLeftValue << promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: return promotedLeftValue >> promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: return promotedLeftValue > promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: return promotedLeftValue >= promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: return promotedLeftValue < promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: return promotedLeftValue <= promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_EQUAL: return context.strictEquality === false ?
						promotedLeftValue == promotedRightValue : promotedLeftValue === promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: return context.strictEquality === false ?
						promotedLeftValue != promotedRightValue : promotedLeftValue !== promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_AND: return promotedLeftValue & promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_OR: return promotedLeftValue | promotedRightValue;
					case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: return promotedLeftValue ^ promotedRightValue;
					default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE,
						this.expressionTypeName), this);
				}
			}
		}
		private executTimeSpan(leftValue: TimeSpan, rightValue: TimeSpan, context: FormulaExecutionContext) {
			switch (this.expressionTypeName as BinaryExpressionType) {
				case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_ADD: return DotNetTimeSpan.FromTicks(leftValue.ticks + rightValue.ticks);
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: return DotNetTimeSpan.FromTicks(leftValue.ticks - rightValue.ticks);
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: return leftValue.ticks > rightValue.ticks;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: return leftValue.ticks >= rightValue.ticks;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: return leftValue.ticks < rightValue.ticks;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: return leftValue.ticks <= rightValue.ticks;
				case FormulaConstants.EXPRESSION_TYPE_EQUAL: return context.strictEquality === false ? leftValue.ticks == rightValue.ticks :
					leftValue.ticks === rightValue.ticks;;
				case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: return context.strictEquality === false ? leftValue.ticks != rightValue.ticks :
					leftValue.ticks !== rightValue.ticks;
				case FormulaConstants.EXPRESSION_TYPE_AND:
				case FormulaConstants.EXPRESSION_TYPE_OR:
				case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR:
				case FormulaConstants.EXPRESSION_TYPE_POWER:
				case FormulaConstants.EXPRESSION_TYPE_MODULO:
				case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT:
				case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT:
				case FormulaConstants.EXPRESSION_TYPE_DIVIDE:
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY:
					throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_NOBINARYOPONTYPE,
						this.expressionTypeName, TimeSpan.constructor.name, TimeSpan.constructor.name), this);
				default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE,
					this.expressionTypeName), this);
			}
		}
		private executeDateAndTimeSpan(leftValue: Date, rightValue: TimeSpan) {
			switch (this.expressionTypeName as BinaryExpressionType) {
				case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_ADD: return new Date(leftValue.getTime() + rightValue.milliseconds);
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: return new Date(leftValue.getTime() - rightValue.milliseconds);
				default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_NOBINARYOPONTYPE,
					this.expressionTypeName, TimeSpan.constructor.name, TimeSpan.constructor.name), this);
			}
		}
		private executeNullLiftedBoolean(leftValue: any, rightValue: any, context: FormulaExecutionContext) {
			const leftValueIsNull = leftValue === null || leftValue === undefined;
			const rightValueIsNull = rightValue === null || rightValue === undefined;
			switch (this.expressionTypeName) {
				case FormulaConstants.EXPRESSION_TYPE_AND:
					if (rightValueIsNull && leftValueIsNull) {
						return null;
					} else if (rightValueIsNull) {
						return leftValue ? null : false;
					} else {
						return rightValue ? null : false;
					}
					break;
				case FormulaConstants.EXPRESSION_TYPE_OR:
					if (rightValueIsNull && leftValueIsNull) {
						return null;
					} else if (rightValueIsNull) {
						return leftValue ? true : null;
					} else {
						return rightValue ? true : null;
					}
					break;
				default:
					return this.executeNullLifted(leftValue, rightValue, context);
			}
		}
		private executeNullLifted(leftValue: any, rightValue: any, context: FormulaExecutionContext) {
			switch (this.expressionTypeName as BinaryExpressionType) {
				case FormulaConstants.EXPRESSION_TYPE_AND:
				case FormulaConstants.EXPRESSION_TYPE_OR:
				case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR:
				case FormulaConstants.EXPRESSION_TYPE_DIVIDE:
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY:
				case FormulaConstants.EXPRESSION_TYPE_POWER:
				case FormulaConstants.EXPRESSION_TYPE_MODULO:
				case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_ADD:
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT:
				case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT:
				case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: return null;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN:
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL:
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN:
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: return false;
				case FormulaConstants.EXPRESSION_TYPE_EQUAL: return context.strictEquality === false ? leftValue == rightValue :
					leftValue === rightValue;
				case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: return context.strictEquality === false ? leftValue != rightValue :
					leftValue !== rightValue;
				default: throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE, this.expressionTypeName), this);
			}
		}
		private executePower(context: FormulaExecutionContext) {
			const leftValue = this.left.execute(context);
			const rightValue = this.right.execute(context);
			if (leftValue === null || leftValue === undefined || rightValue === null || rightValue === undefined) {
				return null;
			}
			if (typeof leftValue === 'bigint' || typeof rightValue === 'bigint') {
				return BigInt(leftValue) ** BigInt(rightValue);
			} else {
				return leftValue ** rightValue;
			}
		}
		private executeOrElse(context: FormulaExecutionContext) {
			const operation = '||';
			const leftValue = this.left.execute(context);
			if (typeof leftValue != 'boolean') {
				throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_BIND_INVALID_LOGICAL_EXPRESSION,
						this.left, operation, typeof leftValue), this);
			}
			if (!!leftValue) {
				return true; // shortcut
			}
			const rightValue = this.right.execute(context);
			if (typeof rightValue != 'boolean') {
				throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_BIND_INVALID_LOGICAL_EXPRESSION,
						this.right, operation, typeof rightValue), this);
			}
			return !!leftValue || !!rightValue;
		}
		private executeAndAlso(context: FormulaExecutionContext) {
			const operation = '||';
			const leftValue = this.left.execute(context);
			if (typeof leftValue != 'boolean') {
				throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_BIND_INVALID_LOGICAL_EXPRESSION,
						this.left, operation, typeof leftValue), this);
			}
			if (!leftValue) {
				return false; // shortcut
			}
			const rightValue = this.right.execute(context);
			if (typeof rightValue != 'boolean') {
				throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_BIND_INVALID_LOGICAL_EXPRESSION,
						this.right, operation, typeof rightValue), this);
			}
			return !!leftValue && !!rightValue;
		}
		private executeCoalesce(context: FormulaExecutionContext) {
			const leftValue = this.left.execute(context);
			if (leftValue !== null && leftValue !== undefined) {
				return leftValue;
			}
			const rightValue = this.right.execute(context);
			return leftValue ?? rightValue;
		}
		private executeConcat(leftValue: any, rightValue: any) {
			const leftString = coerceToString(leftValue);
			const rightString = coerceToString(rightValue);
			return leftString + rightString;
		}
		/* eslint-enable no-bitwise */
		/* eslint-enable eqeqeq */
		private promoteOperands(leftValue: any, rightValue: any): [any, any] {
			if (typeof leftValue === 'bigint' || typeof rightValue === 'bigint') {
				leftValue = BigInt(leftValue);
				rightValue = BigInt(rightValue);
			}
			return [leftValue, rightValue];
		}
		public toObject(): FormulaExpressionObj & FormulaBinaryExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as BinaryExpressionType,
				[FormulaConstants.LEFT_ATTRIBUTE]: this.left.toObject(),
				[FormulaConstants.RIGHT_ATTRIBUTE]: this.right.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let operator: string;
			switch (this.expressionTypeName) {
				case FormulaConstants.EXPRESSION_TYPE_DIVIDE: operator = '/'; break;
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_MULTIPLY: operator = '*'; break;
				case FormulaConstants.EXPRESSION_TYPE_POWER: operator = '**'; break;
				case FormulaConstants.EXPRESSION_TYPE_MODULO: operator = '%'; break;
				case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_ADD: operator = '+'; break;
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
				case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: operator = '-'; break;
				case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT: operator = '<<'; break;
				case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: operator = '>>'; break;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: operator = '>'; break;
				case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: operator = '>='; break;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: operator = '<'; break;
				case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: operator = '<='; break;
				case FormulaConstants.EXPRESSION_TYPE_EQUAL: operator = '=='; break;
				case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: operator = '!='; break;
				case FormulaConstants.EXPRESSION_TYPE_AND: operator = '&'; break;
				case FormulaConstants.EXPRESSION_TYPE_OR: operator = '|'; break;
				case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: operator = '^'; break;
				case FormulaConstants.EXPRESSION_TYPE_AND_ALSO: operator = '&&'; break;
				case FormulaConstants.EXPRESSION_TYPE_OR_ELSE: operator = '||'; break;
				case FormulaConstants.EXPRESSION_TYPE_COALESCE: operator = '??'; break;
				default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNBINARYEXPRTYPE,
					this.expressionTypeName), this);
			}
			return this.left.toString() + ' ' + operator + ' ' + this.right.toString();
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_DIVIDE, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_MULTIPLY, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_POWER, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_MODULO, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_ADD, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_SUBTRACT, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_GREATER_THAN, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_LESS_THAN, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_EQUAL, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_AND, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_OR, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_AND_ALSO, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_OR_ELSE, BinaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_COALESCE, BinaryExpression);
	export function coerceToBoolean(value: any): boolean {
	    if (Array.isArray(value)) {
	        return value.length > 0;
	    } else if (typeof value === 'string') {
	        return value.length > 0;
	    } else if (typeof value === 'object') {
	        return value !== null;
	    } else if (typeof value === undefined) {
	        return false;
	    } else {
	        return !!value;
	    }
	}
	export class ConditionExpression extends FormulaExpression {
		public readonly test: FormulaExpression;
		public readonly ifTrue: FormulaExpression;
		public readonly ifFalse: FormulaExpression;
		constructor(values: ExpressionObjOrImpl<FormulaConditionExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.test, 'values.test').not.nullOrUndefined();
			check(values.ifTrue, 'values.ifTrue').not.nullOrUndefined();
			check(values.ifFalse, 'values.ifFalse').not.nullOrUndefined();
			super(ExpressionType.Conditional, values);
			this.test = FormulaExpression.create(values.test);
			this.ifTrue = FormulaExpression.create(values.ifTrue);
			this.ifFalse = FormulaExpression.create(values.ifFalse);
		}
		public execute(context: FormulaExecutionContext) {
			return coerceToBoolean(this.test.execute(context)) ? this.ifTrue.execute(context) : this.ifFalse.execute(context);
		}
		public toObject(): FormulaExpressionObj & FormulaConditionExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_CONDITION,
				[FormulaConstants.TEST_ATTRIBUTE]: this.test.toObject(),
				[FormulaConstants.IF_TRUE_ATTRIBUTE]: this.ifTrue.toObject(),
				[FormulaConstants.IF_FALSE_ATTRIBUTE]: this.ifFalse.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			return this.test.toString() + ' ? ' + this.ifTrue.toString() + ' : ' + this.ifFalse.toString();
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_CONDITION, ConditionExpression);
	export class ConvertExpression extends FormulaExpression {
		public readonly expression: FormulaExpression;
		public readonly type: FormulaTypeReference;
		public readonly expressionTypeName: string;
		constructor(values: ExpressionObjOrImpl<FormulaConvertExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			/* eslint-disable max-len */
			switch (values.expressionType) {
				case FormulaConstants.EXPRESSION_TYPE_CONVERT: super(ExpressionType.Convert, values); break;
				case FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED: super(ExpressionType.ConvertChecked, values); break;
				case FormulaConstants.EXPRESSION_TYPE_TYPE_AS: super(ExpressionType.TypeAs, values); break;
				default:
					super(0, values);
					throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNEXPRTYPE, values.expressionType), this);
			}
			/* eslint-enable max-len */
			this.expressionTypeName = values.expressionType;
			this.expression = FormulaExpression.create(values.expression);
			this.type = FormulaTypeReference.create(values.type);
		}
		public execute(context: FormulaExecutionContext) {
			const value = this.expression.execute(context);
			if (value === null || value === undefined) {
				return null;
			}
			switch (this.type.getFullName()) {
				case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR:
					if (typeof (value) === 'string' && value.length === 1) {
						return value;
					} else if (typeof (value) === 'string' && value.length === 0) {
						return '\0';
					} else if (typeof (value) === 'string' && value.length > 1) {
						return String(value ?? '')[0] ?? '\0';
					} else if (typeof (value) === 'number') {
						return String.fromCharCode(value);
					} else {
						throw new Error(formatString(ExpressionResources.EXCEPTION_COMPIL_NOCONVERTIONBETWEENTYPES,
							typeof value, this.type.toString()));
					}
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return value === 'true' || !!value;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return parseInt(value, 10);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return BigInt(value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return parseFloat(value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_TYPE: return context.resolveType(FormulaTypeReference.create(value));
				case FormulaConstants.KNOWN_TYPE_SYSTEM_STRING: return String(value);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT:
				default: return value;
			}
		}
		public toObject(): FormulaConvertExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName,
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: this.expression.toObject(),
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			switch (this.expressionType) {
				case ExpressionType.Convert:
				case ExpressionType.ConvertChecked: return '(' + this.type.toString() + ')' + this.expression.toString();
				case ExpressionType.TypeAs: return this.expression.toString() + ' as ' + this.type.toString();
				default: throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNEXPRTYPE, this.expressionTypeName), this);
			}
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_CONVERT, ConvertExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED, ConvertExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_TYPE_AS, ConvertExpression);
	export class DefaultExpression extends FormulaExpression {
		public readonly valueType: FormulaTypeReference;
		constructor(values: ExpressionObjOrImpl<FormulaDefaultExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.Default, values);
			this.valueType = FormulaTypeReference.create(values.type);
		}
		public execute() {
			switch (this.valueType.getFullName()) {
				case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return '\0';
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return false;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return 0;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE:
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return 0.0;
				case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return new Date(0);
				case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return new TimeSpan(0);
				default: return null;
			}
		}
		public toObject(): FormulaDefaultExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_DEFAULT,
				[FormulaConstants.TYPE_ATTRIBUTE]: this.valueType.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			return 'default(' + this.valueType.toString() + ')';
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_DEFAULT, DefaultExpression);
	export function findMemberOnTarget(target: any, memberName: string): any {
		if (target === null || target === undefined) {
			return target[memberName]; // will throw exception
		}
		const targetIsObjectLike = (typeof (target) === 'object' || typeof (target) === 'function');
		if (targetIsObjectLike && memberName in target) {
			return target[memberName];
		} else if (target instanceof Map) {
			return target.get(memberName);
		}
		const targetType: Function = typeof (target) === 'bigint' ? DotNetInt64 :
			typeof (target) === 'number' ? DotNetFloat64 :
				typeof (target) === 'string' ? DotNetString :
					typeof (target) === 'boolean' ? DotNetBoolean :
						typeof (target) === 'function' ? getSurrogateTypeByConstructor(target) :
							target instanceof TimeSpan ? DotNetTimeSpan :
								target instanceof Date ? DotNetDate :
									Array.isArray(target) ? DotNetArray :
										target instanceof Object ? DotNetObject :
											target.constructor ?? target;
		const instanceMember = getPropertyOnPrototypeChain(targetType.prototype, memberName);
		if (instanceMember && instanceMember.get) {
			return instanceMember.get.apply(target);
		} else if (instanceMember && instanceMember.value !== undefined) {
			return instanceMember.value;
		}
		const allMembers = (targetIsObjectLike ? Object.keys(target) : []).join(', ');
		throw Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETORESOLVEMEMBERONTYPE, memberName, targetType.name, allMembers));
	}
	function getSurrogateTypeByConstructor(constructor: any) {
		if (constructor === Number) {
			return DotNetFloat64;
		} else if (constructor === BigInt) {
			return DotNetInt64;
		} else if (constructor === String) {
			return DotNetString;
		} else if (constructor === Boolean) {
			return DotNetBoolean;
		} else if (constructor === Object) {
			return DotNetObject;
		} else if (constructor === Array) {
			return DotNetArray;
		} else if (constructor === TimeSpan) {
			return DotNetTimeSpan;
		} else if (constructor === Date) {
			return DotNetDate;
		} else {
			return constructor;
		}
	}
	function getPropertyOnPrototypeChain(prototype: object | undefined | null, memberName: string): PropertyDescriptor | null {
		if (prototype === null || prototype === undefined) {
			return null;
		}
		const propretyDesc = Object.getOwnPropertyDescriptor(prototype, memberName);
		if (propretyDesc) {
			return propretyDesc;
		}
		return getPropertyOnPrototypeChain(Object.getPrototypeOf(prototype), memberName);
	}
	export interface NullPropagationExpression {
		isNullPropagationEnabled(): boolean;
	}
	export function isNullPropagationExpression(value: any): value is NullPropagationExpression {
		return value !== null && typeof value === 'object' && typeof value.isNullPropagationEnabled === 'function';
	}
	export class MemberExpression extends FormulaExpression implements NullPropagationExpression {
		public readonly name: string;
		public readonly rawName: string;
		public readonly expression?: FormulaExpression;
		public readonly useNullPropagation: boolean;
		public readonly arguments?: TypeArgumentCollection;
		constructor(values: ExpressionObjOrImpl<FormulaMemberExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			// backward compability with old version of parser
			if (values[FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE]) {
				const newValues = { ...values };
				newValues.name = values.name || values[FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE];
				values = newValues;
			}
			check(values.name, 'values.name').not.nullOrUndefined();
			super(ExpressionType.MemberAccess, values);
			this.rawName = String(values.name);
			this.name = this.rawName[0] === '@' ? this.rawName.substring(1) : this.rawName;
			this.expression = values.expression ? FormulaExpression.create(values.expression) : undefined;
			this.useNullPropagation = !!(values.useNullPropagation || false);
			this.arguments = objectToTypeArgumentsIfNotNull(values.arguments);
		}
		public getTarget(): FormulaExpression | undefined {
			return this.expression || undefined;
		}
		public getMemberName(): string {
			return this.name;
		}
		public isNullPropagationEnabled(): boolean {
			if (this.useNullPropagation) {
				return true;
			}
			if (isNullPropagationExpression(this.expression)) {
				return this.expression.isNullPropagationEnabled();
			}
			return false;
		}
		public execute(context: FormulaExecutionContext) {
			const isNullPropagation = context.autoNullPropagation || this.isNullPropagationEnabled();
			const [typeReference, memberName, rawMemberName] = this.tryGetTypeReferenceAndMemberName();
			const resolvedType = typeReference ? context.resolveType(typeReference) :
				context.resolveType(new FormulaTypeReference({ name: memberName }));
			if (resolvedType && memberName in resolvedType) {
				return (<any>resolvedType)[memberName];
			} else if (this.expression) {
				const target = this.expression.execute(context);
				if (target === null || target === undefined) {
					if (isNullPropagation) {
						return null;
					}
					throw Error(formatString(ExpressionResources.EXCEPTION_EXECUTION_CANTDONULLVALUE,
						this.expression.toString(), ExpressionType[this.expressionType]));
				}
				const value = findMemberOnTarget(target, memberName);
				return value;
			} else if (rawMemberName === FormulaConstants.NOTATION_TRUE_STRING) {
				return true;
			} else if (rawMemberName === FormulaConstants.NOTATION_FALSE_STRING) {
				return false;
			} else if (rawMemberName === FormulaConstants.NOTATION_NULL_STRING) {
				return null;
			} else if (context.hasArgument(memberName)) {
				return context.getArgument(memberName);
			} else if (context.globalObject && context.globalObject.hasOwnProperty(memberName)) {
				return context.globalObject[memberName];
			} else {
				const allNames = [...context.argumentNames, ...Object.keys(context.globalObject ?? {})].join(', ');
				throw Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETORESOLVENAME, memberName, allNames));
			}
		}
		public tryGetTypeReferenceAndMemberName() {
			const typeReference = this.tryGetTypeReference(/* skipSelf */ true);
			if (typeReference) {
				return [typeReference, this.name, this.rawName] as const;
			}
			return [undefined, this.name, this.rawName] as const;
		}
		public tryGetTypeReference(skipSelf?: boolean): FormulaTypeReference | undefined {
			if (this.useNullPropagation) {
				return undefined; // null propagation ?. is not type reference
			}
			if (this.expression != null && !(this.expression instanceof MemberExpression)) {
				return undefined; // base expression is not member expression
			}
			const baseTypeReference = this.expression instanceof MemberExpression ?
				this.expression.tryGetTypeReference(/* skipSelf */ false) : undefined;
			if (this.expression instanceof MemberExpression && !baseTypeReference) {
				return undefined; // base expression is not a type reference
			}
			if (skipSelf === true) {
				return baseTypeReference;
			} else {
				return new FormulaTypeReference({
					name: this.name,
					arguments: this.arguments,
					expression: baseTypeReference
				});
			}
		}
		public toObject(): FormulaMemberExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE,
				[FormulaConstants.NAME_ATTRIBUTE]: this.name,
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: expressionToObjectIfNotNull(this.expression),
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: typeArgumentsToObjectIfNotNull(this.arguments),
				[FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE]: !!this.useNullPropagation,
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			const typeArgumentsStr = this.hasTypeArguments() ? '<' + this.typeArguments() + '>' : '';
			if (this.expression) {
				return this.expression.toString() + (this.useNullPropagation ? '?.' : '.') + this.name + typeArgumentsStr;
			} else {
				return this.name + typeArgumentsStr;
			}
		}
		private hasTypeArguments(): boolean {
			return (this.arguments !== null && this.arguments !== undefined) && Object.getOwnPropertyNames(this.arguments).length > 0;
		}
		private typeArguments(): string {
			const result = [];
			for (const argumentNumber in this.arguments) {
				if (this.arguments.hasOwnProperty(argumentNumber) === false) {
					continue;
				}
				const argument = this.arguments[argumentNumber];
				if (!argument) {
					result.push('');
				} else {
					result.push(argument.toString());
				}
			}
			return result.toString();
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_PROPERTY_OR_FIELD, MemberExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE, MemberExpression);
	export class IndexExpression extends FormulaExpression implements NullPropagationExpression {
		public readonly arguments: ArgumentCollection;
		public readonly expression: FormulaExpression;
		public readonly useNullPropagation: boolean;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaIndexExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.arguments, 'values.arguments').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			super(ExpressionType.Index, values);
			this.arguments = objectToArguments(values.arguments);
			this.expression = FormulaExpression.create(values.expression);
			this.useNullPropagation = !!(values.useNullPropagation || false);
		}
		public isNullPropagationEnabled(): boolean {
			if (this.useNullPropagation) {
				return true;
			}
			if (isNullPropagationExpression(this.expression)) {
				return this.expression.isNullPropagationEnabled();
			}
			return false;
		}
		public execute(context: FormulaExecutionContext) {
			let target: any;
			if (this.expression instanceof MemberExpression) {
				const [typeReference, memberName] = this.expression.tryGetTypeReferenceAndMemberName();
				const resolvedType = typeReference ? context.resolveType(typeReference) :
					context.resolveType(new FormulaTypeReference({ name: memberName }));
				let baseExpression: FormulaExpression | undefined;
				let notAMemberExpression = false;
				if (resolvedType) {
					target = resolvedType;
				} else if (context.globalObject && memberName in context.globalObject) {
					target = context.globalObject;
				} else if ((baseExpression = this.expression.getTarget())) {
					target = baseExpression.execute(context);
				} else {
					target = this.expression.execute(context);
					notAMemberExpression = true;
				}
				if (!notAMemberExpression) {
					target = findMemberOnTarget(target, memberName);
				}
			} else {
				target = this.expression.execute(context);
			}
			const isNullPropagation = context.autoNullPropagation || this.isNullPropagationEnabled();
			if (target === null || target === undefined) {
				if (isNullPropagation) {
					return null;
				} else {
					throw Error(formatString(ExpressionResources.EXCEPTION_EXECUTION_CANTDONULLVALUE,
						this.expression.toString(), ExpressionType[this.expressionType]));
				}
			}
			const indexes = [];
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				const argument = this.arguments[argumentName];
				const value = (argument ? argument.execute(context) : '') || '';
				indexes.push(value);
			}
			if (indexes.length === 0) {
				throw Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETOBINDINDEXER,
					typeof target === 'object' ? target.constructor.name : typeof target, ExpressionType[this.expressionType]));
			}
			let nextTarget = target;
			for (let index of indexes) {
				if (target instanceof Array) {
					if (index === '') {
						index = 0;
					} else {
						index = parseInt(index, 10);
					}
				}
				if (Array.isArray(nextTarget)) {
					nextTarget = nextTarget[index];
				} else if (nextTarget instanceof Map) {
					nextTarget = nextTarget.get(index);
				} else if (isIterable(nextTarget)) {
					nextTarget = [...nextTarget][index];
				} else if (nextTarget != null && nextTarget !== undefined) {
					nextTarget = nextTarget[index];
				} else if (isNullPropagation) {
					nextTarget = null;
				} else {
					throw Error(formatString(ExpressionResources.EXCEPTION_EXECUTION_CANTDONULLVALUE,
						this.expression.toString(), ExpressionType[this.expressionType]));
				}
			}
			return nextTarget === undefined ? null : nextTarget;
			function isIterable(obj: any) {
				return obj != null && typeof obj[Symbol.iterator] === 'function';
			}
		}
		public toObject(): FormulaIndexExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_INDEX,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: argumentsToObject(this.arguments),
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: expressionToObject(this.expression),
				[FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE]: !!this.useNullPropagation,
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let result = this.expression.toString() + (this.useNullPropagation ? '?[' : '[');
			let isFirstArgument = true;
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				if (!isFirstArgument) {
					result += ', ';
				}
				const isDigitRegex = /^\d+$/;
				const argumentValue = this.arguments[argumentName];
				if (!isDigitRegex.test(argumentName)) {
					result += argumentName + ': ';
				}
				result += argumentValue === null ? 'null' : argumentValue.toString();
				isFirstArgument = false;
			}
			result += ']';
			return result;
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_INDEX, IndexExpression);
	export class InvokeExpression extends FormulaExpression implements NullPropagationExpression {
		public readonly arguments: ArgumentCollection;
		public readonly expression: FormulaExpression;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaInvokeExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			super(ExpressionType.Invoke, values);
			this.arguments = values.arguments ? objectToArguments(values.arguments) : {};
			this.expression = FormulaExpression.create(values.expression);
		}
		public isNullPropagationEnabled(): boolean {
			if (isNullPropagationExpression(this.expression)) {
				return this.expression.isNullPropagationEnabled();
			}
			return false;
		}
		public execute(context: FormulaExecutionContext) {
			const isNullPropagation = context.autoNullPropagation || this.isNullPropagationEnabled();
			let target: any;
			let invokable: any;
			if (this.expression instanceof MemberExpression) {
				const [typeReference, memberName] = this.expression.tryGetTypeReferenceAndMemberName();
				const resolvedType = typeReference ? context.resolveType(typeReference) :
					context.resolveType(new FormulaTypeReference({ name: memberName }));
				let baseExpression: FormulaExpression | undefined;
				if (resolvedType) {
					target = resolvedType;
				} else if (context.globalObject && memberName in context.globalObject) {
					target = context.globalObject;
				} else if ((baseExpression = this.expression.getTarget())) {
					target = baseExpression.execute(context);
				} else {
					target = null;
					invokable = this.expression.execute(context);
				}
				if (invokable === null || invokable === undefined) {
					if (isNullPropagation && (target === null || target === undefined)) {
						return null;
					}
					if (target === null || target === undefined) {
						throw Error(formatString(ExpressionResources.EXCEPTION_EXECUTION_CANTDONULLVALUE,
							this.expression.toString(), ExpressionType[this.expressionType]));
					}
					invokable = findMemberOnTarget(target, memberName);
					if ((invokable === null || invokable === undefined) && isNullPropagation) {
						return null;
					}
					if (!(invokable instanceof Function)) {
						throw Error(formatString(ExpressionResources.EXCEPTION_BIND_CALLMEMBERISNOTMETHOD,
							memberName, target.constructor?.name));
					}
				}
			} else {
				target = null;
				invokable = this.expression.execute(context);
				if ((invokable === null || invokable === undefined) && isNullPropagation) {
					return null;
				}
			}
			return this.invokeTarget(invokable, target, context);
		}
		private invokeTarget(invokable: any, target: any, context: FormulaExecutionContext) {
			if (typeof invokable !== 'function') {
				throw Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETOINVOKENONDELEG, typeof target));
			}
			const parameterNames = getFunctionParameterNames(invokable);
			const args = [];
			args.length = Math.max(parameterNames.length, invokable.length);
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				const isDigitRegex = /^\d+$/;
				const argument = this.arguments[argumentName];
				const argumentNumber = isDigitRegex.test(argumentName) ? parseInt(argumentName, 10) :
					parameterNames.indexOf(argumentName);
				if (argumentNumber < 0 || argumentNumber >= args.length) {
					continue; // unknown argument
				}
				args[argumentNumber] = argument == null ? null : argument.execute(context);
			}
			return invokable.apply(target, args);
		}
		public toObject(): FormulaInvokeExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_INVOKE,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: argumentsToObject(this.arguments),
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: expressionToObject(this.expression),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let result = this.expression.toString() + '(';
			let isFirstArgument = true;
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				if (!isFirstArgument) {
					result += ', ';
				}
				const isDigitRegex = /^\d+$/;
				const argumentValue = this.arguments[argumentName];
				if (!isDigitRegex.test(argumentName)) {
					result += argumentName + ': ';
				}
				result += argumentValue === null ? 'null' : argumentValue.toString();
				isFirstArgument = false;
			}
			result += ')';
			return result;
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_INVOKE, InvokeExpression);
	export class LambdaExpression extends FormulaExpression {
		public readonly arguments: ArgumentCollection;
		public readonly expression: FormulaExpression;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaLambdaExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			super(ExpressionType.Lambda, values);
			this.arguments = values.arguments ? objectToArguments(values.arguments) : {};
			this.expression = FormulaExpression.create(values.expression);
		}
		public execute(context: FormulaExecutionContext) {
			const parameterNames = this.getParameterNames();
			const subContext = context.createSubContext();
			for (let p = 0; p < parameterNames.length; p++) {
				const parameterName = parameterNames[p];
				subContext.setArgument(parameterName, null);
			}
			const expression = this.expression;
			return function executeLambdaBody() {
				const argsCount = Math.min(arguments.length, parameterNames.length);
				for (let p = 0; p < argsCount; p++) {
					const value = arguments[p];
					subContext.setArgument(parameterNames[p], value);
				}
				return expression.execute(subContext);
			};
		}
		public toObject(): FormulaLambdaExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_LAMBDA,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: argumentsToObject(this.arguments),
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: expressionToObject(this.expression),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let result = '(';
			let firstParam = true;
			if (this.arguments) {
				for (const argumentName in this.arguments) {
					if (!this.arguments.hasOwnProperty(argumentName)) {
						continue;
					}
					const argument = this.arguments[argumentName];
					if (firstParam === false) {
						result += ', ';
					}
					if (argument != null) {
						result += argument.toString() + ' ';
					}
					result += argumentName;
					firstParam = false;
				}
			}
			result += ')';
			result += ' => ';
			result += this.expression.toString();
			return result;
		}
		private getParameterNames(): Array<string> {
			if (!this.arguments) {
				return [];
			}
			const parameterNames = [];
			for (const argumentNumber in this.arguments) {
				if (this.arguments.hasOwnProperty(argumentNumber)) {
					const argument = this.arguments[argumentNumber];
					parameterNames.push(argument.toString());
				}
			}
			return parameterNames;
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_LAMBDA, LambdaExpression);
	export class NewArrayBoundExpression extends FormulaExpression {
		public readonly arguments: ArgumentCollection;
		public readonly type: FormulaTypeReference;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaNewArrayBoundExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.arguments, 'values.arguments').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.NewArrayBounds, values);
			this.arguments = objectToArguments(values.arguments);
			this.type = FormulaTypeReference.create(values.type);
		}
		public execute(context: FormulaExecutionContext) {
			const lengths = <number[]>[];
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				const argument = this.arguments[argumentName];
				const length = argument ? parseInt(argument.execute(context) ?? 0, 10) : 0;
				lengths.push(length);
			}
			const array: any[] = [];
			const defaultValue = new DefaultExpression({
				expressionType: FormulaConstants.EXPRESSION_TYPE_DEFAULT,
				type: this.type,
				_pos: this._pos
			}).execute();
			if (lengths.length > 0) {
				this.initialize(array, lengths, 0, defaultValue);
			}
			return array;
		}
		initialize(array: any[], lengths: number[], index: number, defaultValue: any) {
			const length = lengths[index];
			if (index === lengths.length - 1) {
				for (let i = 0; i < length; i++) {
					array.push(defaultValue);
				}
			} else {
				for (let i = 0; i < length; i++) {
					const subArray: any[] = [];
					this.initialize(subArray, lengths, index + 1, defaultValue);
					array.push(subArray);
				}
			}
		}
		public toObject(): FormulaNewArrayBoundExpressionObj & FormulaExpressionObj {
			return {
				// eslint-disable-next-line max-len
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: argumentsToObject(this.arguments),
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let result = 'new ' + this.type.toString() + '[';
			let isFirstArgument = true;
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				if (!isFirstArgument) {
					result += ', ';
				}
				const argumentValue = this.arguments[argumentName];
				result += argumentValue === null ? 'null' : argumentValue.toString();
				isFirstArgument = false;
			}
			result += ']';
			return result;
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS, NewArrayBoundExpression);
	export class NewExpression extends FormulaExpression {
		public readonly arguments: ArgumentCollection;
		public readonly type: FormulaTypeReference;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaNewExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.New, values);
			this.arguments = values.arguments ? objectToArguments(values.arguments) : {};
			this.type = FormulaTypeReference.create(values.type);
		}
		public execute(context: FormulaExecutionContext) {
			const ctr = context.resolveType(this.type);
			if (!ctr) {
				throw new Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETORESOLVETYPE, this.type));
			}
			const parameterNames = getFunctionParameterNames(ctr);
			const args: any[] = [];
			args.length = Math.max(parameterNames.length, ctr.length);
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				const isDigitRegex = /^\d+$/;
				const argument = this.arguments[argumentName];
				const argumentNumber = isDigitRegex.test(argumentName) ?
					parseInt(argumentName, 10) :
					parameterNames.indexOf(argumentName);
				if (argumentNumber < 0 || argumentNumber >= args.length) {
					continue; // unknown argument
				}
				args[argumentNumber] = argument == null ? null : argument.execute(context);
			}
			if ('new' in ctr && typeof (ctr.new) === 'function') {
				return ctr.new(...args);
			} else {
				args.unshift(ctr);
				return new (Function.prototype.bind.apply(ctr, <any>args));
			}
		}
		public toObject(): FormulaNewExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_NEW,
				[FormulaConstants.ARGUMENTS_ATTRIBUTE]: argumentsToObject(this.arguments),
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			let result = 'new ' + this.type.toString() + '(';
			let isFirstArgument = true;
			for (const argumentName in this.arguments) {
				if (!this.arguments.hasOwnProperty(argumentName)) {
					continue;
				}
				if (!isFirstArgument) {
					result += ', ';
				}
				const isDigitRegex = /^\d+$/;
				const argumentValue = this.arguments[argumentName];
				if (!isDigitRegex.test(argumentName)) {
					result += argumentName + ': ';
				}
				result += argumentValue === null ? 'null' : argumentValue.toString();
				isFirstArgument = false;
			}
			result += ')';
			return result;
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NEW, NewExpression);
	export class TypeIsExpression extends FormulaExpression {
		public readonly expression: FormulaExpression;
		public readonly type: FormulaTypeReference;
		// eslint-disable-next-line max-len
		constructor(values: ExpressionObjOrImpl<FormulaTypeIsExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.TypeIs, values);
			this.expression = FormulaExpression.create(values.expression);
			this.type = FormulaTypeReference.create(values.type);
		}
		public execute(context: FormulaExecutionContext) {
			const typeFunction = context.resolveType(this.type);
			const target = this.expression.execute(context);
			if (!typeFunction) {
				throw new Error(formatString(ExpressionResources.EXCEPTION_BIND_UNABLETORESOLVETYPE, this.type));
			}
			if ('is' in typeFunction && typeof (typeFunction.is) === 'function') {
				return typeFunction.is(target);
			} else {
				return target instanceof typeFunction;
			}
		}
		public toObject(): FormulaTypeIsExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_TYPE_IS,
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: expressionToObject(this.expression),
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			return this.expression.toString() + ' is ' + this.type.toString();
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_TYPE_IS, TypeIsExpression);
	export class TypeOfExpression extends FormulaExpression {
		public readonly type: FormulaTypeReference;
		constructor(values: ExpressionObjOrImpl<FormulaTypeOfExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.type, 'values.type').not.nullOrUndefined();
			super(ExpressionType.Constant, values);
			this.type = FormulaTypeReference.create(values.type);
		}
		public execute(context: FormulaExecutionContext) {
			const type = context.resolveType(this.type);
			return type;
		}
		public toObject(): FormulaTypeOfExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as FormulaConstants.EXPRESSION_TYPE_TYPE_OF,
				[FormulaConstants.TYPE_ATTRIBUTE]: this.type.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			return this.type === null ? 'default(System.Type)' : 'typeof(' + this.type.toString() + ')';
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_TYPE_OF, TypeOfExpression);
	export class UnaryExpression extends FormulaExpression {
		public readonly expression: FormulaExpression;
		constructor(values: ExpressionObjOrImpl<FormulaUnaryExpressionObj>) {
			check(values, 'values').not.nullOrUndefined();
			check(values.expressionType, 'values.expressionType').not.nullOrUndefined();
			check(values.expression, 'values.expression').not.nullOrUndefined();
			/* eslint-disable max-len */
			switch (values.expressionType) {
				case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE: super(ExpressionType.Noop, values); break;
				case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE: super(ExpressionType.Noop, values); break;
				case FormulaConstants.EXPRESSION_TYPE_GROUP: super(ExpressionType.Noop, values); break;
				case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: super(ExpressionType.UnaryPlus, values); break;
				case FormulaConstants.EXPRESSION_TYPE_NEGATE: super(ExpressionType.Negate, values); break;
				case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED: super(ExpressionType.NegateChecked, values); break;
				case FormulaConstants.EXPRESSION_TYPE_NOT: super(ExpressionType.Not, values); break;
				case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: super(ExpressionType.Not, values); break;
				default: throw new FormulaError(formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNUNARYEXPRTYPE, values.expressionType), values);
			}
			/* eslint-enable max-len */
			this.expression = FormulaExpression.create(values.expression);
		}
		public execute(context: FormulaExecutionContext) {
			const target = this.expression.execute(context);
			if ((target === null || target === undefined) && this.expressionTypeName !== FormulaConstants.EXPRESSION_TYPE_NOT) {
				return null;
			}
			switch (this.expressionTypeName) {
				case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE:
				case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE:
				case FormulaConstants.EXPRESSION_TYPE_GROUP: return target;
				case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: return +target;
				case FormulaConstants.EXPRESSION_TYPE_NEGATE:
				case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED: return -target;
				case FormulaConstants.EXPRESSION_TYPE_NOT: {
					return !coerceToBoolean(target);
				}
				// eslint-disable-next-line no-bitwise
				case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: return ~target;
				default: throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNUNARYEXPRTYPE, this.expressionTypeName), this);
			}
		}
		public toObject(): FormulaUnaryExpressionObj & FormulaExpressionObj {
			return {
				[FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE]: this.expressionTypeName as UnaryExpressionType,
				[FormulaConstants.EXPRESSION_ATTRIBUTE]: this.expression.toObject(),
				[FormulaConstants.ORIGINAL_C_SHARP_CODE_ATTRIBUTE]: this.cSharpSourceCode,
				[FormulaConstants.POSITION_ATTRIBUTE]: this._pos,
			};
		}
		public toString(): string {
			if (this.cSharpSourceCode) {
				return this.cSharpSourceCode;
			}
			switch (this.expressionTypeName) {
				case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE: return 'unchecked(' + this.expression.toString() + ')';
				case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE: return 'checked(' + this.expression.toString() + ')';
				case FormulaConstants.EXPRESSION_TYPE_GROUP: return '(' + this.expression.toString() + ')';
				case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: return '+' + this.expression.toString();
				case FormulaConstants.EXPRESSION_TYPE_NEGATE: return '-' + this.expression.toString();
				case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED: return '-' + this.expression.toString();
				case FormulaConstants.EXPRESSION_TYPE_NOT: return '!' + this.expression.toString();
				case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: return '~' + this.expression.toString();
				default: throw new FormulaError(
					formatString(ExpressionResources.EXCEPTION_COMPIL_UNKNOWNUNARYEXPRTYPE, this.expressionTypeName), this);
			}
		}
	}
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_GROUP, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NEGATE, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_NOT, UnaryExpression);
	registerExpressionType(FormulaConstants.EXPRESSION_TYPE_COMPLEMENT, UnaryExpression);
	export abstract class FormulaExpressionVisitor {
		public visit(expression: FormulaExpression | null | undefined) {
			if (!expression) {
				return null;
			}
			switch (expression.constructor) {
				case BinaryExpression: return this.visitBinary(<BinaryExpression>expression);
				case ConditionExpression: return this.visitCondition(<ConditionExpression>expression);
				case ConstantExpression: return this.visitConstant(<ConstantExpression>expression);
				case ConvertExpression: return this.visitConvert(<ConvertExpression>expression);
				case DefaultExpression: return this.visitDefault(<DefaultExpression>expression);
				case IndexExpression: return this.visitIndex(<IndexExpression>expression);
				case InvokeExpression: return this.visitInvoke(<InvokeExpression>expression);
				case LambdaExpression: return this.visitLambda(<LambdaExpression>expression);
				case MemberExpression: return this.visitMember(<MemberExpression>expression);
				case NewArrayBoundExpression: return this.visitNewArrayBounds(<NewArrayBoundExpression>expression);
				case NewExpression: return this.visitNew(<NewExpression>expression);
				case TypeIsExpression: return this.visitTypeIs(<TypeIsExpression>expression);
				case TypeOfExpression: return this.visitTypeOf(<TypeOfExpression>expression);
				case UnaryExpression: return this.visitUnary(<UnaryExpression>expression);
				default: throw new Error(`Unknown expression type ${expression.constructor.name}.`);
			}
		}
		public visitConstant(constantExpression: ConstantExpression): FormulaExpression {
			return constantExpression;
		}
		public visitConvert(convertExpression: ConvertExpression): FormulaExpression {
			return convertExpression;
		}
		public visitDefault(defaultExpression: DefaultExpression): FormulaExpression {
			return defaultExpression;
		}
		public visitIndex(indexExpression: IndexExpression): FormulaExpression {
			return indexExpression;
		}
		public visitInvoke(invokeExpression: InvokeExpression): FormulaExpression {
			return invokeExpression;
		}
		public visitLambda(lambdaExpression: LambdaExpression): FormulaExpression {
			return lambdaExpression;
		}
		public visitMember(memberExpression: MemberExpression): FormulaExpression {
			return memberExpression;
		}
		public visitNewArrayBounds(newArrayBoundExpression: NewArrayBoundExpression): FormulaExpression {
			return newArrayBoundExpression;
		}
		public visitNew(newExpression: NewExpression): FormulaExpression {
			return newExpression;
		}
		public visitTypeIs(typeIsExpression: TypeIsExpression): FormulaExpression {
			return typeIsExpression;
		}
		public visitTypeOf(typeOfExpression: TypeOfExpression): FormulaExpression {
			return typeOfExpression;
		}
		public visitUnary(unaryExpression: UnaryExpression): FormulaExpression {
			return unaryExpression;
		}
		public visitCondition(conditionExpression: ConditionExpression): FormulaExpression {
			return conditionExpression;
		}
		public visitBinary(binaryExpression: BinaryExpression): FormulaExpression {
			return binaryExpression;
		}
	}
	export interface FormulaTypeResolver {
		resolveType(type: FormulaTypeReference): Function | undefined;
	}
	export function prepareClassOrEnum(type: Function | object): Function {
		if (typeof (type) === 'function') {
			return type;
		} else if (typeof (type) === 'object') {
			return createDotNetEnum<any>(type);
		} else {
			throw new Error(`Unable to use object '${type}' as type for FormulaTypeResolver. Make sure it is enum(object) or function.`);
		}
	}
	/* eslint-disable @typescript-eslint/naming-convention */
	export enum TypeNameFormattingOptions {
		None = 0,
		Aliases = 0x1 << 0,
		ShortNames = 0x1 << 1,
		Arrays = 0x1 << 2,
		All = Aliases | ShortNames | Arrays
	}
	/* eslint-enable @typescript-eslint/naming-convention */

<#+ 
	}
#>
