<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormatters(CodeGenerationContext context)
	{
#>
		export function utf8Count(str: string): number {
		const strLength = str.length;
		let byteLength = 0;
		let pos = 0;
		while (pos < strLength) {
			let value = str.charCodeAt(pos++);
			if ((value & 0xffffff80) === 0) {
				// 1-byte
				byteLength++;
				continue;
			} else if ((value & 0xfffff800) === 0) {
				// 2-bytes
				byteLength += 2;
			} else {
				// handle surrogate pair
				if (value >= 0xd800 && value <= 0xdbff) {
					// high surrogate
					if (pos < strLength) {
						const extra = str.charCodeAt(pos);
						if ((extra & 0xfc00) === 0xdc00) {
							++pos;
							value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
						}
					}
				}
				if ((value & 0xffff0000) === 0) {
					// 3-byte
					byteLength += 3;
				} else {
					// 4-byte
					byteLength += 4;
				}
			}
		}
		return byteLength;
	}
	export function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {
		const strLength = str.length;
		let offset = outputOffset;
		let pos = 0;
		while (pos < strLength) {
			let value = str.charCodeAt(pos++);
			if ((value & 0xffffff80) === 0) {
				// 1-byte
				output[offset++] = value;
				continue;
			} else if ((value & 0xfffff800) === 0) {
				// 2-bytes
				output[offset++] = ((value >> 6) & 0x1f) | 0xc0;
			} else {
				// handle surrogate pair
				if (value >= 0xd800 && value <= 0xdbff) {
					// high surrogate
					if (pos < strLength) {
						const extra = str.charCodeAt(pos);
						if ((extra & 0xfc00) === 0xdc00) {
							++pos;
							value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
						}
					}
				}
				if ((value & 0xffff0000) === 0) {
					// 3-byte
					output[offset++] = ((value >> 12) & 0x0f) | 0xe0;
					output[offset++] = ((value >> 6) & 0x3f) | 0x80;
				} else {
					// 4-byte
					output[offset++] = ((value >> 18) & 0x07) | 0xf0;
					output[offset++] = ((value >> 12) & 0x3f) | 0x80;
					output[offset++] = ((value >> 6) & 0x3f) | 0x80;
				}
			}
			output[offset++] = (value & 0x3f) | 0x80;
		}
	}
	// TextEncoder and TextDecoder are standardized in whatwg encoding:
	// https://encoding.spec.whatwg.org/
	// and available in all the modern browsers:
	// https://caniuse.com/textencoder
	// They are available in Node.js since v12 LTS as well:
	// https://nodejs.org/api/globals.html#textencoder
	const sharedTextEncoder = new TextEncoder();
	// This threshold should be determined by benchmarking, which might vary in engines and input data.
	// Run `npx ts-node benchmark/encode-string.ts` for details.
	const TEXT_ENCODER_THRESHOLD = 50;
	export function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {
		sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
	}
	export function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {
		if (str.length > TEXT_ENCODER_THRESHOLD) {
			utf8EncodeTE(str, output, outputOffset);
		} else {
			utf8EncodeJs(str, output, outputOffset);
		}
	}
	const CHUNK_SIZE = 0x1_000;
	export function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {
		let offset = inputOffset;
		const end = offset + byteLength;
		const units: Array<number> = [];
		let result = "";
		while (offset < end) {
			const byte1 = bytes[offset++]!;
			if ((byte1 & 0x80) === 0) {
				// 1 byte
				units.push(byte1);
			} else if ((byte1 & 0xe0) === 0xc0) {
				// 2 bytes
				const byte2 = bytes[offset++]! & 0x3f;
				units.push(((byte1 & 0x1f) << 6) | byte2);
			} else if ((byte1 & 0xf0) === 0xe0) {
				// 3 bytes
				const byte2 = bytes[offset++]! & 0x3f;
				const byte3 = bytes[offset++]! & 0x3f;
				units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
			} else if ((byte1 & 0xf8) === 0xf0) {
				// 4 bytes
				const byte2 = bytes[offset++]! & 0x3f;
				const byte3 = bytes[offset++]! & 0x3f;
				const byte4 = bytes[offset++]! & 0x3f;
				let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
				if (unit > 0xffff) {
					unit -= 0x10000;
					units.push(((unit >>> 10) & 0x3ff) | 0xd800);
					unit = 0xdc00 | (unit & 0x3ff);
				}
				units.push(unit);
			} else {
				units.push(byte1);
			}
			if (units.length >= CHUNK_SIZE) {
				result += String.fromCharCode(...units);
				units.length = 0;
			}
		}
		if (units.length > 0) {
			result += String.fromCharCode(...units);
		}
		return result;
	}
	const sharedTextDecoder = new TextDecoder();
	// This threshold should be determined by benchmarking, which might vary in engines and input data.
	// Run `npx ts-node benchmark/decode-string.ts` for details.
	const TEXT_DECODER_THRESHOLD = 200;
	export function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {
		const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
		return sharedTextDecoder.decode(stringBytes);
	}
	export function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {
		if (byteLength > TEXT_DECODER_THRESHOLD) {
			return utf8DecodeTD(bytes, inputOffset, byteLength);
		} else {
			return utf8DecodeJs(bytes, inputOffset, byteLength);
		}
	}
		export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {
		if (buffer instanceof Uint8Array) {
			return buffer;
		} else if (ArrayBuffer.isView(buffer)) {
			return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
		} else if (buffer instanceof ArrayBuffer) {
			return new Uint8Array(buffer);
		} else {
			// ArrayLike<number>
			return Uint8Array.from(buffer);
		}
	}
	export function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {
		if (buffer instanceof ArrayBuffer) {
			return new DataView(buffer);
		}
		const bufferView = ensureUint8Array(buffer);
		return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
	}
		export enum GameDataFormat {
		Json,
		MessagePack
	}
	export interface GameDataLoadOptions {
		format: GameDataFormat,
		patches: ReadonlyArray<BufferSource | ArrayLike<number>>,
	}
		export interface GameDataReader {
		readObject(): object;
		close(): void;
	}
		export class JsonGameDataReader implements GameDataReader {
		private jsonString: string;
		constructor(buffer: BufferSource | ArrayLike<number>) {
			check(buffer, 'buffer').is.not.nullOrUndefined();
			const dataAsU8Array = ensureUint8Array(buffer);
			this.jsonString = utf8Decode(dataAsU8Array, 0, dataAsU8Array.length);
		}
		readObject(): object {
			const parsedData = JSON.parse(this.jsonString)
			if (typeof parsedData !== 'object' || parsedData === null) {
				throw new Error(`Invalid JSON data. An object is expected while '${parsedData}' has been read.`)
			}
			return parsedData;
		}
		close(): void {
			this.jsonString = '';
		}
	}
		/*
		Copyright 2019 The MessagePack Community.
		Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	*/
	function prettyByte(byte: number): string {
		return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
	}
	// Integer Utility
	const UINT32_MAX = 0xffff_ffff;
	// DataView extension to handle int64 / uint64,
	// where the actual range is 53-bits integer (a.k.a. safe integer)
	function setUint64(view: DataView, offset: number, value: number): void {
		const high = value / 0x1_0000_0000;
		const low = value; // high bits are truncated by DataView
		view.setUint32(offset, high);
		view.setUint32(offset + 4, low);
	}
	function setInt64(view: DataView, offset: number, value: number): void {
		const high = Math.floor(value / 0x1_0000_0000);
		const low = value; // high bits are truncated by DataView
		view.setUint32(offset, high);
		view.setUint32(offset + 4, low);
	}
	function getInt64(view: DataView, offset: number): number {
		const high = view.getInt32(offset);
		const low = view.getUint32(offset + 4);
		return high * 0x1_0000_0000 + low;
	}
	function getUint64(view: DataView, offset: number): number {
		const high = view.getUint32(offset);
		const low = view.getUint32(offset + 4);
		return high * 0x1_0000_0000 + low;
	}
	const DEFAULT_MAX_KEY_LENGTH = 16;
	const DEFAULT_MAX_LENGTH_PER_KEY = 16;
	interface KeyDecoder {
		canBeCached(byteLength: number): boolean;
		decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;
	}
	interface KeyCacheRecord {
		readonly bytes: Uint8Array;
		readonly str: string;
	}
	class CachedKeyDecoder implements KeyDecoder {
		hit = 0;
		miss = 0;
		private readonly caches: Array<Array<KeyCacheRecord>>;
		constructor(
			readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH,
			readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY,
		) {
			// avoid `new Array(N)`, which makes a sparse array,
			// because a sparse array is typically slower than a non-sparse array.
			this.caches = [];
			for (let i = 0; i < this.maxKeyLength; i++) {
				this.caches.push([]);
			}
		}
		public canBeCached(byteLength: number): boolean {
			return byteLength > 0 && byteLength <= this.maxKeyLength;
		}
		private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {
			const records = this.caches[byteLength - 1]!;
			FIND_CHUNK: for (const record of records) {
				const recordBytes = record.bytes;
				for (let j = 0; j < byteLength; j++) {
					if (recordBytes[j] !== bytes[inputOffset + j]) {
						continue FIND_CHUNK;
					}
				}
				return record.str;
			}
			return null;
		}
		private store(bytes: Uint8Array, value: string) {
			const records = this.caches[bytes.length - 1]!;
			const record: KeyCacheRecord = {bytes, str: value};
			if (records.length >= this.maxLengthPerKey) {
				// `records` are full!
				// Set `record` to an arbitrary position.
				records[(Math.random() * records.length) | 0] = record;
			} else {
				records.push(record);
			}
		}
		public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {
			const cachedValue = this.find(bytes, inputOffset, byteLength);
			if (cachedValue != null) {
				this.hit++;
				return cachedValue;
			}
			this.miss++;
			const str = utf8DecodeJs(bytes, inputOffset, byteLength);
			// Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
			const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
			this.store(slicedCopyOfBytes, str);
			return str;
		}
	}
	class DecodeError extends Error {
		constructor(message: string) {
			super(message);
			// fix the prototype chain in a cross-platform way
			const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);
			Object.setPrototypeOf(this, proto);
			Object.defineProperty(this, "name", {
				configurable: true,
				enumerable: false,
				value: DecodeError.name,
			});
		}
	}
	type SplitTypes<T, U> = U extends T ? (Exclude<T, U> extends never ? T : Exclude<T, U>) : T;
	type SplitUndefined<T> = SplitTypes<T, undefined>;
	type ContextOf<ContextType> = ContextType extends undefined
		? {}
		: {
			/**
			 * Custom user-defined data, read/writable
			 */
			context: ContextType;
		};
	type DecoderOptions<ContextType = undefined> = Readonly<Partial<{
		/**
		 * Decodes Int64 and Uint64 as bigint if it's set to true.
		 * Depends on ES2020's {@link DataView#getBigInt64} and
		 * {@link DataView#getBigUint64}.
		 *
		 * Defaults to false.
		 */
		useBigInt64: boolean;
		/**
		 * Maximum string length.
		 *
		 * Defaults to 4_294_967_295 (UINT32_MAX).
		 */
		maxStrLength: number;
		/**
		 * Maximum binary length.
		 *
		 * Defaults to 4_294_967_295 (UINT32_MAX).
		 */
		maxBinLength: number;
		/**
		 * Maximum array length.
		 *
		 * Defaults to 4_294_967_295 (UINT32_MAX).
		 */
		maxArrayLength: number;
		/**
		 * Maximum map length.
		 *
		 * Defaults to 4_294_967_295 (UINT32_MAX).
		 */
		maxMapLength: number;
		/**
		 * Maximum extension length.
		 *
		 * Defaults to 4_294_967_295 (UINT32_MAX).
		 */
		maxExtLength: number;
		/**
		 * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.
		 * `null` is a special value to disable the use of the key decoder at all.
		 */
		keyDecoder: KeyDecoder | null;
	}>> & ContextOf<ContextType>;
	const STATE_ARRAY = "array";
	const STATE_MAP_KEY = "map_key";
	const STATE_MAP_VALUE = "map_value";
	type MapKeyType = string | number;
	const isValidMapKeyType = (key: unknown): key is MapKeyType => {
		return typeof key === "string" || typeof key === "number";
	};
	type StackMapState = {
		type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;
		size: number;
		key: MapKeyType | null;
		readCount: number;
		map: Record<string, unknown>;
	};
	type StackArrayState = {
		type: typeof STATE_ARRAY;
		size: number;
		array: Array<unknown>;
		position: number;
	};
	class StackPool {
		private readonly stack: Array<StackState> = [];
		private stackHeadPosition = -1;
		public get length(): number {
			return this.stackHeadPosition + 1;
		}
		public top(): StackState | undefined {
			return this.stack[this.stackHeadPosition];
		}
		public pushArrayState(size: number) {
			const state = this.getUninitializedStateFromPool() as StackArrayState;
			state.type = STATE_ARRAY;
			state.position = 0;
			state.size = size;
			state.array = new Array(size);
		}
		public pushMapState(size: number) {
			const state = this.getUninitializedStateFromPool() as StackMapState;
			state.type = STATE_MAP_KEY;
			state.readCount = 0;
			state.size = size;
			state.map = {};
		}
		private getUninitializedStateFromPool() {
			this.stackHeadPosition++;
			if (this.stackHeadPosition === this.stack.length) {
				const partialState: Partial<StackState> = {
					type: undefined,
					size: 0,
					array: undefined,
					position: 0,
					readCount: 0,
					map: undefined,
					key: null,
				};
				this.stack.push(partialState as StackState);
			}
			return this.stack[this.stackHeadPosition];
		}
		public release(state: StackState): void {
			const topStackState = this.stack[this.stackHeadPosition];
			if (topStackState !== state) {
				throw new Error("Invalid stack state. Released state is not on top of the stack.");
			}
			if (state.type === STATE_ARRAY) {
				const partialState = state as Partial<StackArrayState>;
				partialState.size = 0;
				partialState.array = undefined;
				partialState.position = 0;
				partialState.type = undefined;
			}
			if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
				const partialState = state as Partial<StackMapState>;
				partialState.size = 0;
				partialState.map = undefined;
				partialState.readCount = 0;
				partialState.type = undefined;
			}
			this.stackHeadPosition--;
		}
		public reset(): void {
			this.stack.length = 0;
			this.stackHeadPosition = -1;
		}
	}
	type StackState = StackArrayState | StackMapState;
	const HEAD_BYTE_REQUIRED = -1;
	const EMPTY_VIEW = new DataView(new ArrayBuffer(0));
	const EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
	try {
		// IE11: The spec says it should throw RangeError,
		// IE11: but in IE11 it throws TypeError.
		EMPTY_VIEW.getInt8(0);
	} catch (e) {
		if (!(e instanceof RangeError)) {
			throw new Error(
				"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access",
			);
		}
	}
	const DataViewIndexOutOfBoundsError = RangeError;
	const MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
	const sharedCachedKeyDecoder = new CachedKeyDecoder();
	class Decoder<ContextType = undefined> {
		private readonly context: ContextType;
		private readonly useBigInt64: boolean;
		private readonly maxStrLength: number;
		private readonly maxBinLength: number;
		private readonly maxArrayLength: number;
		private readonly maxMapLength: number;
		private readonly maxExtLength: number;
		private readonly keyDecoder: KeyDecoder | null;
		private totalPos = 0;
		private pos = 0;
		private view = EMPTY_VIEW;
		private bytes = EMPTY_BYTES;
		private headByte = HEAD_BYTE_REQUIRED;
		private readonly stack = new StackPool();
		public constructor(options?: DecoderOptions<ContextType>) {
			this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined
			this.useBigInt64 = options?.useBigInt64 ?? false;
			this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;
			this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;
			this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;
			this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;
			this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;
			this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;
		}
		private reinitializeState() {
			this.totalPos = 0;
			this.headByte = HEAD_BYTE_REQUIRED;
			this.stack.reset();
			// view, bytes, and pos will be re-initialized in setBuffer()
		}
		private setBuffer(buffer: ArrayLike<number> | BufferSource): void {
			this.bytes = ensureUint8Array(buffer);
			this.view = createDataView(this.bytes);
			this.pos = 0;
		}
		private appendBuffer(buffer: ArrayLike<number> | BufferSource) {
			if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
				this.setBuffer(buffer);
			} else {
				const remainingData = this.bytes.subarray(this.pos);
				const newData = ensureUint8Array(buffer);
				// concat remainingData + newData
				const newBuffer = new Uint8Array(remainingData.length + newData.length);
				newBuffer.set(remainingData);
				newBuffer.set(newData, remainingData.length);
				this.setBuffer(newBuffer);
			}
		}
		private hasRemaining(size: number) {
			return this.view.byteLength - this.pos >= size;
		}
		private createExtraByteError(posToShow: number): Error {
			const {view, pos} = this;
			return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
		}
		/**
		 * @throws {@link DecodeError}
		 * @throws {@link RangeError}
		 */
		public decode(buffer: ArrayLike<number> | BufferSource): unknown {
			this.reinitializeState();
			this.setBuffer(buffer);
			const object = this.doDecodeSync();
			if (this.hasRemaining(1)) {
				throw this.createExtraByteError(this.pos);
			}
			return object;
		}
		public* decodeMulti(buffer: ArrayLike<number> | BufferSource): Generator<unknown, void, unknown> {
			this.reinitializeState();
			this.setBuffer(buffer);
			while (this.hasRemaining(1)) {
				yield this.doDecodeSync();
			}
		}
		public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>): Promise<unknown> {
			let decoded = false;
			let object: unknown;
			for await (const buffer of stream) {
				if (decoded) {
					throw this.createExtraByteError(this.totalPos);
				}
				this.appendBuffer(buffer);
				try {
					object = this.doDecodeSync();
					decoded = true;
				} catch (e) {
					if (!(e instanceof DataViewIndexOutOfBoundsError)) {
						throw e; // rethrow
					}
					// fallthrough
				}
				this.totalPos += this.pos;
			}
			if (decoded) {
				if (this.hasRemaining(1)) {
					throw this.createExtraByteError(this.totalPos);
				}
				return object;
			}
			const {headByte, pos, totalPos} = this;
			throw new RangeError(
				`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,
			);
		}
		public decodeArrayStream(
			stream: AsyncIterable<ArrayLike<number> | BufferSource>,
		): AsyncGenerator<unknown, void, unknown> {
			return this.decodeMultiAsync(stream, true);
		}
		public decodeStream(stream: AsyncIterable<ArrayLike<number> | BufferSource>): AsyncGenerator<unknown, void, unknown> {
			return this.decodeMultiAsync(stream, false);
		}
		private async* decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | BufferSource>, isArray: boolean) {
			let isArrayHeaderRequired = isArray;
			let arrayItemsLeft = -1;
			for await (const buffer of stream) {
				if (isArray && arrayItemsLeft === 0) {
					throw this.createExtraByteError(this.totalPos);
				}
				this.appendBuffer(buffer);
				if (isArrayHeaderRequired) {
					arrayItemsLeft = this.readArraySize();
					isArrayHeaderRequired = false;
					this.complete();
				}
				try {
					while (true) {
						yield this.doDecodeSync();
						if (--arrayItemsLeft === 0) {
							break;
						}
					}
				} catch (e) {
					if (!(e instanceof DataViewIndexOutOfBoundsError)) {
						throw e; // rethrow
					}
					// fallthrough
				}
				this.totalPos += this.pos;
			}
		}
		private doDecodeSync(): unknown {
			DECODE: while (true) {
				const headByte = this.readHeadByte();
				let object: unknown;
				if (headByte >= 0xe0) {
					// negative fixint (111x xxxx) 0xe0 - 0xff
					object = headByte - 0x100;
				} else if (headByte < 0xc0) {
					if (headByte < 0x80) {
						// positive fixint (0xxx xxxx) 0x00 - 0x7f
						object = headByte;
					} else if (headByte < 0x90) {
						// fixmap (1000 xxxx) 0x80 - 0x8f
						const size = headByte - 0x80;
						if (size !== 0) {
							this.pushMapState(size);
							this.complete();
							continue DECODE;
						} else {
							object = {};
						}
					} else if (headByte < 0xa0) {
						// fixarray (1001 xxxx) 0x90 - 0x9f
						const size = headByte - 0x90;
						if (size !== 0) {
							this.pushArrayState(size);
							this.complete();
							continue DECODE;
						} else {
							object = [];
						}
					} else {
						// fixstr (101x xxxx) 0xa0 - 0xbf
						const byteLength = headByte - 0xa0;
						object = this.decodeUtf8String(byteLength, 0);
					}
				} else if (headByte === 0xc0) {
					// nil
					object = null;
				} else if (headByte === 0xc2) {
					// false
					object = false;
				} else if (headByte === 0xc3) {
					// true
					object = true;
				} else if (headByte === 0xca) {
					// float 32
					object = this.readF32();
				} else if (headByte === 0xcb) {
					// float 64
					object = this.readF64();
				} else if (headByte === 0xcc) {
					// uint 8
					object = this.readU8();
				} else if (headByte === 0xcd) {
					// uint 16
					object = this.readU16();
				} else if (headByte === 0xce) {
					// uint 32
					object = this.readU32();
				} else if (headByte === 0xcf) {
					// uint 64
					if (this.useBigInt64) {
						object = this.readU64AsBigInt();
					} else {
						object = this.readU64();
					}
				} else if (headByte === 0xd0) {
					// int 8
					object = this.readI8();
				} else if (headByte === 0xd1) {
					// int 16
					object = this.readI16();
				} else if (headByte === 0xd2) {
					// int 32
					object = this.readI32();
				} else if (headByte === 0xd3) {
					// int 64
					if (this.useBigInt64) {
						object = this.readI64AsBigInt();
					} else {
						object = this.readI64();
					}
				} else if (headByte === 0xd9) {
					// str 8
					const byteLength = this.lookU8();
					object = this.decodeUtf8String(byteLength, 1);
				} else if (headByte === 0xda) {
					// str 16
					const byteLength = this.lookU16();
					object = this.decodeUtf8String(byteLength, 2);
				} else if (headByte === 0xdb) {
					// str 32
					const byteLength = this.lookU32();
					object = this.decodeUtf8String(byteLength, 4);
				} else if (headByte === 0xdc) {
					// array 16
					const size = this.readU16();
					if (size !== 0) {
						this.pushArrayState(size);
						this.complete();
						continue DECODE;
					} else {
						object = [];
					}
				} else if (headByte === 0xdd) {
					// array 32
					const size = this.readU32();
					if (size !== 0) {
						this.pushArrayState(size);
						this.complete();
						continue DECODE;
					} else {
						object = [];
					}
				} else if (headByte === 0xde) {
					// map 16
					const size = this.readU16();
					if (size !== 0) {
						this.pushMapState(size);
						this.complete();
						continue DECODE;
					} else {
						object = {};
					}
				} else if (headByte === 0xdf) {
					// map 32
					const size = this.readU32();
					if (size !== 0) {
						this.pushMapState(size);
						this.complete();
						continue DECODE;
					} else {
						object = {};
					}
				} else if (headByte === 0xc4) {
					// bin 8
					const size = this.lookU8();
					object = this.decodeBinary(size, 1);
				} else if (headByte === 0xc5) {
					// bin 16
					const size = this.lookU16();
					object = this.decodeBinary(size, 2);
				} else if (headByte === 0xc6) {
					// bin 32
					const size = this.lookU32();
					object = this.decodeBinary(size, 4);
				} else if (headByte === 0xd4) {
					// fixext 1
					object = this.decodeExtension(1, 0);
				} else if (headByte === 0xd5) {
					// fixext 2
					object = this.decodeExtension(2, 0);
				} else if (headByte === 0xd6) {
					// fixext 4
					object = this.decodeExtension(4, 0);
				} else if (headByte === 0xd7) {
					// fixext 8
					object = this.decodeExtension(8, 0);
				} else if (headByte === 0xd8) {
					// fixext 16
					object = this.decodeExtension(16, 0);
				} else if (headByte === 0xc7) {
					// ext 8
					const size = this.lookU8();
					object = this.decodeExtension(size, 1);
				} else if (headByte === 0xc8) {
					// ext 16
					const size = this.lookU16();
					object = this.decodeExtension(size, 2);
				} else if (headByte === 0xc9) {
					// ext 32
					const size = this.lookU32();
					object = this.decodeExtension(size, 4);
				} else {
					throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
				}
				this.complete();
				const stack = this.stack;
				while (stack.length > 0) {
					// arrays and maps
					const state = stack.top()!;
					if (state.type === STATE_ARRAY) {
						state.array[state.position] = object;
						state.position++;
						if (state.position === state.size) {
							object = state.array;
							stack.release(state);
						} else {
							continue DECODE;
						}
					} else if (state.type === STATE_MAP_KEY) {
						if (!isValidMapKeyType(object)) {
							throw new DecodeError("The type of key must be string or number but " + typeof object);
						}
						if (object === "__proto__") {
							throw new DecodeError("The key __proto__ is not allowed");
						}
						state.key = object;
						state.type = STATE_MAP_VALUE;
						continue DECODE;
					} else {
						// it must be `state.type === State.MAP_VALUE` here
						state.map[state.key!] = object;
						state.readCount++;
						if (state.readCount === state.size) {
							object = state.map;
							stack.release(state);
						} else {
							state.key = null;
							state.type = STATE_MAP_KEY;
							continue DECODE;
						}
					}
				}
				return object;
			}
		}
		private readHeadByte(): number {
			if (this.headByte === HEAD_BYTE_REQUIRED) {
				this.headByte = this.readU8();
				// console.log("headByte", prettyByte(this.headByte));
			}
			return this.headByte;
		}
		private complete(): void {
			this.headByte = HEAD_BYTE_REQUIRED;
		}
		private readArraySize(): number {
			const headByte = this.readHeadByte();
			switch (headByte) {
				case 0xdc:
					return this.readU16();
				case 0xdd:
					return this.readU32();
				default: {
					if (headByte < 0xa0) {
						return headByte - 0x90;
					} else {
						throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
					}
				}
			}
		}
		private pushMapState(size: number) {
			if (size > this.maxMapLength) {
				throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);
			}
			this.stack.pushMapState(size);
		}
		private pushArrayState(size: number) {
			if (size > this.maxArrayLength) {
				throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);
			}
			this.stack.pushArrayState(size);
		}
		private decodeUtf8String(byteLength: number, headerOffset: number): string {
			if (byteLength > this.maxStrLength) {
				throw new DecodeError(
					`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,
				);
			}
			if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
				throw MORE_DATA;
			}
			const offset = this.pos + headerOffset;
			let object: string;
			if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {
				object = this.keyDecoder.decode(this.bytes, offset, byteLength);
			} else {
				object = utf8Decode(this.bytes, offset, byteLength);
			}
			this.pos += headerOffset + byteLength;
			return object;
		}
		private stateIsMapKey(): boolean {
			if (this.stack.length > 0) {
				const state = this.stack.top()!;
				return state.type === STATE_MAP_KEY;
			}
			return false;
		}
		private decodeBinary(byteLength: number, headOffset: number): Uint8Array {
			if (byteLength > this.maxBinLength) {
				throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);
			}
			if (!this.hasRemaining(byteLength + headOffset)) {
				throw MORE_DATA;
			}
			const offset = this.pos + headOffset;
			const object = this.bytes.subarray(offset, offset + byteLength);
			this.pos += headOffset + byteLength;
			return object;
		}
		private decodeExtension(size: number, headOffset: number): unknown {
			if (size > this.maxExtLength) {
				throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);
			}
			const extType = this.view.getInt8(this.pos + headOffset);
			const data = this.decodeBinary(size, headOffset + 1 /* extType */);
			return {data, extType};
		}
		private lookU8() {
			return this.view.getUint8(this.pos);
		}
		private lookU16() {
			return this.view.getUint16(this.pos);
		}
		private lookU32() {
			return this.view.getUint32(this.pos);
		}
		private readU8(): number {
			const value = this.view.getUint8(this.pos);
			this.pos++;
			return value;
		}
		private readI8(): number {
			const value = this.view.getInt8(this.pos);
			this.pos++;
			return value;
		}
		private readU16(): number {
			const value = this.view.getUint16(this.pos);
			this.pos += 2;
			return value;
		}
		private readI16(): number {
			const value = this.view.getInt16(this.pos);
			this.pos += 2;
			return value;
		}
		private readU32(): number {
			const value = this.view.getUint32(this.pos);
			this.pos += 4;
			return value;
		}
		private readI32(): number {
			const value = this.view.getInt32(this.pos);
			this.pos += 4;
			return value;
		}
		private readU64(): number {
			const value = getUint64(this.view, this.pos);
			this.pos += 8;
			return value;
		}
		private readI64(): number {
			const value = getInt64(this.view, this.pos);
			this.pos += 8;
			return value;
		}
		private readU64AsBigInt(): bigint {
			const value = this.view.getBigUint64(this.pos);
			this.pos += 8;
			return value;
		}
		private readI64AsBigInt(): bigint {
			const value = this.view.getBigInt64(this.pos);
			this.pos += 8;
			return value;
		}
		private readF32() {
			const value = this.view.getFloat32(this.pos);
			this.pos += 4;
			return value;
		}
		private readF64() {
			const value = this.view.getFloat64(this.pos);
			this.pos += 8;
			return value;
		}
	}
	export class MessagePackGameDataReader implements GameDataReader {
		private buffer?: BufferSource | ArrayLike<number>;
		private decoder?: Decoder;
		constructor(buffer: BufferSource | ArrayLike<number>) {
			check(buffer, 'buffer').is.not.nullOrUndefined();
			const options: DecoderOptions = {
				useBigInt64: true,
			};
			this.buffer = buffer;
			this.decoder = new Decoder(options);
		}
		readObject(): object {
			if (!this.decoder || !this.buffer) {
				throw new Error("Reader is closed and can't read more objects.");
			}
			const parsedData = this.decoder.decode(this.buffer);
			if (typeof parsedData !== 'object' || parsedData === null) {
				throw new Error(`Invalid MessagePack data. An object is expected while '${parsedData}' has been read.`)
			}
			return parsedData;
		}
		close(): void {
			this.buffer = undefined;
			this.decoder = undefined;
		}
	}

<#+ 
	}
#>
