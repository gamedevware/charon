<#+ 

	public sealed partial class CodeGenerationContext
	{
		private readonly Dictionary<string, NativeTypeReference> nativeTypes;

		public string ToolsName { get; set; }
		public string ToolsVersion { get; set; }

		public bool EagerReferenceResolution { get; set; }
		public bool RawReferences { get; set; }
		public bool RawLocalizedTexts { get; set; }
		public bool DisablePatching { get; set; }
		public bool DisableStringPooling { get; set; }
		public bool DisableJsonSerialization { get; set; }
		public bool DisableMessagePackSerialization { get; set; }
		public bool DisableDocumentIdEnums { get; set; }

		public Metadata Metadata { get; }
		public StatisticsVisitor Statistics { get; }
		public GenerationTargetLanguage TargetLanguage { get; }
		public CodeObjectModel ObjectModel { get; }

		public CodeGenerationContext(string gameDataPath, GenerationTargetLanguage targetLanguage, string[] optimizations)
		{
			if (gameDataPath == null) throw new ArgumentNullException(nameof(gameDataPath));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (optimizations == null) throw new ArgumentNullException(nameof(optimizations));

			this.ToolsVersion = string.Empty;
			this.ToolsName = string.Empty;

			this.EagerReferenceResolution = optimizations.Contains("EagerReferenceResolution", StringComparer.OrdinalIgnoreCase);
			this.RawReferences = optimizations.Contains("RawReferences", StringComparer.OrdinalIgnoreCase);
			this.RawLocalizedTexts = optimizations.Contains("RawLocalizedTexts", StringComparer.OrdinalIgnoreCase);
			this.DisablePatching = optimizations.Contains("DisablePatching", StringComparer.OrdinalIgnoreCase);
			this.DisableStringPooling = optimizations.Contains("DisableStringPooling", StringComparer.OrdinalIgnoreCase);
			this.DisableJsonSerialization = optimizations.Contains("DisableJsonSerialization", StringComparer.OrdinalIgnoreCase);
			this.DisableMessagePackSerialization = optimizations.Contains("DisableMessagePackSerialization", StringComparer.OrdinalIgnoreCase);
			this.DisableDocumentIdEnums = optimizations.Contains("DisableDocumentIdEnums", StringComparer.OrdinalIgnoreCase);

			var gameData = this.Load(gameDataPath);
			this.Metadata = new Metadata(gameData);
			this.Statistics = StatisticsVisitor.Visit(gameData, this.Metadata);
			this.TargetLanguage = targetLanguage;

			this.nativeTypes = this.TargetLanguage.GetNativeTypes();
			var types = this.FindTypes();
			var formulas = this.FindFormulas(types.Keys);
			var enums = this.FindEnums(types.Keys);

			this.TargetLanguage.FixClassNames();
			this.ObjectModel = new CodeObjectModel(types, formulas, enums, this.nativeTypes);
			this.ObjectModel.ResolveNameCollisions(this.TargetLanguage);
		}

		private IReadOnlyDictionary<string, object> Load(string gameDataPath)
		{
			if (gameDataPath == null) throw new ArgumentNullException(nameof(gameDataPath));

			var encoding = Encoding.UTF8;
			var isGzipped = gameDataPath.EndsWith(".gz", StringComparison.OrdinalIgnoreCase);
			var extension = isGzipped ? Path.GetExtension(gameDataPath.Substring(0, gameDataPath.Length - 3)) : Path.GetExtension(gameDataPath);

			using (var gameDataFile = new FileStream(gameDataPath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, FileOptions.SequentialScan))
			using (var unGzipStream = isGzipped ? (Stream)new GZipStream(gameDataFile, CompressionMode.Decompress, leaveOpen: true) : gameDataFile)
			{
				switch (extension.Trim('.'))
				{
					case "gdjs":
					case "json":
						return this.ReadGameDataJson(unGzipStream, encoding, false);
					case "gdmp":
					case "msgpack":
					case "msgpck":
						return this.ReadGameDataMessagePack(unGzipStream, encoding, false);
					default:
						throw new InvalidOperationException($"Unknown file extension '{extension}'. Unable to determine file format by extension.");
				}
			}
		}

		private IReadOnlyDictionary<string, object> ReadGameDataMessagePack(Stream gameDataStream, Encoding _, bool leaveOpen)
		{
			using (var messagePackReader = new MessagePackGameDataReader(gameDataStream, leaveOpen))
			{
				messagePackReader.NextToken();

				return (IReadOnlyDictionary<string, object>)messagePackReader.ReadAny(nextToken: false);
			}
		}
		private IReadOnlyDictionary<string, object> ReadGameDataJson(Stream gameDataStream, Encoding encoding, bool leaveOpen)
		{
			using (var jsonReader = new JsonGameDataReader(gameDataStream, leaveOpen))
			{
				jsonReader.NextToken();

				return (IReadOnlyDictionary<string, object>)jsonReader.ReadAny(nextToken: false);
			}
		}

		private Dictionary<string, FormulaDefinition> FindFormulas(ICollection<string> schemaIds)
		{
			var formulas = new Dictionary<string, FormulaDefinition>();
			foreach (var schema in this.Metadata.GetSchemas())
			{
				foreach (var schemaProperty in schema.Properties)
				{
					if (!schemaIds.Contains(schema.Id))
					{
						continue;
					}

					if (schemaProperty.DataType != DataType.Formula)
					{
						continue;
					}

					if (schemaProperty.IsRawFormulaType)
					{
						continue;
					}

					var definition = new FormulaDefinition(schemaProperty, this.TargetLanguage, this.LazyResolve);
					formulas.Add(schemaProperty.Id, definition);
				}
			}

			return formulas;
		}
		private Dictionary<string, EnumDefinition> FindEnums(ICollection<string> schemaIds)
		{
			var mergeEnums = new Dictionary<string, EnumDefinition>();
			var enums = new Dictionary<string, EnumDefinition>();

			foreach (var schema in this.Metadata.GetSchemas())
			{
				if (!schemaIds.Contains(schema.Id))
				{
					continue;
				}

				foreach (var schemaProperty in schema.Properties)
				{
					if (schemaProperty.DataType != DataType.PickList && schemaProperty.DataType != DataType.MultiPickList)
					{
						continue;
					}

					var enumDef = new EnumDefinition(schemaProperty, this.TargetLanguage, this.LazyResolve);
					if (enumDef.MergeName != null &&
						mergeEnums.TryGetValue(enumDef.MergeName, out var otherDefinition))
					{
						otherDefinition.MergeWith(enumDef, this.LazyResolve);
						enums.Add(schemaProperty.Id, otherDefinition);
					}
					else
					{
						if (enumDef.MergeName != null)
						{
							mergeEnums[enumDef.MergeName] =  enumDef;
						}

						enums.Add(schemaProperty.Id, enumDef);
					}
				}
			}

			if (!this.DisableDocumentIdEnums)
			{
				foreach (var documentsBySchema in this.Statistics.DocumentUniqueValues.GroupBy(documents => documents.Schema))
				{
					if (documentsBySchema.Key.Type == SchemaType.Settings || documentsBySchema.Key.Type == SchemaType.Union)
					{
						continue; // don't generate document id enum for settings and unions
					}

					foreach (var documentsByProperty in documentsBySchema.GroupBy(documents => documents.UniqueProperty))
					{
						var schemaProperty = documentsByProperty.Key;
						if (enums.ContainsKey(schemaProperty.Id))
						{
							continue; // already has enum attached to this schema property, probably id is PickList
						}

						var values = documentsByProperty.Select(documents => new KeyValuePair<string, object>(documents.UniqueValueName, documents.UniqueValue)).ToList();
						// make document ids order stable
						values.Sort((x, y) => StringComparer.Ordinal.Compare(x.Key, y.Key));

						var enumDef = new EnumDefinition(schemaProperty, values, this.TargetLanguage, this.LazyResolve);
						if (enumDef.MergeName != null)
						{
							var counter = 1;
							var baseName = enumDef.MergeName;
							while (mergeEnums.ContainsKey(enumDef.MergeName))
							{
								counter++;
								enumDef.MergeName = baseName + counter;
							}
							mergeEnums[enumDef.MergeName] =  enumDef;
						}
						enums.Add(schemaProperty.Id, enumDef);
					}
				}
			}

			return enums;
		}
		private Dictionary<string, TypeDefinition> FindTypes()
		{
			// determine all non-skipped schemas
			var referencedSchemaIds = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			foreach (var schema in this.Metadata.GetSchemas())
			{
				var isSkipped = schema.Name == GenerationConstants.KNOWN_SCHEMA_SCHEMA ||
					schema.Name == GenerationConstants.KNOWN_SCHEMA_SCHEMA_PROPERTY;
				if (isSkipped)
				{
					continue;
				}

				referencedSchemaIds.Add(schema.Id);

				foreach (var schemaProperty in schema.Properties)
				{
					if (schemaProperty.ReferenceType == null)
					{
						continue;
					}

					referencedSchemaIds.Add(schemaProperty.ReferenceType.Id);
				}
			}

			var typeGenerationFlags = (this.RawLocalizedTexts ? TypeGenerationFlags.RawLocalizedTexts : 0) |
				(this.RawReferences ? TypeGenerationFlags.RawReferences : 0);
			var types = new Dictionary<string, TypeDefinition>();
			foreach (var schema in this.Metadata.GetSchemas())
			{
				if (!referencedSchemaIds.Contains(schema.Id))
				{
					continue;
				}

				var definition = new TypeDefinition(schema, this.TargetLanguage, typeGenerationFlags, this.LazyResolve);
				types.Add(definition.TypeName, definition);
				types.Add(schema.Id, definition);
			}

			return types;
		}

		private ITypeReference LazyResolve(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.ObjectModel != null)
			{
				return this.ObjectModel.ResolveType(typeName);
			}
			else if (this.nativeTypes.TryGetValue(typeName, out var nativeTypeRef))
			{
				return nativeTypeRef;
			}

			return new LazyTypeReference(typeName, this.ResolveInObjectModel);
		}
		private ITypeReference ResolveInObjectModel(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.ObjectModel == null)
			{
				throw new InvalidOperationException($"Unable to resolve type '{typeName}' while object model is still building.");
			}

			return this.ObjectModel.ResolveType(typeName);
		}
	}


	public class CodeObjectModel
	{
		private readonly Dictionary<string, TypeDefinition> typeById;
		private readonly Dictionary<string, EnumDefinition> enumById;
		private readonly Dictionary<string, FormulaDefinition> formulaById;
		private readonly Dictionary<string, NativeTypeReference> nativeTypes;
		private readonly Dictionary<string, ExternalTypeReference> externalTypes;

		public IEnumerable<EnumDefinition> Enums => this.enumById.Values.Distinct();
		public IEnumerable<TypeDefinition> Types => this.typeById.Values.Distinct();
		public IEnumerable<FormulaDefinition> Formulas => this.formulaById.Values.Distinct();

		public CodeObjectModel
		(
			Dictionary<string, TypeDefinition> types,
			Dictionary<string, FormulaDefinition> formulas,
			Dictionary<string, EnumDefinition> enums,
			Dictionary<string, NativeTypeReference> nativeTypes)
		{
			if (types == null) throw new ArgumentNullException(nameof(types));
			if (formulas == null) throw new ArgumentNullException(nameof(formulas));
			if (enums == null) throw new ArgumentNullException(nameof(enums));

			this.typeById = types;
			this.enumById = enums;
			this.formulaById = formulas;
			this.nativeTypes = nativeTypes;
			this.externalTypes = new Dictionary<string, ExternalTypeReference>();
		}

		public ITypeReference ResolveType(string typeName)
		{
			if (string.IsNullOrEmpty(typeName)) throw new ArgumentException("Type name can't be null or empty string.", nameof(typeName));

			if (this.typeById.TryGetValue(typeName, out var typeDefinition))
			{
				return typeDefinition;
			}
			else if (this.enumById.TryGetValue(typeName, out var enumDefinition))
			{
				return enumDefinition;
			}
			else if (this.formulaById.TryGetValue(typeName, out var formulaDefinition))
			{
				return formulaDefinition;
			}
			else if (this.nativeTypes.TryGetValue(typeName, out var nativeType))
			{
				return nativeType;
			}
			else if (this.externalTypes.TryGetValue(typeName, out var externalType))
			{
				return externalType;
			}
			else
			{
				externalType = new ExternalTypeReference(typeName);
				this.externalTypes.Add(externalType.TypeName, externalType);
				return externalType;
			}
		}

		public IReadOnlyList<ITypeReference> GetAllDefinedTypes()
		{
			var result = new List<ITypeReference>(this.enumById.Count + this.typeById.Count + this.formulaById.Count);
			result.AddRange(this.Enums);
			result.AddRange(this.Types);
			result.AddRange(this.Formulas);
			return result;
		}

		public void ResolveNameCollisions(GenerationTargetLanguage targetLanguage)
		{
			var takenNames = new HashSet<string>(new[] {
				targetLanguage.DocumentClassName, targetLanguage.GameDataClassName, targetLanguage.LocalizedTextClassName,
				targetLanguage.DocumentReferenceClassName,
				targetLanguage.ReadOnlyListClassName, targetLanguage.ReadOnlyDictionaryClassName
			}, StringComparer.Ordinal);

			// check name collisions in types
			foreach (var typeDef in this.Types)
			{
				var typeName = typeDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = typeDef.TypeName + counter;
				}

				typeDef.TypeName = typeName;
				takenNames.Add(typeName);
			}

			// check name collisions in enums
			foreach (var enumDef in this.Enums)
			{
				var typeName = enumDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = enumDef.TypeName + counter;
				}

				enumDef.TypeName = typeName;
				takenNames.Add(typeName);
			}

			// check name collisions in formulas
			foreach (var formulaDef in this.Formulas)
			{
				var typeName = formulaDef.TypeName;
				var counter = 0;
				while (takenNames.Contains(typeName))
				{
					counter++;
					typeName = formulaDef.TypeName + counter;
				}

				formulaDef.TypeName = typeName;
				takenNames.Add(typeName);
			};
		}
	}


	public class CppLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor", "bool",
			"break", "case", "catch", "char", "char8_t", "char16_t", "char32_t", "class",
			"compl", "concept", "const", "const_cast", "consteval", "constexpr", "constinit",
			"continue", "co_await", "co_return", "co_yield", "decltype", "default", "delete",
			"do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
			"false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
			"namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or",
			"or_eq", "private", "protected", "public", "register", "reinterpret_cast", "requires",
			"return", "short", "signed", "sizeof", "static", "static_assert", "static_cast",
			"struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
			"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void",
			"volatile", "wchar_t", "while", "xor", "xor_eq"
		});

		public string SharedPtrTypeName = "std::shared_ptr";
		public string UniquePtrTypeName = "std::unique_ptr";
		public string OptionalTypeName = "std::optional";
		public string FunctionTypeName = "std::function";

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.Cpp;

		public CppLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "std::vector";
			this.DocumentCollectionClassName = "std::unordered_map";
			this.ReadOnlyListClassName = "std::vector";
			this.ReadOnlyDictionaryClassName = "std::unordered_map";
			this.NullableClassName = this.OptionalTypeName;
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join("::", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateCppIdentifier));
			this.GameDataClassName = ValidateCppIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateCppIdentifier(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedTextClassName = ValidateCppIdentifier(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateCppIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateCppIdentifier(this.DocumentCollectionClassName ?? "std::unordered_map");
			this.DocumentReferenceCollectionClassName = ValidateCppIdentifier(this.DocumentReferenceCollectionClassName ?? "std::vector");
			this.ReadOnlyListClassName = ValidateCppIdentifier(this.ReadOnlyListClassName ?? "std::vector");
			this.ReadOnlyDictionaryClassName = ValidateCppIdentifier(this.ReadOnlyDictionaryClassName ?? "std::unordered_map");
			this.NullableClassName = ValidateCppIdentifier(this.NullableClassName ?? this.OptionalTypeName);
		}

		public ITypeReference MakePtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("", elementType, "*");
		}
		public ITypeReference MakeConstType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("const ", elementType, "");
		}
		public ITypeReference MakeConstRefType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("const ", elementType, "&");
		}
		public ITypeReference MakeRefType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("", elementType, "&");
		}
		public ITypeReference MakeSharedPtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(SharedPtrTypeName, elementType);
		}
		public ITypeReference MakeUniquePtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(UniquePtrTypeName, elementType);
		}
		public ITypeReference MakeOptionalType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(OptionalTypeName, elementType);
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, this.MakeDocumentReferenceTypeRef(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, this.MakeSharedPtrType(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return valueType; // do not wrap twice into optional
			}
			return new GenericTypeReference(this.NullableClassName, valueType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return genericTypeReference.GenericArguments[0];
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return new NativeTypeReference("std::any");
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateCppIdentifier("m_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateCppIdentifier(MakePascalCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			if (formulaName == null) throw new ArgumentNullException(nameof(formulaName));

			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateCppIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}

		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "std::string" },
				{ typeof(char), "char" },
				{ typeof(bool), "bool" },
				{ typeof(void), "void" },
				{ typeof(byte), "uint8_t" },
				{ typeof(sbyte), "int8_t" },
				{ typeof(short), "int16_t" },
				{ typeof(ushort), "uint16_t" },
				{ typeof(int), "int32_t" },
				{ typeof(uint), "uint32_t" },
				{ typeof(long), "int64_t" },
				{ typeof(ulong), "uint64_t" },
				{ typeof(float), "float" },
				{ typeof(double), "double" },
				{ typeof(decimal), "double" },
				{ typeof(TimeSpan), "std::chrono::duration<int64_t, std::nano>" },
				{ typeof(DateTime), "std::chrono::system_clock::time_point" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateCppIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class CSharpLanguage : GenerationTargetLanguage
	{
		private static readonly IReadOnlyDictionary<Type, string> AliasByType = new Dictionary<Type, string> {
			{ typeof(string), "string" },
			{ typeof(char), "char" },
			{ typeof(bool), "bool" },
			{ typeof(void), "void" },
			{ typeof(object), "object" },
			{ typeof(byte), "byte" },
			{ typeof(sbyte), "sbyte" },
			{ typeof(short), "short" },
			{ typeof(ushort), "ushort" },
			{ typeof(int), "int" },
			{ typeof(uint), "uint" },
			{ typeof(long), "long" },
			{ typeof(ulong), "ulong" },
			{ typeof(float), "float" },
			{ typeof(double), "double" },
			{ typeof(decimal), "decimal" },
		};
		private static readonly IReadOnlyDictionary<string, Type> TypeByAlias = AliasByType.ToDictionary(kv => kv.Value, kv => kv.Key);

		private static readonly HashSet<string> NativeValueTypes = new HashSet<string>(new[] {
			typeof(char), typeof(bool), typeof(byte), typeof(sbyte), typeof(short), typeof(ushort),
			typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double),
			typeof(decimal), typeof(TimeSpan), typeof(DateTime) }.Select(type => type.FullName));
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"abstract", "as", "base", "bool", "break",
			"byte", "case", "catch", "char", "checked",
			"class", "const", "continue", "decimal", "default",
			"delegate", "do", "double", "else", "enum",
			"event", "explicit", "extern", "false", "finally",
			"fixed", "float", "for", "foreach", "goto",
			"if", "implicit", "in", "int", "interface",
			"internal", "is", "lock", "long", "namespace",
			"new", "null", "object", "operator", "out",
			"override", "params", "private", "protected", "public",
			"readonly", "ref", "return", "sbyte", "sealed",
			"short", "sizeof", "stackalloc", "static", "string",
			"struct", "switch", "this", "throw", "true",
			"try", "typeof", "uint", "ulong", "unchecked",
			"unsafe", "ushort", "using", "virtual", "void",
			"volatile", "while", "add", "alias", "ascending", "async", "await",
			"by", "descending", "dynamic", "equals", "from",
			"get", "global", "group", "into", "join",
			"let", "on", "orderby", "partial", "remove",
			"select", "set", "value", "var", "where", "field", "property"
		});

		/// <inheritdoc />
		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.CSharp;
		public string RawJsonClassName { get; }

		public CSharpLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "Document";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "DocumentReferenceCollection";
			this.DocumentCollectionClassName = "DocumentCollection";
			this.ReadOnlyListClassName = "ReadOnlyCollection";
			this.ReadOnlyDictionaryClassName = "ReadOnlyDictionary";
			this.RawJsonClassName = "IReadOnlyDictionary";
			this.NullableClassName = "Nullable";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateCSharpIdentifier));
			this.GameDataClassName = ValidateCSharpIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateCSharpIdentifier(this.DocumentClassName ?? "Document");
			this.LocalizedTextClassName = ValidateCSharpIdentifier(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateCSharpIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateCSharpIdentifier(this.DocumentCollectionClassName ?? "DocumentCollection");
			this.DocumentReferenceCollectionClassName = ValidateCSharpIdentifier(this.DocumentReferenceCollectionClassName ?? "DocumentReferenceCollection");
			this.ReadOnlyListClassName = ValidateCSharpIdentifier(this.ReadOnlyListClassName ?? "ReadOnlyCollection");
			this.ReadOnlyDictionaryClassName = ValidateCSharpIdentifier(this.ReadOnlyDictionaryClassName ?? "ReadOnlyDictionary");
			this.NullableClassName = ValidateCSharpIdentifier(this.NullableClassName?? "Nullable");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<para />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is NativeTypeReference nativeTypeReference && NativeValueTypes.Contains(nativeTypeReference.TypeName))
			{
				return new GenericTypeReference(this.NullableClassName, valueType);
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return genericTypeReference.GenericArguments[0];
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return new GenericTypeReference(this.RawJsonClassName, new NativeTypeReference("string"), new NativeTypeReference("object"));
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateCSharpIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateCSharpIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateCSharpIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}

		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new[] {
				typeof(string), typeof(char), typeof(bool), typeof(void), typeof(object), typeof(byte), typeof(sbyte), typeof(short), typeof(ushort),
				typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(decimal), typeof(TimeSpan), typeof(DateTime)
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var type in types)
			{
				var nativeType = new NativeTypeReference(type.FullName);
				nativeTypes.Add(type.Name, nativeType);
				if (!string.IsNullOrEmpty(type.FullName))
				{
					nativeTypes.Add(type.FullName, nativeType);
				}
				if (TryGetAliasFor(type, out var alias))
				{
					nativeTypes.Add(alias, nativeType);
				}
			}

			return nativeTypes;
		}

		private static bool TryGetAliasFor(Type type, out string alias)
		{
			return AliasByType.TryGetValue(type, out alias);
		}
		private static string ValidateCSharpIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "@" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class DerivedTypeReference : ITypeReference
	{
		private readonly string prefix;
		private readonly string suffix;
		private readonly ITypeReference baseType;

		public string TypeName { get { return this.prefix + this.baseType.TypeName + this.suffix;  } }

		public DerivedTypeReference(string prefix, ITypeReference baseType, string suffix)
		{
			this.prefix = prefix ?? String.Empty;
			this.suffix = suffix ?? String.Empty;
			this.baseType = baseType;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public enum EnumBaseTypeCode
	{
		Int32,
		Int64,
		Float32,
		Float64,
		String,
		TimeSpan,
		Bool,
		DateTime
	}


	public class EnumDefinition : ITypeReference
	{
		public string MergeName { get; set; }
		public string TypeName { get; set; }
		public string Description { get; set; }
		public string DefaultValueName { get; set; }
		public ITypeReference BaseType { get; set; }
		public EnumBaseTypeCode BaseTypeCode { get; set; }
		public bool IsFlags { get; set; }
		public bool IsPickList { get; set; }
		public bool IsInt64 => this.BaseTypeCode == EnumBaseTypeCode.Int64;
		public IReadOnlyList<KeyValuePair<string, object>> Values { get; set; }
		public HashSet<SchemaProperty> SchemaProperties { get; }

		public EnumDefinition(SchemaProperty schemaProperty, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (schemaProperty.DataType != DataType.PickList && schemaProperty.DataType != DataType.MultiPickList) throw new ArgumentException("Pick list type is expected.", nameof(schemaProperty));

			this.SchemaProperties = new HashSet<SchemaProperty>();
			this.SchemaProperties.Add(schemaProperty);

			var specification = schemaProperty.GetSpecification();

			if (!string.IsNullOrEmpty(specification.CustomTypeName))
			{
				this.TypeName = this.MergeName = specification.CustomTypeName;
			}
			else if(!string.IsNullOrEmpty(schemaProperty.SharedProperty?.SchemaProperty.Name))
			{
				this.TypeName = schemaProperty.SharedProperty?.SchemaProperty.Name;
			}
			else
			{
				this.TypeName = schemaProperty.DeclaredSchema.Name + "_" + schemaProperty.Name;
			}
			this.TypeName = targetLanguage.MakeEnumName(this.TypeName);

			this.IsPickList = true;
			this.IsFlags = schemaProperty.DataType == DataType.MultiPickList;
			this.BaseTypeCode = schemaProperty.Size > 4 ? EnumBaseTypeCode.Int64 : EnumBaseTypeCode.Int32;
			this.BaseType = typeResolver((schemaProperty.Size > 4 ? typeof(long) : typeof(int)).Name);

			var uniqueNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			var values = new List<KeyValuePair<string, object>>();
			var hasDefault = false;
			foreach (var kv in specification.GetPickListValues())
			{
				hasDefault = hasDefault | kv.Value == "0";
				this.DefaultValueName = kv.Key;
			}
			foreach (var kv in specification.GetPickListValues())
			{
				var literalName = targetLanguage.MakeEnumLiteralName(kv.Key);
				var counter = 1;
				while (!uniqueNames.Add(literalName))
				{
					literalName = targetLanguage.MakeEnumLiteralName(kv.Key + counter);
					counter++;
				}
				try
				{
					var literalValue = Convert.ToInt64(kv.Value, CultureInfo.InvariantCulture);
					values.Add(new KeyValuePair<string, object>(literalName, literalValue));
				}
				catch (FormatException fe)
				{
					throw new InvalidOperationException(string.Format("Failed to parse '{1}.{2}' pick list value '{0}' as integer.",
						kv.Value, schemaProperty.DeclaredSchema.Name, schemaProperty.Name), fe);
				}
			}

			if (!hasDefault)
			{
				values.Insert(0, new KeyValuePair<string, object>(targetLanguage.MakeEnumLiteralName("None"),  0L));
				this.DefaultValueName = "None";
			}

			values.Sort(OrderByValue);
			this.Values = values;

			this.UpdateDescription();
		}
		public EnumDefinition(SchemaProperty schemaProperty, IReadOnlyList<KeyValuePair<string, object>> values, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			switch (schemaProperty.DataType)
			{
				case DataType.Date:
					this.BaseTypeCode = EnumBaseTypeCode.DateTime;
					this.BaseType = typeResolver(nameof(DateTime));
					break;
				case DataType.Text:
					this.BaseTypeCode = EnumBaseTypeCode.String;
					this.BaseType = typeResolver(nameof(String));
					break;
				case DataType.Integer:
				case DataType.MultiPickList:
				case DataType.PickList:
					this.BaseTypeCode = schemaProperty.Size > 4 ? EnumBaseTypeCode.Int64 : EnumBaseTypeCode.Int32;
					this.BaseType = typeResolver(schemaProperty.Size > 4 ? nameof(Int64) : nameof(Int32));
					break;
				case DataType.Number:
					this.BaseTypeCode = schemaProperty.Size > 4 ? EnumBaseTypeCode.Float64 : EnumBaseTypeCode.Float32;
					this.BaseType = typeResolver(schemaProperty.Size > 4 ? nameof(Double) : nameof(Single));
					break;
				case DataType.Time:
					this.BaseTypeCode = EnumBaseTypeCode.TimeSpan;
					this.BaseType = typeResolver(nameof(TimeSpan));
					break;
				case DataType.Logical:
					this.BaseTypeCode = EnumBaseTypeCode.Bool;
					this.BaseType = typeResolver(nameof(Boolean));
					break;
				case DataType.LocalizedText:
				case DataType.Document:
				case DataType.DocumentCollection:
				case DataType.Reference:
				case DataType.ReferenceCollection:
				case DataType.Formula:
				default: throw new ArgumentException($"Unexpected base type for enum '{schemaProperty.DataType}'.");
			}

			this.SchemaProperties = new HashSet<SchemaProperty> { schemaProperty };

			var uniqueNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			var newValues = new List<KeyValuePair<string, object>>();
			foreach (var kv in values)
			{
				var literalName = targetLanguage.MakeEnumLiteralName(kv.Key);
				var counter = 1;
				while (!uniqueNames.Add(literalName))
				{
					literalName = targetLanguage.MakeEnumLiteralName(kv.Key + counter);
					counter++;
				}
				var literalValue = kv.Value;
				newValues.Add(new KeyValuePair<string, object>(literalName, literalValue));
			}
			newValues.Sort(OrderByValue);

			this.TypeName = schemaProperty.DeclaredSchema.Name + "_" + schemaProperty.Name;
			this.TypeName = targetLanguage.MakeEnumName(this.TypeName);
			this.Values = newValues;
			this.DefaultValueName = values.FirstOrDefault().Key;

			this.UpdateDescription();
		}

		public bool ContainsKey(string key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			foreach (var kv in this.Values)
			{
				if (string.Equals(kv.Key, key, StringComparison.Ordinal))
				{
					return true;
				}
			}
			return false;
		}

		public void MergeWith(EnumDefinition otherDefinition, Func<string, ITypeReference> typeResolver)
		{
			if (otherDefinition == null) throw new ArgumentNullException(nameof(otherDefinition));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			foreach (var schemaProperty in otherDefinition.SchemaProperties)
			{
				this.SchemaProperties.Add(schemaProperty);
			}

			var newValues = new List<KeyValuePair<string, object>>(this.Values);
			foreach (var kv in otherDefinition.Values)
			{
				if (!this.ContainsKey(kv.Key))
				{
					newValues.Add(kv);
				}
			}

			this.IsFlags = this.IsFlags || otherDefinition.IsFlags;

			if (!Equals(this.BaseType, otherDefinition.BaseType))
			{
				// determine new size and change base type accordingly
				var maxSize = this.SchemaProperties.Max(ea => ea.Size);
				if (maxSize > 4)
				{
					this.BaseTypeCode = EnumBaseTypeCode.Int64;
					this.BaseType = typeResolver(nameof(Int64));
				}

				// convert values to new type
				for (var index = 0; index < this.Values.Count; index++)
				{
					var key = this.Values[index].Key;
					var value = Convert.ToInt64(this.Values[index].Value, CultureInfo.InvariantCulture);
					newValues[index] = new KeyValuePair<string, object>(key, value);
				}
			}

			newValues.Sort(OrderByValue);
			this.Values = newValues;

			this.UpdateDescription();
		}

		private void UpdateDescription()
		{
			this.Description = $"Enumeration based on {this.BaseType}. " +
				(this.DefaultValueName != "None" ? $"Default Value: {this.DefaultValueName} - 0, " : "") +
				(this.IsFlags ? "Flags, " : "") +
				$"Used in Schemas: {string.Join(", ", this.SchemaProperties.Select(property => property.DeclaredSchema.Name).Distinct())}.";
		}

		private static  int OrderByValue(KeyValuePair<string, object> x, KeyValuePair<string, object> y)
		{
			if (x.Value is IComparable xComparable)
			{
				return xComparable.CompareTo(y.Value);
			}
			else if (y.Value is IComparable yComparable)
			{
				return yComparable.CompareTo(x.Value) * -1;
			}
			else
			{
				return (x.Value?.GetHashCode() ?? 0).CompareTo(y.Value?.GetHashCode() ?? 0);
			}
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class ExternalTypeReference : ITypeReference
	{
		public string TypeName { get; private set; }

		public ExternalTypeReference(string typeName)
		{
			this.TypeName = typeName;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class FormulaDefinition : ITypeReference
	{
		public string Name { get; set; }
		public string TypeName { get; set; }
		public string Description { get; set; }
		public string[] ParameterNames { get; set; }
		public string[] ParameterRawNames { get; set; }
		public ITypeReference[] ParameterTypes { get; set; }
		public ITypeReference ReturnType { get; set; }
		public ITypeReference[] KnownTypes { get; set; }
		public SpecificationDictionary Specification { get; }
		public SchemaProperty SchemaProperty { get; }

		public FormulaDefinition(SchemaProperty schemaProperty, GenerationTargetLanguage targetLanguage, Func<string, ITypeReference> typeResolver)
		{
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			this.SchemaProperty = schemaProperty;
			this.Specification = this.SchemaProperty.GetSpecification();
			this.Name = this.Specification.CustomTypeName;

			if (!string.IsNullOrEmpty(this.Specification.CustomTypeName))
			{
				this.TypeName = this.Specification.CustomTypeName;
			}
			else
			{
				this.TypeName = this.SchemaProperty.DeclaredSchema.Name + this.SchemaProperty.Name + GenerationConstants.FORMULA_SUFFIX;
			}

			this.TypeName = targetLanguage.MakeFormulaName(this.TypeName);

			this.ReturnType = typeResolver(this.Specification.GetFormulaResultType() ?? "void");
			this.KnownTypes = this.Specification.GetKnownTypes().Distinct().Select(typeResolver).ToArray();
			var parameters = this.Specification.GetFormulaParameters();
			this.ParameterNames = new string[parameters.Count];
			this.ParameterRawNames = new string[parameters.Count];
			this.ParameterTypes = new ITypeReference[parameters.Count];;

			for(var index = 0; index < parameters.Count; index++)
			{
				this.ParameterNames[index] = targetLanguage.MakeMethodParameterName(parameters[index].Key);
				this.ParameterRawNames[index] = parameters[index].Key;
				this.ParameterTypes[index] = typeResolver(parameters[index].Value);
			}

			this.Description = $"Formula Signature: ({string.Join(", ", parameters.Select(parameter => parameter.Value + " " + parameter.Key))}) -> {(this.Specification.GetFormulaResultType() ?? "void")}";
		}

		public IReadOnlyList<ITypeReference> GetReferenceTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.ParameterTypes);
			result.AddRange(this.KnownTypes);
			result.Add(this.ReturnType);

			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native types
			result.RemoveAll(typeRef => !(typeRef is TypeDefinition) &&
				!(typeRef is EnumDefinition) &&
				!(typeRef is FormulaDefinition));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}
		public IReadOnlyList<ITypeReference> GetReferencedExternalTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.ParameterTypes);
			result.AddRange(this.KnownTypes);
			result.Add(this.ReturnType);

			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native types
			result.RemoveAll(typeRef => !(typeRef is ExternalTypeReference));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}


		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public abstract class GameDataVisitor
	{
		protected readonly Metadata metadata;

		protected GameDataVisitor(Metadata metadata)
		{
			if (metadata == null) throw new ArgumentNullException(nameof(metadata));

			this.metadata = metadata;
		}

		public void Visit(IReadOnlyDictionary<string, object> gameData)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));

			if (!gameData.ContainsKey("Collections"))
			{
				throw new InvalidOperationException("Invalid gamedata. Missing 'Collections'.");
			}

			var collections = (IReadOnlyDictionary<string, object>)gameData["Collections"];
			var documentStack = new Stack<IReadOnlyDictionary<string, object>>();
			var propertyStack = new Stack<SchemaProperty>();
			foreach (var schemaName in collections.Keys)
			{
				if (!this.metadata.TryGetSchema(schemaName, out var schema))
				{
					continue;
				}
				if (!collections.TryGetValue(schemaName, out var collectionObj))
				{
					continue;
				}
				if (!(collectionObj is IList<object> collection))
				{
					continue;
				}

				foreach (var document in collection.OfType<IReadOnlyDictionary<string, object>>())
				{
					if (document == null) continue;

					documentStack.Clear();
					propertyStack.Clear();

					this.VisitDocument(document, schema, documentStack, propertyStack);
				}
			}
		}

		protected virtual void VisitDocument(
			IReadOnlyDictionary<string, object> document,
			Schema documentSchema,
			Stack<IReadOnlyDictionary<string, object>> parentDocuments,
			Stack<SchemaProperty> path)
		{
			if (document == null) throw new ArgumentNullException(nameof(document));
			if (documentSchema == null) throw new ArgumentNullException(nameof(documentSchema));
			if (parentDocuments == null) throw new ArgumentNullException(nameof(parentDocuments));
			if (path == null) throw new ArgumentNullException(nameof(path));

			foreach (var schemaProperty in documentSchema.Properties)
			{
				if (schemaProperty.DataType != DataType.Document && schemaProperty.DataType != DataType.DocumentCollection)
					continue;

				if (!document.TryGetValue(schemaProperty.Name, out var value) || value == null)
					continue;

				var subSchema = this.metadata.GetSchema(schemaProperty.ReferenceType.Id);
				parentDocuments.Push(document);
				path.Push(schemaProperty);
				if (value is IList<object> list)
				{
					foreach (var subDocument in list)
					{
						this.VisitDocument((IReadOnlyDictionary<string, object>)subDocument, subSchema, parentDocuments, path);
					}
				}
				else if (value is IReadOnlyDictionary<string, object> objects)
				{
					this.VisitDocument(objects, subSchema, parentDocuments, path);
				}

				parentDocuments.Pop();
				path.Pop();
			}
		}
	}


	public class GenerationConstants
	{
		public const string FORMULA_SUFFIX = "Formula";
		public const string FORMULA_SCOPE_SUFFIX = "Scope";
		public const string KNOWN_SCHEMA_PROJECT_SETTINGS = "ProjectSettings";
		public const string KNOWN_SCHEMA_SCHEMA = "Schema";
		public const string KNOWN_SCHEMA_SCHEMA_PROPERTY = "SchemaProperty";
		public const string KNOWN_SCHEMA_PROPERTY_ID = "Id";
	}


	public abstract class GenerationTargetLanguage
	{
		public abstract TargetSourceCodeLanguage SourceCodeLanguage { get; }
		public string Namespace { get; set; }
		public string GameDataClassName { get; set; }
		public string DocumentClassName { get; set; }
		public string LocalizedTextClassName { get; set; }
		public string DocumentReferenceClassName { get; set; }
		public string DocumentReferenceCollectionClassName { get; set; }
		public string DocumentCollectionClassName { get; set; }
		public string ReadOnlyListClassName { get; set; }
		public string ReadOnlyDictionaryClassName { get; set; }
		public string NullableClassName { get; set; }

		protected static string MakePascalCaseIdentifier(string value)
		{
			if (string.IsNullOrEmpty(value)) throw new ArgumentException("Type name can't be null or empty string.", nameof(value));

			var sb = new StringBuilder(value);
			var nextToLower = true;
			var nextToUpper = false;
			for (var i = 0; i < sb.Length; i++)
			{
				if (sb[i] == '_')
				{
					sb.Remove(i, 1);
					i--;
					nextToUpper = !nextToLower;
					continue;
				}

				if (!char.IsLetterOrDigit(sb[i]))
				{
					sb[i] = '_';
				}
				else if (char.IsLetter(sb[i]) && nextToLower)
				{
					sb[i] = char.ToLowerInvariant(sb[i]);
					nextToLower = false;
				}
				else if (char.IsLetter(sb[i]) && nextToUpper)
				{
					sb[i] = char.ToUpperInvariant(sb[i]);
					nextToUpper = false;
				}
			}

			if (sb.Length == 0 || char.IsDigit(sb[0]))
			{
				sb.Insert(0, '_');
			}
			return sb.ToString();
		}
		protected static string MakeDromedaryCaseName(string value)
		{
			if (string.IsNullOrEmpty(value)) throw new ArgumentException("Type name can't be null or empty string.", nameof(value));

			var sb = new StringBuilder(value);
			var index = 0;
			var nextToUpper = true;
			while (index < sb.Length && !char.IsLetter(sb[index]))
			{
				if (!char.IsDigit(sb[index]))
				{
					sb[index] = '_';
				}
				index++;
			}

			for (; index < sb.Length; index++)
			{
				if (sb[index] == '_')
				{
					sb.Remove(index, 1);
					index--;
					nextToUpper = true;
					continue;
				}

				if (!char.IsLetterOrDigit(sb[index]))
				{
					sb[index] = '_';
				}
				else if (char.IsLetter(sb[index]) && nextToUpper)
				{
					sb[index] = char.ToUpperInvariant(sb[index]);
					nextToUpper = false;
				}
			}

			if (sb.Length == 0 || char.IsDigit(sb[0]))
			{
				sb.Insert(0, '_');
			}

			var name = sb.ToString();
			return name;
		}
		protected static string MakeSnakeCaseIdentifier(string identifier)
		{
			if (string.IsNullOrEmpty(identifier))
				return identifier;

			var result = new StringBuilder();
			for (var i = 0; i < identifier.Length; i++)
			{
				var c = identifier[i];
				if (char.IsUpper(c))
				{
					if (i > 0 && identifier[i - 1] != '_')
					{
						result.Append('_');
					}
					result.Append(char.ToLowerInvariant(c));
				}
				else
				{
					result.Append(c);
				}
			}
			return result.ToString();
		}

		public abstract Dictionary<string, NativeTypeReference> GetNativeTypes();

		public abstract ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType);
		public abstract ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType);
		public abstract ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType);
		public abstract ITypeReference MakeOptionalTypeRef(ITypeReference valueType);
		public abstract ITypeReference MakeRequiredTypeRef(ITypeReference valueType);
		public abstract ITypeReference MakeRawFormulaTypeRef();

		public abstract void FixClassNames();
		public abstract string PrepareDescription(string summary);
		public abstract string MakeTypeName(string typeName);
		public abstract string MakeEnumName(string enumName);
		public abstract string MakeFieldName(string fieldName);
		public abstract string MakePropertyName(string propertyName);
		public abstract string MakeFormulaName(string formulaName);
		public abstract string MakeMethodParameterName(string parameterName);
		public abstract string MakeEnumLiteralName(string enumLiteralName);

		public virtual string MakePlural(string name)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));

			return Pluralizer.Pluralize(name);
		}
		public virtual string MakeSingular(string name)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));

			return Pluralizer.Singularize(name);
		}
		public virtual string FormatEnumDisplayString(object enumValue)
		{
			var stringValue = new StringBuilder(enumValue?.ToString() ?? string.Empty);

			var prevWasLowercase = false;
			for (var i = 0; i < stringValue.Length; i++)
			{
				if (prevWasLowercase && char.IsUpper(stringValue[i]))
				{
					stringValue.Insert(i++, ' ');
					prevWasLowercase = false;
				}
				else
				{
					prevWasLowercase = !char.IsUpper(stringValue[i]);
				}
			}
			return stringValue.ToString();
		}
	}


	public sealed class GenericTypeReference : ITypeReference
	{
		public string TypeName
		{
			get
			{
				if (this.GenericArguments.Length > 0)
				{
					return this.Definition.TypeName + "<" + string.Join(",", Array.ConvertAll(this.GenericArguments, a => a.TypeName)) + ">";
				}
				else
				{
					return this.Definition.TypeName;
				}
			}
		}
		public ITypeReference Definition { get; private  set; }
		public ITypeReference[] GenericArguments { get; private  set; }

		public GenericTypeReference(string typeName, params ITypeReference[] genericArguments)
			:this(new NativeTypeReference(typeName), genericArguments)
		{

		}
		public GenericTypeReference(ITypeReference definition, params ITypeReference[] genericArguments)
		{
			this.Definition = definition;
			this.GenericArguments = genericArguments ?? new ITypeReference[0];
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class HaxeLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"abstract", "break", "case", "cast", "catch", "class", "continue", "default", "do",
			"dynamic", "else", "enum", "extends", "extern", "false", "final", "for", "function",
			"if", "implements", "import", "in", "inline", "interface", "macro", "new", "null",
			"operator", "overload", "override", "package", "private", "public", "return", "static",
			"switch", "this", "throw", "true", "try", "typedef", "untyped", "using", "var", "while",
		});
		private static readonly HashSet<string> KnownTypes = new HashSet<string>(new string[] {
			"Bool", "Int", "Int64", "String", "Bytes", "Float", "Map", "Array", "Any"
		});
		private static readonly NativeTypeReference AnyType = new NativeTypeReference("Any");

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.Haxe;

		public HaxeLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "DocumentReferenceCollection";
			this.DocumentCollectionClassName = "DocumentCollection";
			this.ReadOnlyListClassName = "ReadOnlyArray";
			this.ReadOnlyDictionaryClassName = "Map";
			this.NullableClassName = "Null";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateHaxeIdentifier));
			this.GameDataClassName = ValidateHaxeIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateHaxeIdentifier(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedTextClassName = ValidateHaxeIdentifier(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateHaxeIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateHaxeIdentifier(this.DocumentCollectionClassName ?? "DocumentCollection");
			this.DocumentReferenceCollectionClassName = ValidateHaxeIdentifier(this.DocumentReferenceCollectionClassName ?? "DocumentReferenceCollection");
			this.ReadOnlyListClassName = ValidateHaxeIdentifier(this.ReadOnlyListClassName ?? "ReadOnlyArray");
			this.ReadOnlyDictionaryClassName = ValidateHaxeIdentifier(this.ReadOnlyDictionaryClassName ?? "Map");
			this.NullableClassName = ValidateHaxeIdentifier(this.NullableClassName?? "Null");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return valueType; // do not wrap twice into nullable
			}
			return new GenericTypeReference(this.NullableClassName, valueType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return genericTypeReference.GenericArguments[0];
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return AnyType;
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateHaxeTypeName(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateHaxeIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateHaxeIdentifier(MakePascalCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateHaxeIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateHaxeIdentifier(MakePascalCaseIdentifier(enumLiteralName));
		}
		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "String" },
				{ typeof(char), "String" },
				{ typeof(bool), "Bool" },
				{ typeof(void), "Void" },
				{ typeof(object), "Any" },
				{ typeof(byte), "Int" },
				{ typeof(sbyte), "Int" },
				{ typeof(short), "Int" },
				{ typeof(ushort), "Int" },
				{ typeof(int), "Int" },
				{ typeof(uint), "Int64" },
				{ typeof(long), "Int64" },
				{ typeof(ulong), "Int64" },
				{ typeof(float), "Float" },
				{ typeof(double), "Float" },
				{ typeof(decimal), "Float" },
				{ typeof(TimeSpan), "TimeSpan" },
				{ typeof(DateTime), "Date" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateHaxeTypeName(string typeName)
		{
			typeName = ValidateHaxeIdentifier(typeName);
			if (KnownTypes.Contains(typeName))
			{
				return "_" + typeName;
			}
			else
			{
				return typeName;
			}
		}
		private static string ValidateHaxeIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public interface ITypeReference
	{
		string TypeName { get; }
	}


	[DebuggerDisplay("{typeName}")]
	public class LazyTypeReference : ITypeReference
	{
		private readonly  string typeName;
		private readonly TypeResolveFn resolveActualTypeFunc;

		public string TypeName => this.resolveActualTypeFunc(this.typeName).TypeName;

		public ITypeReference Resolve()
		{
			return this.resolveActualTypeFunc(this.typeName);
		}

		public LazyTypeReference(string typeName, TypeResolveFn resolveActualTypeFunc)
		{
			this.typeName = typeName;
			this.resolveActualTypeFunc = resolveActualTypeFunc;
		}

		public override bool Equals(object otherType)
		{
			if (otherType == null || !(otherType is LazyTypeReference))
			{
				return false;
			}
			return this.typeName.Equals(((LazyTypeReference)otherType).typeName, StringComparison.Ordinal);
		}
		public override int GetHashCode()
		{
			return this.typeName.GetHashCode();
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class LuaLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"and", "break", "do", "else", "elseif", "end", "false", "for", "function",
			"goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then",
			"true", "until", "while"
		});
		private static readonly HashSet<string> KnownTypes = new HashSet<string>(new string[] {
			"string", "number", "boolean", "table", "function", "userdata", "thread"
		});
		private static readonly NativeTypeReference AnyType = new NativeTypeReference("any");

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.Lua;

		public LuaLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "Array";
			this.DocumentCollectionClassName = "Map";
			this.ReadOnlyListClassName = "Array";
			this.ReadOnlyDictionaryClassName = "Map";
			this.NullableClassName = "Nullable";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateLuaIdentifier));
			this.GameDataClassName = ValidateLuaTypeName(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateLuaTypeName(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedTextClassName = ValidateLuaTypeName(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateLuaTypeName(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateLuaTypeName(this.DocumentCollectionClassName ?? "Map");
			this.DocumentReferenceCollectionClassName = ValidateLuaTypeName(this.DocumentReferenceCollectionClassName ?? "Array");
			this.ReadOnlyListClassName = ValidateLuaTypeName(this.ReadOnlyListClassName ?? "Array");
			this.ReadOnlyDictionaryClassName = ValidateLuaTypeName(this.ReadOnlyDictionaryClassName ?? "Map");
			this.NullableClassName = ValidateLuaTypeName(this.NullableClassName ?? "Nullable");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, this.MakeDocumentReferenceTypeRef(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			return valueType; // In Lua, all values are implicitly nullable (nil)
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			// Lua doesn't have type enforcement, but we track this for documentation
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return AnyType;
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateLuaTypeName(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateLuaIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateLuaIdentifier(MakePascalCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateLuaIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateLuaIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}
		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string> {
				{ typeof(string), "string" },
				{ typeof(char), "string" },
				{ typeof(bool), "boolean" },
				{ typeof(void), "nil" },
				{ typeof(byte), "integer" },
				{ typeof(sbyte), "integer" },
				{ typeof(short), "integer" },
				{ typeof(ushort), "integer" },
				{ typeof(int), "integer" },
				{ typeof(uint), "integer" },
				{ typeof(long), "integer" }, // Int64 mapped to integer (Int32 behavior)
				{ typeof(ulong), "integer" }, // Int64 mapped to integer (Int32 behavior)
				{ typeof(float), "number" },
				{ typeof(double), "number" },
				{ typeof(decimal), "number" },
				{ typeof(TimeSpan), "number" },
				{ typeof(DateTime), "number" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);

				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}

			return nativeTypes;
		}

		private static string ValidateLuaTypeName(string typeName)
		{
			typeName = ValidateLuaIdentifier(typeName);
			if (KnownTypes.Contains(typeName))
			{
				return "_" + typeName;
			}
			else
			{
				return typeName;
			}
		}

		private static string ValidateLuaIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class NativeTypeReference : ITypeReference
	{
		public string TypeName { get; private set; }

		public NativeTypeReference(string typeName)
		{
			this.TypeName = typeName;
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	public class NullTypeReference : ITypeReference
	{
		public static readonly NullTypeReference Instance = new NullTypeReference();

		/// <inheritdoc />
		public string TypeName => "null";
	}


	public class OrTypeReference : ITypeReference
	{
		private readonly List<ITypeReference> types;

		/// <inheritdoc />
		public string TypeName => this.ToString();

		public OrTypeReference(params ITypeReference[] types)
		{
			if (types == null) throw new ArgumentNullException(nameof(types));

			this.types = new List<ITypeReference>();
			foreach (var type in types)
			{
				if (this.types.Contains(type))
				{
					continue;
				}
				else if (type is OrTypeReference orTypeReference)
				{
					foreach (var subType in orTypeReference.types)
					{
						if (this.types.Contains(subType))
						{
							continue;
						}
						this.types.Add(subType);
					}
				}
				this.types.Add(type);
			}
		}

		public bool Contains(ITypeReference typeReference)
		{
			if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));

			return this.types.Contains(typeReference);
		}

		public OrTypeReference Without(ITypeReference typeReference)
		{
			if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));

			var typeIndex = this.types.IndexOf(typeReference);
			if (typeIndex < 0)
			{
				return this;
			}

			var newTypes = new List<ITypeReference>(this.types);
			newTypes.RemoveAt(typeIndex);
			return new OrTypeReference(newTypes.ToArray());
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return string.Join("|", this.types.Select(type => type.TypeName));
		}
	}


	//Copyright (c) 2011, Brendan Erwin and contributors. All rights reserved.

	//	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	//	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	//	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	//	The names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	//THIS SOFTWARE IS PROVIDED BY Brendan Erwin and contributors ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL Brendan Erwin or contributors BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	public static class Pluralizer
	{
		private static readonly EnglishInflector inflector = new EnglishInflector();

		public static string Pluralize(string value)
		{
			return inflector.Pluralize(value);
		}

		public static string Singularize(string value)
		{
			return inflector.Singularize(value);
		}

		private class NounsRule : IEquatable<NounsRule>
		{
			private readonly int hashCode;
			private readonly string pattern;
			private readonly Regex regex;
			private readonly string replacement;

			public NounsRule(string pattern, string replacement)
			{
				if (string.IsNullOrEmpty(pattern))
					throw new ArgumentNullException(nameof(pattern));
				if (replacement == null)
					throw new ArgumentNullException(nameof(replacement));
				this.pattern = pattern;
				this.replacement = replacement;
				this.hashCode = 397 ^ this.replacement.GetHashCode() ^ this.pattern.GetHashCode();
				this.regex = this.CreateRegex();
			}
			public bool Equals(NounsRule other)
			{
				if (ReferenceEquals(null, other))
					return false;
				if (ReferenceEquals(this, other))
					return true;
				return Equals(other.pattern, this.pattern) && Equals(other.replacement, this.replacement);
			}
			public override bool Equals(object obj)
			{
				return this.Equals(obj as NounsRule);
			}
			public override int GetHashCode()
			{
				return this.hashCode;
			}
			private Regex CreateRegex()
			{
				return new Regex(this.pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
			}
			public string Apply(string word)
			{
				if (!this.regex.IsMatch(word))
					return null;

				return this.regex.Replace(word, this.replacement);
			}
		}
		private sealed class EnglishInflector
		{
			private readonly List<NounsRule> plurals = new List<NounsRule>();
			private readonly List<NounsRule> singulars = new List<NounsRule>();
			private readonly HashSet<string> uncountables = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			public EnglishInflector()
			{
				this.AddPlural("$", "s");
				this.AddPlural("s$", "s");
				this.AddPlural("(ax|test)is$", "$1es");
				this.AddPlural("(octop|vir)us$", "$1i");
				this.AddPlural("(alias|status)$", "$1es");
				this.AddPlural("(bu)s$", "$1ses");
				this.AddPlural("(buffal|tomat)o$", "$1oes");
				this.AddPlural("([ti])um$", "$1a");
				this.AddPlural("sis$", "ses");
				this.AddPlural("(?:([^f])fe|([lr])f)$", "$1$2ves");
				this.AddPlural("(hive)$", "$1s");
				this.AddPlural("([^aeiouy]|qu)y$", "$1ies");
				this.AddPlural("(x|ch|ss|sh)$", "$1es");
				this.AddPlural("(matr|vert|ind)ix|ex$", "$1ices");
				this.AddPlural("([m|l])ouse$", "$1ice");
				this.AddPlural("^(ox)$", "$1en");
				this.AddPlural("(quiz)$", "$1zes");

				this.AddSingular("s$", "");
				this.AddSingular("(n)ews$", "$1ews");
				this.AddSingular("([ti])a$", "$1um");
				this.AddSingular("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$", "$1$2sis");
				this.AddSingular("(^analy)ses$", "$1sis");
				this.AddSingular("([^f])ves$", "$1fe");
				this.AddSingular("(hive)s$", "$1");
				this.AddSingular("(tive)s$", "$1");
				this.AddSingular("([lr])ves$", "$1f");
				this.AddSingular("([^aeiouy]|qu)ies$", "$1y");
				this.AddSingular("(s)eries$", "$1eries");
				this.AddSingular("(m)ovies$", "$1ovie");
				this.AddSingular("(x|ch|ss|sh)es$", "$1");
				this.AddSingular("([m|l])ice$", "$1ouse");
				this.AddSingular("(bus)es$", "$1");
				this.AddSingular("(o)es$", "$1");
				this.AddSingular("(shoe)s$", "$1");
				this.AddSingular("(cris|ax|test)es$", "$1is");
				this.AddSingular("(octop|vir)i$", "$1us");
				this.AddSingular("(alias|status)es$", "$1");
				this.AddSingular("^(ox)en", "$1");
				this.AddSingular("(vert|ind)ices$", "$1ex");
				this.AddSingular("(matr)ices$", "$1ix");
				this.AddSingular("(quiz)zes$", "$1");

				this.AddIrregular("person", "people");
				this.AddIrregular("man", "men");
				this.AddIrregular("child", "children");
				this.AddIrregular("sex", "sexes");
				this.AddIrregular("move", "moves");

				this.AddUncountable("equipment");
				this.AddUncountable("information");
				this.AddUncountable("rice");
				this.AddUncountable("money");
				this.AddUncountable("species");
				this.AddUncountable("series");
				this.AddUncountable("fish");
				this.AddUncountable("sheep");
			}
			private string ApplyFirstMatchRule(IEnumerable<NounsRule> rules, string word)
			{
				var result = word;
				if (this.uncountables.Contains(word)) return result;
				foreach (var rule in rules.Reverse())
				{
					result = rule.Apply(word);
					if (result != null)
					{
						break;
					}
				}
				return result ?? word;
			}
			private void AddIrregular(string singular, string plural)
			{
				this.AddPlural("(" + singular[0] + ")" + singular.Substring(1) + "$", "$1" + plural.Substring(1));
				this.AddSingular("(" + plural[0] + ")" + plural.Substring(1) + "$", "$1" + singular.Substring(1));
			}
			private void AddUncountable(string word)
			{
				this.uncountables.Add(word);
			}
			private void AddPlural(string rule, string replacement)
			{
				this.plurals.Add(new NounsRule(rule, replacement));
			}
			private void AddSingular(string rule, string replacement)
			{
				this.singulars.Add(new NounsRule(rule, replacement));
			}
			public string Pluralize(string word)
			{
				return this.ApplyFirstMatchRule(this.plurals, word);
			}
			public string Singularize(string word)
			{
				return this.ApplyFirstMatchRule(this.singulars, word);
			}
		}
	}


	public class RustLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"as", "async", "await", "break", "const", "continue", "crate", "dyn", "else",
			"enum", "extern", "false", "fn", "for", "if", "impl", "in", "let", "loop",
			"match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static",
			"struct", "super", "trait", "true", "type", "unsafe", "use", "where", "while",
			"abstract", "become", "box", "do", "final", "macro", "override", "priv", "typeof",
			"unsized", "virtual", "yield", "try", "union"
		});
		private static readonly HashSet<string> KnownTypes = new HashSet<string>(new string[] {
			"String", "Vec", "Box", "Option", "Result", "HashMap", "HashSet", "BTreeMap",
			"BTreeSet", "Arc", "Rc", "Cell", "RefCell"
		});
		private static readonly NativeTypeReference AnyType = new NativeTypeReference("Box<dyn std::any::Any>");

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.Rust;

		public RustLanguage()
		{
			this.Namespace = "game_parameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "Vec";
			this.DocumentCollectionClassName = "HashMap";
			this.ReadOnlyListClassName = "Vec";
			this.ReadOnlyDictionaryClassName = "HashMap";
			this.NullableClassName = "Option";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join("::", (this.Namespace ?? "game_parameters").Split('.').Select(ValidateRustIdentifier));
			this.GameDataClassName = ValidateRustTypeName(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateRustTypeName(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedTextClassName = ValidateRustTypeName(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateRustTypeName(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateRustTypeName(this.DocumentCollectionClassName ?? "HashMap");
			this.DocumentReferenceCollectionClassName = ValidateRustTypeName(this.DocumentReferenceCollectionClassName ?? "Vec");
			this.ReadOnlyListClassName = ValidateRustTypeName(this.ReadOnlyListClassName ?? "Vec");
			this.ReadOnlyDictionaryClassName = ValidateRustTypeName(this.ReadOnlyDictionaryClassName ?? "HashMap");
			this.NullableClassName = ValidateRustTypeName(this.NullableClassName ?? "Option");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "\n/// ") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, this.MakeDocumentReferenceTypeRef(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return valueType; // do not wrap twice into Option
			}

			return new GenericTypeReference(this.NullableClassName, valueType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType is GenericTypeReference genericTypeReference && genericTypeReference.Definition.TypeName == this.NullableClassName)
			{
				return genericTypeReference.GenericArguments[0];
			}

			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return AnyType;
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateRustTypeName(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateRustIdentifier(MakeSnakeCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateRustIdentifier(MakeSnakeCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateRustIdentifier(MakeSnakeCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateRustIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}
		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string> {
				{ typeof(string), "String" },
				{ typeof(char), "char" },
				{ typeof(bool), "bool" },
				{ typeof(void), "()" },
				{ typeof(byte), "u8" },
				{ typeof(sbyte), "i8" },
				{ typeof(short), "i16" },
				{ typeof(ushort), "u16" },
				{ typeof(int), "i32" },
				{ typeof(uint), "u32" },
				{ typeof(long), "i64" },
				{ typeof(ulong), "u64" },
				{ typeof(float), "f32" },
				{ typeof(double), "f64" },
				{ typeof(decimal), "f64" },
				{ typeof(TimeSpan), "std::time::Duration" },
				{ typeof(DateTime), "chrono::DateTime<chrono::Utc>" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);

				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}

			return nativeTypes;
		}

		private static string ValidateRustTypeName(string typeName)
		{
			typeName = ValidateRustIdentifier(typeName);
			if (KnownTypes.Contains(typeName))
			{
				return "_" + typeName;
			}
			else
			{
				return typeName;
			}
		}

		private static string ValidateRustIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "r#" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public sealed class StatisticsVisitor : GameDataVisitor
	{
		public readonly Dictionary<Schema, int> RootDocumentCount = new Dictionary<Schema, int>(200);
		public readonly Dictionary<Schema, int> DocumentCount = new Dictionary<Schema, int>(200);
		public readonly List<(Schema Schema, SchemaProperty UniqueProperty, string UniqueValueName, object UniqueValue)> DocumentUniqueValues = new List<(Schema schema, SchemaProperty UniqueProperty, string DocumentName, object Id)>(2000);

		public StatisticsVisitor(Metadata metadata) : base(metadata)
		{
		}

		protected override void VisitDocument
		(
			IReadOnlyDictionary<string, object> document,
			Schema documentSchema,
			Stack<IReadOnlyDictionary<string, object>> parentDocuments,
			Stack<SchemaProperty> path
		)
		{
			this.CountDocumentsByType(documentSchema, parentDocuments);

			this.CollectUniqueValues(document, documentSchema);

			base.VisitDocument(document, documentSchema, parentDocuments, path);
		}

		private void CollectUniqueValues(IReadOnlyDictionary<string, object> document, Schema documentSchema)
		{
			if (documentSchema.Name == nameof(Schema) || documentSchema.Name == nameof(SchemaProperty))
			{
				return; // don't generate document ids for metadata
			}

			if (documentSchema.Type == SchemaType.Settings)
			{
				return; // dont generate document id for settings
			}

			var documentName = default(string);
			document.TryGetValue("Name", out var name);
			document.TryGetValue("Title", out var title);
			document.TryGetValue("DisplayName", out var displayName);
			document.TryGetValue("Id", out var id);
			documentName = name as string ?? title as string ?? displayName as string ?? id as string;

			foreach (var schemaProperty in documentSchema.Properties)
			{
				if (schemaProperty.Uniqueness != Uniqueness.Unique)
				{
					continue;
				}

				if (!document.TryGetValue(schemaProperty.Name, out var uniqueValue) ||
					uniqueValue == null)
				{
					continue;
				}

				var isGeneratedId = schemaProperty.Name == "Id" && documentSchema.IdGenerator != IdGeneratorType.Custom;
				var uniqueValueName = !isGeneratedId && schemaProperty.DataType == DataType.Text ? uniqueValue as string : null;
				uniqueValueName = uniqueValueName ?? documentName;
				if (string.IsNullOrWhiteSpace(uniqueValueName))
				{
					continue;
				}

				this.DocumentUniqueValues.Add((documentSchema, schemaProperty, uniqueValueName, uniqueValue));
			}
		}
		private void CountDocumentsByType(Schema documentSchema, Stack<IReadOnlyDictionary<string, object>> parentDocuments)
		{
			if (this.DocumentCount.TryGetValue(documentSchema, out var count))
			{
				this.DocumentCount[documentSchema] = count + 1;
			}
			else
			{
				this.DocumentCount[documentSchema] = 1;
			}

			if (parentDocuments.Count == 0)
			{
				if (this.RootDocumentCount.TryGetValue(documentSchema, out count))
				{
					this.RootDocumentCount[documentSchema] = count + 1;
				}
				else
				{
					this.RootDocumentCount[documentSchema] = 1;
				}
			}
		}

		public static StatisticsVisitor Visit(IReadOnlyDictionary<string, object> gameData, Metadata metadata)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));
			if (metadata == null) throw new ArgumentNullException(nameof(metadata));

			var visitor = new StatisticsVisitor(metadata);
			visitor.Visit(gameData);
			return visitor;
		}
	}


	public class TypeDefinition : ITypeReference
	{
		public string TypeName { get; set; }
		public List<string> BaseTypeAndInterfaces { get; set; }
		public ITypeReference CollectionType { get; set; }
		public string CollectionName { get; set; }
		public string CollectionFieldName { get; set; }
		public string SettingsName { get; set; }
		public string DisplayName => this.Schema.DisplayName;
		public string Description { get; set; }
		public List<string> CustomAttributes { get; set; }

		public List<TypePropertyDefinition> Properties { get; }
		public TypePropertyDefinition IdMember { get; set; }
		public List<TypePropertyDefinition> UniqueMembers { get; }
		public SpecificationDictionary Specification { get; }
		public Schema Schema { get; }
		public bool IsSettings => this.Schema.Type == SchemaType.Settings;
		public bool IsUnion => this.Schema.Type == SchemaType.Union;

		public TypeDefinition(Schema schema, GenerationTargetLanguage targetLanguage, TypeGenerationFlags typeGenerationFlags, Func<string, ITypeReference> typeResolver)
		{
			if (schema == null) throw new ArgumentNullException(nameof(schema));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			this.TypeName = targetLanguage.MakeTypeName(targetLanguage.MakeSingular(schema.Name));
			this.CollectionName = targetLanguage.MakePropertyName(targetLanguage.MakePlural(schema.Name));
			this.SettingsName = targetLanguage.MakePropertyName(schema.Name);
			this.CollectionFieldName = targetLanguage.MakePropertyName(this.CollectionName);
			this.Schema = schema;
			this.Description = targetLanguage.PrepareDescription(schema.Description);
			this.Specification = schema.GetSpecification();
			this.BaseTypeAndInterfaces = this.Specification.GetSourceCodeBaseType(targetLanguage.SourceCodeLanguage);
			this.CustomAttributes = this.Specification.GetSourceCodeAttributes(targetLanguage.SourceCodeLanguage);

			if (string.Equals(this.SettingsName, this.CollectionName, StringComparison.Ordinal))
			{
				this.CollectionName = this.CollectionName + "List";
			}

			this.Properties = new List<TypePropertyDefinition>();
			this.UniqueMembers = new List<TypePropertyDefinition>();
			foreach (var schemaProperty in this.Schema.Properties)
			{
				var memberDefinition = new TypePropertyDefinition(this, schemaProperty, targetLanguage, typeGenerationFlags, typeResolver);

				if (schemaProperty.Name == GenerationConstants.KNOWN_SCHEMA_PROPERTY_ID)
				{
					this.IdMember = memberDefinition;
				}
				if (schemaProperty.Uniqueness != Uniqueness.None)
				{
					this.UniqueMembers.Add(memberDefinition);
				}
				this.Properties.Add(memberDefinition);
			}

			System.Diagnostics.Debug.Assert(this.IdMember != null, "this.IdMember != null");

			this.CollectionType = targetLanguage.MakeDocumentCollectionTypeRef(this.IdMember.Type, this);

			if (string.IsNullOrEmpty(this.Description))
			{
				this.Description = $"{this.DisplayName} with {this.IdMember.SchemaProperty.DataType} id.";
			}
			this.Description = this.Description.Trim();
			if (!this.Description.EndsWith(".")) { this.Description += "."; }

			this.Description +=
				(this.UniqueMembers.Count > 1 ? $" Unique Properties: {string.Join(", ", this.UniqueMembers.Select(member => member.Name))}," : string.Empty) +
				(this.IsSettings ? " Settings," : "");
			this.Description = this.Description.TrimEnd(new[] { ',', '.' }) + ".";
		}

		public IReadOnlyList<ITypeReference> GetReferenceTypes()
		{
			var result = new List<ITypeReference>();
			result.AddRange(this.Properties.Select(property => property.DocumentOrReferenceType ?? property.StorageType));
			for (var index = 0; index < result.Count; index++)
			{
				result[index] = TypeReference.Resolve(result[index]); // unwrap lazy types refs
			}

			// remove all native and external types
			result.RemoveAll(typeRef => !(typeRef is TypeDefinition) &&
				!(typeRef is EnumDefinition) &&
				!(typeRef is FormulaDefinition));

			return result.Distinct(TypeReference.TypeNameEqualityComparer).ToList();
		}

		public override string ToString()
		{
			return this.TypeName;
		}
	}


	[Flags]
	public enum TypeGenerationFlags
	{
		None = 0,
		RawReferences = 0x1 << 0,
		RawLocalizedTexts = 0x1 << 1,
	}


	public class TypeMemberDefinition
	{
		public string Name { get; set; }
		public ITypeReference Type { get; set; }

		public TypeMemberDefinition(string name, ITypeReference typeReference)
		{
			if (name == null) throw new ArgumentNullException(nameof(name));
			if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));
			if (string.IsNullOrEmpty(name)) throw new ArgumentException("Value cannot be null or empty.", nameof(name));

			this.Name = name;
			this.Type = typeReference;
		}
	}


	public class TypePropertyDefinition : TypeMemberDefinition
	{
		public string RawName => this.RawProperty?.Name ?? this.Name;
		public string DisplayName { get { return this.SchemaProperty.DisplayName; } }
		public string Description { get; set; }
		public int Ordinal { get; set; }
		public DataType DataType { get { return this.SchemaProperty.DataType; } }
		public Requirement Requirement { get { return this.SchemaProperty.Requirement; } }

		public ITypeReference DocumentOrReferenceType { get; set; }
		public ITypeReference DocumentCollectionType { get; set; }
		public ITypeReference StorageType { get; set; }
		public TypeMemberDefinition BackingField { get; set; }
		public TypeMemberDefinition ConstructorParameter { get; set; }
		public TypePropertyDefinition RawProperty { get; set; }
		public List<string> CustomAttributes { get; set; }

		public SpecificationDictionary Specification { get; }
		public SchemaProperty SchemaProperty { get; private set; }

		public TypePropertyDefinition
		(
			TypeDefinition typeDef,
			SchemaProperty schemaProperty,
			GenerationTargetLanguage targetLanguage,
			TypeGenerationFlags typeGenerationFlags,
			Func<string, ITypeReference> typeResolver)
			: base(targetLanguage.MakePropertyName(schemaProperty.Name),
				GetPropertyType(schemaProperty, targetLanguage, typeResolver))
		{
			if (typeDef == null) throw new ArgumentNullException(nameof(typeDef));
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			this.Ordinal = schemaProperty.DeclaredSchema.Properties.IndexOf(schemaProperty) + 1;
			this.StorageType = this.Type;
			this.SchemaProperty = schemaProperty;
			this.Description = targetLanguage.PrepareDescription(schemaProperty.Description);
			this.Specification = this.SchemaProperty.GetSpecification();
			this.Name = targetLanguage.MakePropertyName(this.SchemaProperty.Name);
			this.CustomAttributes = this.Specification.GetSourceCodeAttributes(targetLanguage.SourceCodeLanguage);

			if (schemaProperty.ReferenceType != null)
			{
				this.DocumentOrReferenceType = typeResolver(schemaProperty.ReferenceType.Id);
			}

			if ((typeGenerationFlags & TypeGenerationFlags.RawReferences) == 0 && this.DataType == DataType.Reference)
			{
				this.Type = this.DocumentOrReferenceType;
				this.RawProperty = new TypePropertyDefinition(typeDef, schemaProperty, targetLanguage, TypeGenerationFlags.RawReferences, typeResolver);
				this.RawProperty.Name = targetLanguage.MakePropertyName(this.RawProperty.Name + "Raw");
			}
			else if ((typeGenerationFlags & TypeGenerationFlags.RawReferences) == 0 && this.DataType == DataType.ReferenceCollection)
			{
				var idTypeRef = GetPropertyType(schemaProperty.ReferenceType?.Schema.GetIdProperty(), targetLanguage, typeResolver);
				this.Type = targetLanguage.MakeDocumentCollectionTypeRef(idTypeRef, this.DocumentOrReferenceType);
				this.RawProperty = new TypePropertyDefinition(typeDef, schemaProperty, targetLanguage, TypeGenerationFlags.RawReferences, typeResolver);
				this.RawProperty.Name = targetLanguage.MakePropertyName(this.RawProperty.Name + "Raw");
			}
			else if ((typeGenerationFlags & TypeGenerationFlags.RawLocalizedTexts) == 0 && this.DataType == DataType.LocalizedText)
			{
				this.Type = typeResolver(nameof(String));
				this.RawProperty = new TypePropertyDefinition(typeDef, schemaProperty, targetLanguage, TypeGenerationFlags.RawLocalizedTexts, typeResolver);
				this.RawProperty.Name = targetLanguage.MakePropertyName(this.RawProperty.Name + "Raw");
				this.RawProperty.BackingField.Name = targetLanguage.MakeFieldName(this.RawProperty.BackingField.Name + "Raw");
			}

			this.DocumentCollectionType = targetLanguage.MakeDocumentCollectionTypeRef(this.Type, typeDef);

			if (IsOptional(schemaProperty.Requirement, schemaProperty.DataType))
			{
				this.Type = targetLanguage.MakeOptionalTypeRef(this.Type);
			}

			this.BackingField = new TypeMemberDefinition(targetLanguage.MakeFieldName(this.Name), this.Type);
			this.ConstructorParameter = new TypeMemberDefinition(targetLanguage.MakeMethodParameterName(this.Name), this.Type);

			if (string.IsNullOrWhiteSpace(this.Description))
			{
				this.Description = $"{this.DisplayName} property of {targetLanguage.FormatEnumDisplayString(this.SchemaProperty.DataType)} type.";
			}
			this.Description = this.Description.Trim();
			if (!this.Description.EndsWith(".")) { this.Description += "."; }
			this.Description +=
				(this.Requirement == Requirement.None ? " Can Be Null," : $" {targetLanguage.FormatEnumDisplayString(this.Requirement)},") +
				(this.SchemaProperty.Uniqueness != Uniqueness.None ? " Unique," : string.Empty);
			this.Description = this.Description.TrimEnd(new[] { ',', '.' }) + ".";
		}

		private static ITypeReference GetPropertyType
		(
			SchemaProperty schemaProperty,
			GenerationTargetLanguage targetLanguage,
			Func<string, ITypeReference> typeResolver)
		{
			if (schemaProperty == null) throw new ArgumentNullException(nameof(schemaProperty));
			if (targetLanguage == null) throw new ArgumentNullException(nameof(targetLanguage));
			if (typeResolver == null) throw new ArgumentNullException(nameof(typeResolver));

			var type = default(ITypeReference);
			switch (schemaProperty.DataType)
			{
				case DataType.Logical:
				case DataType.Text:
				case DataType.Time:
				case DataType.Date:
				case DataType.Number:
				case DataType.Integer:
					type = typeResolver(schemaProperty.GetPropertyValueType().Name);
					break;
				case DataType.MultiPickList:
				case DataType.PickList:
					type = typeResolver(schemaProperty.Id); // will resolve EnumDefinition by this id
					break;
				case DataType.LocalizedText:
					type = new NativeTypeReference(targetLanguage.LocalizedTextClassName);
					break;
				case DataType.Document:
					type = typeResolver(schemaProperty.ReferenceType.Id); // will resolve TypeDefinition by this id
					break;
				case DataType.DocumentCollection:
					var idTypeRef = GetPropertyType(schemaProperty.ReferenceType.Schema.GetIdProperty(), targetLanguage, typeResolver);
					type = targetLanguage.MakeDocumentCollectionTypeRef(idTypeRef, typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.Reference:
					type = targetLanguage.MakeDocumentReferenceTypeRef(typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.ReferenceCollection:
					var refIdTypeRef = GetPropertyType(schemaProperty.ReferenceType.Schema.GetIdProperty(), targetLanguage, typeResolver);
					type = targetLanguage.MakeDocumentReferenceCollectionTypeRef(refIdTypeRef, typeResolver(schemaProperty.ReferenceType.Id));
					break;
				case DataType.Formula:
					if (schemaProperty.IsRawFormulaType)
					{
						type = targetLanguage.MakeRawFormulaTypeRef();
					}
					else
					{
						type = typeResolver(schemaProperty.Id); // will resolve FormulaDefinition by this id
					}

					break;
				default:
					throw new InvalidOperationException($"Unknown property data type {schemaProperty.DataType}.");
			}

			return type;
		}

		private static bool IsOptional(Requirement requirement, DataType dataType)
		{
			return requirement == Requirement.None &&
				dataType != DataType.DocumentCollection &&
				dataType != DataType.ReferenceCollection &&
				dataType != DataType.LocalizedText;
		}
	}


	public static class TypeReference
	{
		public static readonly IComparer<ITypeReference> TypeNameComparer = new TypeReferenceComparer();
		public static readonly IEqualityComparer<ITypeReference> TypeNameEqualityComparer = new TypeReferenceEqualityComparer();

		public static ITypeReference Resolve(ITypeReference typeReference)
		{
			while (typeReference is LazyTypeReference lazyTypeReference)
			{
				typeReference = lazyTypeReference.Resolve();
			}
			return typeReference;
		}

		private class TypeReferenceComparer : IComparer<ITypeReference>
		{
			public int Compare(ITypeReference x, ITypeReference y)
			{
				if (ReferenceEquals(x, y)) return 0;
				if (ReferenceEquals(null, y)) return 1;
				if (ReferenceEquals(null, x)) return -1;

				return string.Compare(x.TypeName, y.TypeName, StringComparison.Ordinal);
			}
		}
		private class TypeReferenceEqualityComparer : IEqualityComparer<ITypeReference>
		{
			public bool Equals(ITypeReference x, ITypeReference y)
			{
				if (ReferenceEquals(x, y)) return true;
				if (ReferenceEquals(x, null)) return false;
				if (ReferenceEquals(y, null)) return false;
				if (x.GetType() != y.GetType()) return false;

				return string.Equals(x.TypeName, y.TypeName, StringComparison.Ordinal);
			}
			public int GetHashCode(ITypeReference obj)
			{
				return (obj.TypeName != null ? obj.TypeName.GetHashCode() : 0);
			}
		}
	}


	public delegate ITypeReference TypeResolveFn(string typeName);


	public class TypeScriptLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"break", "case", "catch", "class", "const", "continue", "debugger", "default",
			"delete", "do", "else", "enum", "export", "extends", "false", "finally", "for",
			"function", "if", "import", "in", "instanceof", "new", "null", "return", "super",
			"switch", "this", "throw", "true", "try", "typeof", "var", "void", "while", "with",
			"as", "implements", "interface", "let", "package", "private", "protected", "public",
			"static", "yield", "any", "boolean", "constructor", "declare", "get", "module", "require",
			"number", "set", "string", "symbol", "type", "from", "of",
		});
		private static readonly HashSet<string> KnownTypes = new HashSet<string>(new string[] {
			"Map", "Set", "Document", "Window", "String", "Number", "Boolean", "Date",
			"TimeSpan", "Math", "Object", "Function", "Bigint", "Symbol", "Array", "RegExp", "Error",
		});
		private static readonly NativeTypeReference AnyType = new NativeTypeReference("any");

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.TypeScript;

		public TypeScriptLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "GameData";
			this.DocumentClassName = "GameDataDocument";
			this.LocalizedTextClassName = "LocalizedText";
			this.DocumentReferenceClassName = "DocumentReference";
			this.DocumentReferenceCollectionClassName = "DocumentReferenceCollection";
			this.DocumentCollectionClassName = "DocumentCollection";
			this.ReadOnlyListClassName = "ReadOnlyArray";
			this.ReadOnlyDictionaryClassName = "ReadOnlyMap";
			this.NullableClassName = "Nullable";
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Join(".", (this.Namespace ?? "GameParameters").Split('.').Select(ValidateTypeScriptIdentifier));
			this.GameDataClassName = ValidateTypeScriptIdentifier(this.GameDataClassName ?? "GameData");
			this.DocumentClassName = ValidateTypeScriptIdentifier(this.DocumentClassName ?? "GameDataDocument");
			this.LocalizedTextClassName = ValidateTypeScriptIdentifier(this.LocalizedTextClassName ?? "LocalizedText");
			this.DocumentReferenceClassName = ValidateTypeScriptIdentifier(this.DocumentReferenceClassName ?? "DocumentReference");
			this.DocumentCollectionClassName = ValidateTypeScriptIdentifier(this.DocumentCollectionClassName ?? "DocumentCollection");
			this.DocumentReferenceCollectionClassName = ValidateTypeScriptIdentifier(this.DocumentReferenceCollectionClassName ?? "DocumentReferenceCollection");
			this.ReadOnlyListClassName = ValidateTypeScriptIdentifier(this.ReadOnlyListClassName ?? "ReadOnlyArray");
			this.ReadOnlyDictionaryClassName = ValidateTypeScriptIdentifier(this.ReadOnlyDictionaryClassName ?? "ReadOnlyMap");
			this.NullableClassName = ValidateTypeScriptIdentifier(this.NullableClassName?? "Nullable");
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));

			if (valueType is OrTypeReference orTypeReference && orTypeReference.Contains(NullTypeReference.Instance))
			{
				return valueType; // don't duplicate null type
			}
			return new OrTypeReference(valueType, NullTypeReference.Instance);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType is OrTypeReference orTypeReference)
			{
				return orTypeReference.Without(NullTypeReference.Instance);
			}
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new GenericTypeReference(this.DocumentReferenceClassName, documentType);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return AnyType;
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateTypeScriptTypeName(MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			return MakeTypeName(enumName);
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateTypeScriptIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateTypeScriptIdentifier(MakePascalCaseIdentifier(enumLiteralName));
		}
		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "string" },
				{ typeof(char), "string" },
				{ typeof(bool), "boolean" },
				{ typeof(void), "void" },
				{ typeof(object), "object" },
				{ typeof(byte), "number" },
				{ typeof(sbyte), "number" },
				{ typeof(short), "number" },
				{ typeof(ushort), "number" },
				{ typeof(int), "number" },
				{ typeof(uint), "number" },
				{ typeof(long), "bigint" },
				{ typeof(ulong), "bigint" },
				{ typeof(float), "number" },
				{ typeof(double), "number" },
				{ typeof(decimal), "number" },
				{ typeof(TimeSpan), "TimeSpan" },
				{ typeof(DateTime), "Date" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateTypeScriptTypeName(string typeName)
		{
			typeName = ValidateTypeScriptIdentifier(typeName);
			if (KnownTypes.Contains(typeName))
			{
				return "_" + typeName;
			}
			else
			{
				return typeName;
			}
		}
		private static string ValidateTypeScriptIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public class UeCppLanguage : GenerationTargetLanguage
	{
		private static readonly HashSet<string> Keywords = new HashSet<string>(new string[] {
			"alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand", "bitor", "bool",
			"break", "case", "catch", "char", "char8_t", "char16_t", "char32_t", "class",
			"compl", "concept", "const", "const_cast", "consteval", "constexpr", "constinit",
			"continue", "co_await", "co_return", "co_yield", "decltype", "default", "delete",
			"do", "double", "dynamic_cast", "else", "enum", "explicit", "export", "extern",
			"false", "float", "for", "friend", "goto", "if", "inline", "int", "long", "mutable",
			"namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or",
			"or_eq", "private", "protected", "public", "register", "reinterpret_cast", "requires",
			"return", "short", "signed", "sizeof", "static", "static_assert", "static_cast",
			"struct", "switch", "template", "this", "thread_local", "throw", "true", "try",
			"typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void",
			"volatile", "wchar_t", "while", "xor", "xor_eq"
		});

		public string SharedRefTypeName = "TSharedRef";
		public string SharedPtrTypeName = "TSharedPtr";
		public string OptionalTypeName = "TOptional";
		public string FunctionTypeName = "TFunction";

		public string ModuleName { get; set; }
		public string ApiName => this.ModuleName.ToUpperInvariant() + "_API";
		public string ConstantPrefix => this.ModuleName.ToUpperInvariant() + "_";

		public override TargetSourceCodeLanguage SourceCodeLanguage => TargetSourceCodeLanguage.UeCpp;

		public UeCppLanguage()
		{
			this.Namespace = "GameParameters";
			this.GameDataClassName = "UGameData";
			this.ModuleName = "GameData";
			this.DocumentClassName = "UGameDataDocument";
			this.LocalizedTextClassName = "FLocalizedText";
			this.DocumentReferenceClassName = "FGameDataDocumentReference";
			this.DocumentReferenceCollectionClassName = "TArray";
			this.DocumentCollectionClassName = "TMap";
			this.ReadOnlyListClassName = "TArray";
			this.ReadOnlyDictionaryClassName = "TMap";
			this.NullableClassName = this.OptionalTypeName;
		}

		/// <inheritdoc />
		public override void FixClassNames()
		{
			this.Namespace = string.Empty;
			this.GameDataClassName = ValidateCppIdentifier(this.GameDataClassName ?? "UGameData");
			this.ModuleName = TrimTypePrefix(this.GameDataClassName);
			this.DocumentClassName = ValidateCppIdentifier(this.DocumentClassName ?? "UGameDataDocument");
			this.LocalizedTextClassName = ValidateCppIdentifier(this.LocalizedTextClassName ?? "FLocalizedText");
			this.DocumentReferenceClassName = "FGameDataDocumentReference";
			this.DocumentCollectionClassName = ValidateCppIdentifier(this.DocumentCollectionClassName ?? "TMap");
			this.DocumentReferenceCollectionClassName = ValidateCppIdentifier(this.DocumentReferenceCollectionClassName ?? "TArray");
			this.ReadOnlyListClassName = ValidateCppIdentifier(this.ReadOnlyListClassName ?? "TArray");
			this.ReadOnlyDictionaryClassName = ValidateCppIdentifier(this.ReadOnlyDictionaryClassName ?? "TMap");
			this.NullableClassName = ValidateCppIdentifier(this.NullableClassName ?? this.OptionalTypeName);
		}

		public ITypeReference MakePtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("", elementType, "*");
		}
		public ITypeReference MakeConstType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new DerivedTypeReference("const ", elementType, "");
		}
		public ITypeReference MakeSharedPtrType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(SharedPtrTypeName, elementType);
		}
		public ITypeReference MakeSharedRefType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(SharedRefTypeName, elementType);
		}
		public ITypeReference MakeOptionalType(ITypeReference elementType)
		{
			if (elementType == null) throw new ArgumentNullException(nameof(elementType));

			return new GenericTypeReference(OptionalTypeName, elementType);
		}

		/// <inheritdoc />
		public override string PrepareDescription(string summary)
		{
			{
				if (string.IsNullOrWhiteSpace(summary))
				{
					return null;
				}

				return SecurityElement.Escape(summary)?.Trim('.').Replace("\r", "").Replace("\n", "<br />") ?? "";
			}
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceCollectionTypeRef(ITypeReference idType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentReferenceCollectionClassName, this.MakeDocumentReferenceTypeRef(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentCollectionTypeRef(ITypeReference keyType, ITypeReference documentType)
		{
			return new GenericTypeReference(this.DocumentCollectionClassName, keyType, this.MakePtrType(documentType));
		}
		/// <inheritdoc />
		public override ITypeReference MakeOptionalTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));
			// there is no way to express optional type in UE C++
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeRequiredTypeRef(ITypeReference valueType)
		{
			if (valueType == null) throw new ArgumentNullException(nameof(valueType));
			// there is no way to express optional type in UE C++
			return valueType;
		}
		/// <inheritdoc />
		public override ITypeReference MakeDocumentReferenceTypeRef(ITypeReference documentType)
		{
			if (documentType == null) throw new ArgumentNullException(nameof(documentType));

			return new NativeTypeReference(this.DocumentReferenceClassName);
		}
		/// <inheritdoc />
		public override ITypeReference MakeRawFormulaTypeRef()
		{
			return new NativeTypeReference("FJsonObjectWrapper");
		}
		/// <inheritdoc />
		public override string MakeTypeName(string typeName)
		{
			if (typeName == null) throw new ArgumentNullException(nameof(typeName));

			return ValidateCppIdentifier("U" + MakeDromedaryCaseName(typeName));
		}
		/// <inheritdoc />
		public override string MakeEnumName(string enumName)
		{
			if (enumName.Length > 3 && enumName.StartsWith("E", StringComparison.Ordinal) && char.IsUpper(enumName[1]))
			{
				return enumName;
			}
			return ValidateCppIdentifier("E" + MakeDromedaryCaseName(enumName));
		}
		/// <inheritdoc />
		public override string MakeFieldName(string fieldName)
		{
			if (fieldName == null) throw new ArgumentNullException(nameof(fieldName));

			return ValidateCppIdentifier("_" + MakePascalCaseIdentifier(fieldName));
		}
		/// <inheritdoc />
		public override string MakePropertyName(string propertyName)
		{
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(propertyName));
		}
		/// <inheritdoc />
		public override string MakeFormulaName(string formulaName)
		{
			if (formulaName == null) throw new ArgumentNullException(nameof(formulaName));

			return MakeTypeName(formulaName);
		}
		/// <inheritdoc />
		public override string MakeMethodParameterName(string parameterName)
		{
			if (parameterName == null) throw new ArgumentNullException(nameof(parameterName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(parameterName));
		}
		/// <inheritdoc />
		public override string MakeEnumLiteralName(string enumLiteralName)
		{
			if (enumLiteralName == null) throw new ArgumentNullException(nameof(enumLiteralName));

			return ValidateCppIdentifier(MakeDromedaryCaseName(enumLiteralName));
		}

		public static string TrimTypePrefix(string typeName)
		{
			if (typeName.Length > 2 &&
				char.IsUpper(typeName[0]) &&
				char.IsLetter(typeName[0]) &&
				char.IsUpper(typeName[1]) &&
				char.IsLetter(typeName[1]) &&
				(typeName[0] == 'U' || typeName[0] == 'F' || typeName[0] == 'E'))
			{
				return typeName.Substring(1);
			}

			return typeName;
		}

		/// <inheritdoc />
		public override Dictionary<string, NativeTypeReference> GetNativeTypes()
		{
			var types = new Dictionary<Type, string>
			{
				{ typeof(string), "FString" },
				{ typeof(char), "FString" },
				{ typeof(bool), "bool" },
				{ typeof(void), "void" },
				{ typeof(byte), "int32" },
				{ typeof(sbyte), "int32" },
				{ typeof(short), "int32" },
				{ typeof(ushort), "int32" },
				{ typeof(int), "int32" },
				{ typeof(uint), "uint32" },
				{ typeof(long), "int64" },
				{ typeof(ulong), "uint64" },
				{ typeof(float), "float" },
				{ typeof(double), "double" },
				{ typeof(decimal), "double" },
				{ typeof(TimeSpan), "FTimespan" },
				{ typeof(DateTime), "FDateTime" },
			};
			var nativeTypes = new Dictionary<string, NativeTypeReference>();
			foreach (var typeWithNativeName in types)
			{
				var nativeType = new NativeTypeReference(typeWithNativeName.Value);
				nativeTypes.Add(typeWithNativeName.Key.Name, nativeType);
				if (!string.IsNullOrEmpty(typeWithNativeName.Key.FullName))
				{
					nativeTypes.Add(typeWithNativeName.Key.FullName, nativeType);
				}
			}
			return nativeTypes;
		}

		private static string ValidateCppIdentifier(string identifier)
		{
			if (Keywords.Contains(identifier))
			{
				return "_" + identifier;
			}
			else
			{
				return identifier;
			}
		}
	}


	public enum DataType
	{
		Text = 0,
		LocalizedText = 1,
		Logical = 5,
		Time = 8,
		Date = 9,
		Number = 12,
		Integer = 13,
		MultiPickList = 19,
		PickList = 18,
		Document = 22,
		DocumentCollection = 23,
		Reference = 28,
		ReferenceCollection = 29,
		Formula = 35
	}


	public enum IdGeneratorType
	{
		Custom = 0,
		ObjectId = 1,
		Guid = 2,
		Sequence = 3,
		GlobalSequence = 4
	}


	public sealed class Metadata
	{
		private readonly Dictionary<object, Schema> schemasById;
		private readonly Dictionary<string, Schema> schemasByName;
		private readonly Dictionary<object, SchemaProperty> sharedSchemaPropertiesById;
		private readonly Dictionary<string, SchemaProperty> sharedSchemaPropertiesByName;
		private readonly ProjectSettings projectSettings;

		public readonly Version ToolsVersion;
		public readonly int ChangeNumber;
		public readonly string RevisionHash;

		public ProjectSettings ProjectSettings => this.projectSettings;

		public Metadata(IReadOnlyDictionary<string, object> gameData)
		{
			if (gameData == null) throw new ArgumentNullException(nameof(gameData));

			if (!gameData.ContainsKey("Collections"))
				throw new InvalidOperationException("Invalid gamedata. Missing 'Collections'.");

			var collections = (IReadOnlyDictionary<string, object>)gameData["Collections"];

			if (!collections.ContainsKey("Schema"))
				throw new InvalidOperationException("Invalid gamedata. Missing 'Schema' collection.");

			var schemas = ((IList<object>)collections["Schema"])
				.OfType<IReadOnlyDictionary<string, object>>()
				.Select(document => new Schema(
					document,
					id => this.GetSchema(Convert.ToString(id, CultureInfo.InvariantCulture)),
					id => this.GetSharedSchemaProperty(Convert.ToString(id, CultureInfo.InvariantCulture))));

			var sharedSchemaProperties = ((IList<object>)collections["SchemaProperty"])
				.OfType<IReadOnlyDictionary<string, object>>()
				.Select(document => new SchemaProperty(
					document,
					null,
					id => this.GetSchema(Convert.ToString(id, CultureInfo.InvariantCulture)),
					id => this.GetSharedSchemaProperty(Convert.ToString(id, CultureInfo.InvariantCulture))));

			var projectSettings = Enumerable.Empty<ProjectSettings>();

			if (collections.TryGetValue("ProjectSettings", out var collection))
			{
				projectSettings = ((IList<object>)collection)
					.OfType<IReadOnlyDictionary<string, object>>()
					.Select(document => new ProjectSettings(document));
			}

			this.schemasById = new Dictionary<object, Schema>();
			this.schemasByName = new Dictionary<string, Schema>(StringComparer.Ordinal);

			foreach (var schema in schemas)
			{
				this.schemasById[schema.Id] = schema;
				this.schemasByName[schema.Name] = schema;
			}

			this.sharedSchemaPropertiesById = new Dictionary<object, SchemaProperty>();
			this.sharedSchemaPropertiesByName = new Dictionary<string, SchemaProperty>(StringComparer.Ordinal);

			foreach (var schemaProperty in sharedSchemaProperties)
			{
				this.sharedSchemaPropertiesById[schemaProperty.Id] = schemaProperty;
				this.sharedSchemaPropertiesByName[schemaProperty.Name] = schemaProperty;
			}

			this.projectSettings = projectSettings.FirstOrDefault() ?? new ProjectSettings(new Dictionary<string, object>());

			this.ToolsVersion = gameData.TryGetValue("ToolsVersion", out var toolsVersion) ? new Version((string)toolsVersion) : new Version();
			this.ChangeNumber = GetValueOrDefault(gameData, "ChangeNumber", 0);
			this.RevisionHash = GetValueOrDefault(gameData, "RevisionHash", string.Empty);
		}

		public ICollection<Schema> GetSchemas()
		{
			return this.schemasById.Values;
		}
		public Schema GetSchema(string schemaIdOrName)
		{
			if (schemaIdOrName == null) throw new ArgumentNullException(nameof(schemaIdOrName));

			if (!this.TryGetSchema(schemaIdOrName, out var schema))
			{
				throw new ArgumentException($"Unable to find schema with id or name '{schemaIdOrName}'.");
			}
			return schema;
		}
		public bool TryGetSchema(string schemaIdOrName, out Schema schema)
		{
			if (schemaIdOrName == null) throw new ArgumentNullException(nameof(schemaIdOrName));

			if (!this.schemasById.TryGetValue(schemaIdOrName, out schema) &&
				!this.schemasByName.TryGetValue(schemaIdOrName, out schema))
			{
				return false;
			}

			return true;
		}

		public ICollection<SchemaProperty> GetSharedSchemaProperties()
		{
			return this.sharedSchemaPropertiesById.Values;
		}
		public SchemaProperty GetSharedSchemaProperty(string schemaPropertyIdOrName)
		{
			if (schemaPropertyIdOrName == null) throw new ArgumentNullException(nameof(schemaPropertyIdOrName));

			if (!this.TryGetSharedSchemaProperty(schemaPropertyIdOrName, out var schemaProperty))
			{
				throw new ArgumentException($"Unable to find shared schema property with id or name '{schemaPropertyIdOrName}'.");
			}
			return schemaProperty;
		}
		public bool TryGetSharedSchemaProperty(string schemaPropertyIdOrName, out SchemaProperty schemaProperty)
		{
			if (schemaPropertyIdOrName == null) throw new ArgumentNullException(nameof(schemaPropertyIdOrName));

			if (!this.sharedSchemaPropertiesById.TryGetValue(schemaPropertyIdOrName, out schemaProperty) &&
				!this.sharedSchemaPropertiesByName.TryGetValue(schemaPropertyIdOrName, out schemaProperty))
			{
				return false;
			}

			return true;
		}

		public static T GetValueOrDefault<T>(IReadOnlyDictionary<string, object> values, string valueName, T defaultValue, bool isRequired = false, string subject = "Object")
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (valueName == null) throw new ArgumentNullException(nameof(valueName));

			if (values.TryGetValue(valueName, out var valueObj))
			{
				if (valueObj is T typedValue)
				{
					return typedValue;
				}
				else if (valueObj == null)
				{
					return default(T);
				}
				else if (typeof(T).IsEnum)
				{
					var enumSubType = Enum.GetUnderlyingType(typeof(T));
					// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
					switch (Type.GetTypeCode(valueObj.GetType()))
					{
						case TypeCode.Single:
						case TypeCode.Double:
							var doubleValue = Math.Round(Convert.ToDouble(valueObj, CultureInfo.InvariantCulture));
							valueObj = Convert.ChangeType(doubleValue, enumSubType, CultureInfo.InvariantCulture);
							return (T)Enum.ToObject(typeof(T), valueObj);
						case TypeCode.Byte:
						case TypeCode.Int16:
						case TypeCode.Int32:
						case TypeCode.Int64:
						case TypeCode.SByte:
						case TypeCode.UInt16:
						case TypeCode.UInt32:
						case TypeCode.UInt64:
							return (T)Enum.ToObject(typeof(T), valueObj);
						default:
							var enumString = Convert.ToString(valueObj, CultureInfo.InvariantCulture) ?? string.Empty;
							return (T)Enum.Parse(typeof(T), enumString, true);
					}
				}
				else
				{
					return (T)Convert.ChangeType(valueObj, typeof(T), CultureInfo.InvariantCulture);
				}
			}
			else if (isRequired)
			{
				throw new InvalidOperationException($"{subject} is missing required member '{valueName}'.");
			}
			else
			{
				return defaultValue;
			}
		}
	}


	public sealed class ProjectSettings
	{
		public const string DEFAULT_PROJECT_NAME = "Untitled Project";

		public static readonly string DefaultLanguage = "en-US";
		public static readonly char[] LanguageListSeparator = ";,| ".ToCharArray();

		private readonly string[] languageIds;

		public readonly string Id;
		public readonly string Name;
		public readonly string Copyright;
		public readonly string Languages;
		public readonly string PrimaryLanguage;

		public ProjectSettings(IReadOnlyDictionary<string, object> values)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, false, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, false, this.GetType().Name);
			this.Copyright = Metadata.GetValueOrDefault(values, "Copyright", string.Empty, false, this.GetType().Name);
			this.Languages = Metadata.GetValueOrDefault(values, "Languages", string.Empty, false, this.GetType().Name);
			this.PrimaryLanguage = Metadata.GetValueOrDefault(values, "PrimaryLanguage", string.Empty, false, this.GetType().Name);

			if (string.IsNullOrWhiteSpace(this.Name))
			{
				this.Name = DEFAULT_PROJECT_NAME;
			}
			if (string.IsNullOrWhiteSpace(this.Copyright))
			{
				this.Copyright = string.Empty;
			}
			if (string.IsNullOrWhiteSpace(this.PrimaryLanguage))
			{
				this.PrimaryLanguage = DefaultLanguage;
			}

			var allLanguages = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			if (string.IsNullOrWhiteSpace(this.Languages) == false)
			{
				foreach(var lang in this.Languages.Split(LanguageListSeparator, StringSplitOptions.RemoveEmptyEntries))
					allLanguages.Add(lang);
			}

			allLanguages.Add(this.PrimaryLanguage);

			var allLanguageIds = allLanguages.ToArray();
			Array.Sort(allLanguageIds, StringComparer.OrdinalIgnoreCase);
			this.languageIds = allLanguageIds;

			this.Languages = string.Join(LanguageListSeparator[0].ToString(), this.languageIds);
		}

		public string[] GetLanguageIds()
		{
			return this.languageIds;
		}

		public ProjectSettings Clone()
		{
			var clone = (ProjectSettings)this.MemberwiseClone();
			return clone;
		}

		public override string ToString()
		{
			return string.Format(
				"{0}, languages: {2}, primary language: {3}, copyright: {1}",
				this.Name,
				this.Copyright,
				this.Languages,
				this.PrimaryLanguage
			);
		}
	}


	public enum Requirement
	{
		None = 0,
		NotNull = 2,
		NotEmpty = 3,
	}


	public sealed class Schema
	{
		private readonly Dictionary<string, SchemaProperty> propertiesById;
		private readonly Dictionary<string, SchemaProperty> propertiesByName;
		private readonly SpecificationDictionary specification;

		public readonly string Id;
		public readonly string Name;
		public readonly SchemaType Type;
		public readonly IdGeneratorType IdGenerator;
		public readonly string DisplayName;
		public readonly string Description;
		public readonly string Specification;

		public List<SchemaProperty> Properties { get; private set; }

		public Schema(IReadOnlyDictionary<string, object> values, Func<object, Schema> findSchemaFunc, Func<object, SchemaProperty> findSchemaPropertyFunc)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (findSchemaFunc == null) throw new ArgumentNullException(nameof(findSchemaFunc));
			if (findSchemaPropertyFunc == null) throw new ArgumentNullException(nameof(findSchemaPropertyFunc));

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, true, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, true, this.GetType().Name);
			this.Type = Metadata.GetValueOrDefault(values, "Type", default(SchemaType), false, this.GetType().Name);
			this.DisplayName = Metadata.GetValueOrDefault(values, "DisplayName", string.Empty, false, this.GetType().Name);
			this.Description = Metadata.GetValueOrDefault(values, "Description", string.Empty, false, this.GetType().Name);
			this.Specification = Metadata.GetValueOrDefault(values, "Specification", string.Empty, false, this.GetType().Name);
			this.IdGenerator = Metadata.GetValueOrDefault(values, "IdGenerator", default(IdGeneratorType), false, this.GetType().Name);

			this.Properties = new List<SchemaProperty>();

			if (values.TryGetValue("Properties", out var propertiesObj) && propertiesObj != null)
			{
				foreach (var propertyObj in (IList<object>)propertiesObj)
				{
					this.Properties.Add(new SchemaProperty((IReadOnlyDictionary<string, object>)propertyObj, this, findSchemaFunc, findSchemaPropertyFunc));
				}
			}

			if (string.IsNullOrEmpty(this.DisplayName))
			{
				this.DisplayName = this.Name;
			}

			this.propertiesById = new Dictionary<string, SchemaProperty>(StringComparer.Ordinal);
			this.propertiesByName = new Dictionary<string, SchemaProperty>(StringComparer.Ordinal);

			foreach (var attr in this.Properties)
			{
				this.propertiesById.Add(attr.Id, attr);
				this.propertiesByName.Add(attr.Name, attr);
			}
			this.specification = new SpecificationDictionary(this.Specification ?? string.Empty);
		}

		public bool HasProperty(string propertyIdOrName)
		{
			if (propertyIdOrName == null) throw new ArgumentNullException(nameof(propertyIdOrName));

			return this.propertiesById.ContainsKey(propertyIdOrName) || this.propertiesByName.ContainsKey(propertyIdOrName);
		}
		public SchemaProperty GetIdProperty()
		{
			return this.GetProperty("Id");
		}
		public SchemaProperty GetProperty(string propertyIdOrName)
		{
			if (propertyIdOrName == null) throw new ArgumentNullException(nameof(propertyIdOrName));

			if (this.propertiesById.TryGetValue(propertyIdOrName, out var schemaProperty) == false && this.propertiesByName.TryGetValue(propertyIdOrName, out schemaProperty) == false)
				throw new ArgumentException($"Unable to find property with id or name '{propertyIdOrName}' on schema '{this.Name}'.");
			return schemaProperty;
		}
		public SpecificationDictionary GetSpecification()
		{
			return this.specification;
		}

		public override string ToString()
		{
			return $"{this.Name}, id: {this.Id}";
		}
	}


	public sealed class SchemaProperty
	{
		private readonly Type propertyValueType;
		private readonly SpecificationDictionary specification;

		public readonly string Id;
		public readonly string Name;
		public readonly string DisplayName;
		public readonly string Description;

		public readonly DataType DataType;
		public readonly Uniqueness Uniqueness;
		public readonly Requirement Requirement;
		public readonly SchemaReference ReferenceType;
		public readonly SchemaPropertyReference SharedProperty;
		public readonly int Size;
		public readonly string Specification;
		public bool IsRawFormulaType => string.IsNullOrEmpty(this.GetSpecification().GetFormulaResultType());

		public readonly Schema DeclaredSchema;

		public SchemaProperty(IReadOnlyDictionary<string, object> values, Schema declaredSchema, Func<object, Schema> findSchemaFunc, Func<object, SchemaProperty> findSchemaPropertyFunc)
		{
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (findSchemaFunc == null) throw new ArgumentNullException(nameof(findSchemaFunc));
			if (findSchemaPropertyFunc == null) throw new ArgumentNullException(nameof(findSchemaPropertyFunc));

			this.DeclaredSchema = declaredSchema;

			this.Id = Metadata.GetValueOrDefault(values, "Id", string.Empty, true, this.GetType().Name);
			this.Name = Metadata.GetValueOrDefault(values, "Name", string.Empty, true, this.GetType().Name);
			this.DisplayName = Metadata.GetValueOrDefault(values, "DisplayName", this.Name, false, this.GetType().Name);
			this.Description = Metadata.GetValueOrDefault(values, "Description", string.Empty, false, this.GetType().Name);
			this.DataType = Metadata.GetValueOrDefault(values, "DataType", default(DataType), true, this.GetType().Name);
			this.Uniqueness = Metadata.GetValueOrDefault(values, "Uniqueness", default(Uniqueness), true, this.GetType().Name);
			this.Requirement = Metadata.GetValueOrDefault(values, "Requirement", default(Requirement), true, this.GetType().Name);
			this.Size = Metadata.GetValueOrDefault(values, "Size", 0, true, this.GetType().Name);
			this.Specification = Metadata.GetValueOrDefault(values, "Specification", default(string), false, this.GetType().Name);

			if (string.IsNullOrEmpty(this.DisplayName))
			{
				this.DisplayName = this.Name;
			}

			if (values.TryGetValue("ReferenceType", out var referenceTypeObj) && referenceTypeObj != null)
			{
				this.ReferenceType = new SchemaReference(findSchemaFunc) {
					Id = Metadata.GetValueOrDefault((IReadOnlyDictionary<string, object>)referenceTypeObj, "Id", string.Empty, true, "ReferenceType")
				};
			}

			if (values.TryGetValue("SharedProperty", out var sharedPropertyObj) && sharedPropertyObj != null)
			{
				this.SharedProperty = new SchemaPropertyReference(findSchemaPropertyFunc) {
					Id = Metadata.GetValueOrDefault((IReadOnlyDictionary<string, object>)sharedPropertyObj, "Id", string.Empty, true, "SharedProperty")
				};
			}

			var spec = new SpecificationDictionary(this.Specification ?? string.Empty);
			var type = typeof(string);
			switch (this.DataType)
			{
				case DataType.LocalizedText:
					type = typeof(IReadOnlyDictionary<string, string>);
					break;
				case DataType.Text:
					type = typeof(string);
					break;
				case DataType.Date:
					type = typeof(DateTime);
					break;
				case DataType.Time:
					type = typeof(TimeSpan);
					break;
				case DataType.Logical:
					type = typeof(bool);
					break;
				case DataType.Formula:
				case DataType.Reference:
				case DataType.Document:
					type = typeof(IReadOnlyDictionary<string, object>);
					break;
				case DataType.ReferenceCollection:
				case DataType.DocumentCollection:
					type = typeof(List<IReadOnlyDictionary<string, object>>);
					break;
				case DataType.MultiPickList:
				case DataType.PickList:
				case DataType.Integer:
					switch (this.Size)
					{
						case 1:
							type = typeof(sbyte);
							break;
						case 2:
							type = typeof(short);
							break;
						case 3:
						case 4:
							type = typeof(int);
							break;
						case 5:
						case 6:
						case 7:
						case 8:
							type = typeof(long);
							break;
						default:
							throw new InvalidOperationException(string.Format("Invalid size '{1}' of '{0}' property. Size for integer should be between 1 and 8.",
								this.Name, this.Size));
					}

					break;
				case DataType.Number:
					if (this.Size <= 4)
					{
						type = typeof(float);
					}
					else if (this.Size <= 8)
					{
						type = typeof(double);
					}
					else
					{
						throw new InvalidOperationException(string.Format("Invalid size '{1}' of '{0}' property. Size for number should be between 1 and 8.",
							this.Name, this.Size));
					}

					break;
				default: throw new InvalidOperationException(string.Format("Invalid type '{1}' of '{0}' property.", this.Name, this.DataType));
			}

			this.propertyValueType = type;
			this.specification = spec;
		}

		public Type GetPropertyValueType()
		{
			return this.propertyValueType;
		}
		public SpecificationDictionary GetSpecification()
		{
			return this.specification;
		}
		public override string ToString()
		{
			return $"{this.Name}, id: {this.Id}";
		}
	}


	public sealed class SchemaPropertyReference
	{
		private readonly Func<object, SchemaProperty> findSchemaPropertyFunc;
		private SchemaProperty foundSchema;

		public string Id { get; set; }
		public SchemaProperty SchemaProperty => this.foundSchema ?? (this.foundSchema = this.findSchemaPropertyFunc(this.Id));

		public SchemaPropertyReference(Func<object, SchemaProperty> findSchemaPropertyFunc)
		{
			this.findSchemaPropertyFunc = findSchemaPropertyFunc;
		}

		public override string ToString()
		{
			return $"id: {this.Id}";
		}
	}


	public sealed class SchemaReference
	{
		private readonly Func<object, Schema> findSchemaFunc;
		private Schema foundSchema;

		public string Id { get; set; }
		public Schema Schema => this.foundSchema ?? (this.foundSchema = this.findSchemaFunc(this.Id));

		public SchemaReference(Func<object, Schema> findSchemaFunc)
		{
			this.findSchemaFunc = findSchemaFunc;
		}

		public override string ToString()
		{
			return $"id: {this.Id}";
		}
	}


	public enum SchemaType
	{
		Normal = 0,
		Component = 1,
		Settings = 2,
		Union = 3,
	}


	public class SpecificationDictionary
	{
		private static readonly Dictionary<string, string> EmptyPickListValues = new Dictionary<string, string>();
		private static readonly List<KeyValuePair<string, string>> EmptyFormulaParameters = new List<KeyValuePair<string, string>>();
		private static readonly char[] MultiPickListSeparators = new char[] { ',', ' ', ';', '|' };

		public const char PairSeparator = '&';
		public const char NameValueSeparator = '=';

		private readonly Dictionary<string, List<string>> values;
		private readonly Dictionary<string, string> pickListValues;
		private readonly List<KeyValuePair<string, string>> formulaParameters;

		public bool IsPickList => this.pickListValues != null;

		public bool HasCustomTypeName => this.values.ContainsKey("typeName") && this.values["typeName"].Count > 0 && string.IsNullOrEmpty(this.values["typeName"].FirstOrDefault()) == false;
		public string CustomTypeName => this.HasCustomTypeName ? this.values["typeName"].FirstOrDefault() : string.Empty;

		public SpecificationDictionary()
		{
			this.values = new Dictionary<string, List<string>>();
		}
		public SpecificationDictionary(string specification)
			: this()
		{
			if (specification == null) throw new ArgumentNullException(nameof(specification));

			foreach (var pair in specification.Split(new char[] { PairSeparator }, StringSplitOptions.RemoveEmptyEntries))
			{
				var sepIdx = pair.IndexOf('=');
				if (sepIdx < 0) continue;

				var key = Uri.UnescapeDataString(pair.Substring(0, sepIdx));
				var value = Uri.UnescapeDataString(pair.Substring(sepIdx + 1));

				if (key.StartsWith("pick.", StringComparison.Ordinal))
				{
					var pickName = key.Substring(5);
					if (this.pickListValues == null) this.pickListValues = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
					if (value.Length > 0 && long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var pickValue))
					{
						this.pickListValues[pickName] = value;
					}
					continue;
				}
				if (key.StartsWith("param.", StringComparison.Ordinal))
				{
					var paramName = key.Substring(6);
					if (this.formulaParameters == null) this.formulaParameters = new List<KeyValuePair<string, string>>();
					this.formulaParameters.Add(new KeyValuePair<string, string>(paramName, value));
					continue;
				}

				if (this.values.TryGetValue(key, out var list) == false)
					this.values[key] = list = new List<string>();
				list.Add(value);
			}
		}

		public List<string> GetValues(string key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			if (this.values.TryGetValue(key, out var list) == false)
				this.values[key] = list = new List<string>();
			return list;
		}

		public List<string> GetSourceCodeAttributes(TargetSourceCodeLanguage sourceCodeLanguage)
		{
			switch (sourceCodeLanguage)
			{
				case TargetSourceCodeLanguage.CSharp: return this.GetValues("csAttribute");
				case TargetSourceCodeLanguage.TypeScript: return this.GetValues("tsAttribute");
				case TargetSourceCodeLanguage.UeCpp: return this.GetValues("uecppAttribute");
				case TargetSourceCodeLanguage.Haxe: return this.GetValues("haxeAttribute");
				case TargetSourceCodeLanguage.Cpp:
				case TargetSourceCodeLanguage.Rust:
				case TargetSourceCodeLanguage.Lua: return new List<string>();
				default: throw new ArgumentOutOfRangeException(nameof(sourceCodeLanguage), sourceCodeLanguage, null);
			}
		}
		public List<string> GetSourceCodeBaseType(TargetSourceCodeLanguage sourceCodeLanguage)
		{
			switch (sourceCodeLanguage)
			{
				case TargetSourceCodeLanguage.CSharp: return this.GetValues("csBaseType");
				case TargetSourceCodeLanguage.TypeScript: return this.GetValues("tsBaseType");
				case TargetSourceCodeLanguage.UeCpp: return this.GetValues("uecppBaseType");
				case TargetSourceCodeLanguage.Haxe: return this.GetValues("haxeBaseType");
				case TargetSourceCodeLanguage.Cpp:
				case TargetSourceCodeLanguage.Rust:
				case TargetSourceCodeLanguage.Lua: return new List<string>();
				default: throw new ArgumentOutOfRangeException(nameof(sourceCodeLanguage), sourceCodeLanguage, null);
			}
		}
		public string GetEditor()
		{
			return this.GetValues("editor").FirstOrDefault();
		}
		public Dictionary<string, string> GetPickListValues()
		{
			return this.pickListValues ?? EmptyPickListValues;
		}
		public List<KeyValuePair<string, string>> GetFormulaParameters()
		{
			return this.formulaParameters ?? EmptyFormulaParameters;
		}
		public string GetFormulaResultType()
		{
			var resultType = default(string);
			if (this.values.TryGetValue("resultType", out var resultTypes) || this.values.TryGetValue("result", out resultTypes))
				resultType = resultTypes.FirstOrDefault();

			if (string.IsNullOrEmpty(resultType))
			{
				return null;
			}
			return resultType;
		}
		public List<string> GetKnownTypes()
		{
			if (this.values.TryGetValue("knownType", out var knownTypes))
				return knownTypes;
			else
				return new List<string>();
		}
	}


	public enum TargetSourceCodeLanguage
	{
		CSharp = 1,
		TypeScript = 2,
		UeCpp = 3,
		Haxe = 4,
		Cpp = 5,
		Rust = 6,
		Lua = 7,
	}


	public enum Uniqueness
	{
		None = 0,
		Unique = 1,
		UniqueInContainer = 2,
	}


	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	[Obsolete("Left for backward compatibility. Use GameDataFormat instead.")]
	public static class Format
	{
		public static readonly GameDataFormat Json = GameDataFormat.Json;
		public static readonly GameDataFormat MessagePack = GameDataFormat.MessagePack;
	}


	public enum GameDataFormat
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public GameDataFormat Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = GameDataFormat.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public class GameDataObjectReader : GameDataReader
	{
		private ReaderFrame[] frames;
		private int topFrameIndex;
		private ReaderToken token;
		private bool boolValue;
		private long integerValue;
		private double numberValue;
		private string stringValue;
		private object objectValue;
		private ArraySegment<byte> bytesValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		/// <inheritdoc />
		public override bool ValueAsBoolean => this.boolValue;
		/// <inheritdoc />
		public override long ValueAsInteger => this.integerValue;
		/// <inheritdoc />
		public override double ValueAsNumber => this.numberValue;
		/// <inheritdoc />
		public override string ValueAsString => this.stringValue;
		/// <inheritdoc />
		public override DateTime ValueAsDateTime => this.GetValueAsDateTime();
		/// <inheritdoc />
		public override TimeSpan ValueAsTimeSpan => this.GetValueAsTimeSpan();
		/// <inheritdoc />
		public override ArraySegment<byte> ValueAsBytes => this.bytesValue;
		/// <inheritdoc />
		public override object Value => this.GetValue();

		/// <inheritdoc />
		public override int LineNumber => 0;
		/// <inheritdoc />
		public override int ColumnNumber => 0;

		public GameDataObjectReader(IReadOnlyDictionary<string, object> gameDataPatch)
		{
			this.frames = new ReaderFrame[10];
			this.topFrameIndex = -1;
			this.PushFrame(gameDataPatch);
			this.topFrameIndex = int.MinValue;
			this.token = ReaderToken.None;
			this.boolValue= false;
			this.integerValue= 0;
			this.numberValue= 0;
			this.stringValue= null;
			this.objectValue = null;
			this.bytesValue = new ArraySegment<byte>(Array.Empty<byte>());
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			this.integerValue = 0;
			this.numberValue = 0;
			this.stringValue = null;
			this.objectValue = null;

			if (this.topFrameIndex == int.MinValue)
			{
				this.topFrameIndex = 0;
				this.token = this.frames[this.topFrameIndex].ContainerType;
				return true;
			}

			while (this.topFrameIndex >= 0)
			{
				var nextToken = ReaderFrame.GetState(ref this.frames[this.topFrameIndex]);
				switch (nextToken)
				{
					case ReaderToken.Member:
						var memberName = this.frames[this.topFrameIndex].MemberName;
						this.token = nextToken;
						this.SetValue(memberName);
						return true;
					case ReaderToken.Bytes:
					case ReaderToken.Integer:
					case ReaderToken.Number:
					case ReaderToken.Boolean:
					case ReaderToken.String:
						this.token = nextToken;
						this.SetValue(this.frames[this.topFrameIndex].Current);
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						return true;
					case ReaderToken.EndOfObject:
					case ReaderToken.EndOfArray:
						this.PopFrame();
						this.token = nextToken;
						return true;
					case ReaderToken.BeginObject:
						var dictionary = (IReadOnlyDictionary<string, object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(dictionary);
						this.token = nextToken;
						return true;
					case ReaderToken.BeginArray:
						var list = (IReadOnlyList<object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(list);
						this.token = nextToken;
						return true;
					case ReaderToken.Null:
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.token = nextToken;
						return true;
				}
			}

			return false;
		}

		private TimeSpan GetValueAsTimeSpan()
		{
			if (this.objectValue is TimeSpan timeSpan)
			{
				return timeSpan;
			}
			return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
		}
		private DateTime GetValueAsDateTime()
		{
			if (this.objectValue is DateTime dateTime)
			{
				return dateTime;
			}
			return DateTime.ParseExact(this.ValueAsString, DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind);
		}

		private void PushFrame(IReadOnlyDictionary<string, object> dictionary)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(dictionary);
		}
		private void PushFrame(IReadOnlyList<object> list)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(list);
		}
		private void PopFrame()
		{
			this.frames[this.topFrameIndex] = default;
			this.topFrameIndex--;
		}

		private object GetValue()
		{
			switch (this.token)
			{
				case ReaderToken.Null: return null;
				case ReaderToken.Member:
				case ReaderToken.String: return this.objectValue ?? this.stringValue;
				case ReaderToken.Integer: return this.integerValue;
				case ReaderToken.Number: return this.numberValue;
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.bytesValue;
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default:
					throw ReaderException.UnexpectedToken(this, this.token,
						new[] {
							ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes
						});
			}
		}
		private void SetValue(object value)
		{
			this.integerValue = 0;
			this.numberValue = 0;
			this.stringValue = null;
			this.objectValue = null;

			switch (value)
			{
				case null: return;
				case string stringValue: this.stringValue = stringValue; break;
				case sbyte sbyteValue: this.integerValue = sbyteValue; break;
				case byte byteValue: this.integerValue = byteValue; break;
				case short shortValue: this.integerValue = shortValue; break;
				case ushort ushortValue: this.integerValue = ushortValue; break;
				case int intValue: this.integerValue = intValue; break;
				case uint uintValue: this.integerValue = uintValue; break;
				case long longValue: this.integerValue = longValue; break;
				case ulong ulongValue: this.integerValue = unchecked((long)ulongValue); break;
				case float floatValue: this.numberValue = floatValue; break;
				case double doubleValue: this.numberValue = doubleValue; break;
				case decimal decimalValue: this.numberValue = (double)decimalValue; break;
				case bool boolValue: this.boolValue = boolValue; break;
				case ArraySegment<byte> bytes: this.bytesValue = bytes; break;
				default:
					this.objectValue = value;
					this.stringValue = Convert.ToString(value, CultureInfo.InvariantCulture);
					break;
			}
		}

		/// <inheritdoc />
		public override void Dispose()
		{
			Array.Clear(this.frames, 0, this.frames.Length);
			this.topFrameIndex = -1;
		}

		private struct ReaderFrame
		{
			private bool memberNameVisited;
			private int currentIndex;
			private readonly IReadOnlyList<object> list;
			private readonly IndexedDictionary<string, object> dictionary;

			public string MemberName => this.dictionary?.Keys[this.currentIndex];
			public object Current => this.list != null ? this.list[this.currentIndex] : this.dictionary?[this.dictionary.Keys[this.currentIndex]];
			public ReaderToken ContainerType => this.list != null ? ReaderToken.BeginArray : this.dictionary != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
			private bool IsInBounds => this.currentIndex < (this.list?.Count ?? (this.dictionary?.Count ?? 0));

			public ReaderFrame(IReadOnlyList<object> list)
			{
				if (list == null) throw new ArgumentNullException(nameof(list));

				this.dictionary = default;
				this.list = list;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}
			public ReaderFrame(IReadOnlyDictionary<string, object> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary as IndexedDictionary<string, object> ?? new IndexedDictionary<string, object>(dictionary);
				this.list = default;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}

			public static void Next(ref ReaderFrame readerFrame)
			{
				readerFrame.currentIndex++;
				readerFrame.memberNameVisited = false;
			}
			public static ReaderToken GetState(ref ReaderFrame readerFrame)
			{
				var isObjectIteration = readerFrame.dictionary != null;
				if (!readerFrame.IsInBounds)
				{
					return isObjectIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
				}

				if (isObjectIteration && !readerFrame.memberNameVisited)
				{
					readerFrame.memberNameVisited = true;
					return ReaderToken.Member;
				}

				readerFrame.memberNameVisited = false;
				var currentObject = readerFrame.Current;
				switch (currentObject)
				{
					case IReadOnlyDictionary<string, object> _:
						return ReaderToken.BeginObject;
					case IReadOnlyList<object> _:
						return ReaderToken.BeginArray;
					case null:
						return ReaderToken.Null;
					case string _:
						return ReaderToken.String;
					case sbyte _:
					case byte _:
					case short _:
					case ushort _:
					case int _:
					case uint _:
					case long _:
					case ulong _:
						return ReaderToken.Integer;
					case float _:
					case double _:
					case decimal _:
						return ReaderToken.Number;
					case bool _:
						return ReaderToken.Boolean;
					case ArraySegment<byte> _:
						return ReaderToken.Bytes;
					default:
						return ReaderToken.String;
				}
			}
		}
	}


	public interface ILineInfo
	{
		int LineNumber { get; }
		int ColumnNumber { get; }
	}

	public abstract partial class GameDataReader : IDisposable, ILineInfo
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderToken Token { get; }

		public abstract long ValueAsInteger { get; }
		public abstract double ValueAsNumber { get; }
		public abstract ArraySegment<byte> ValueAsBytes { get; }
		public abstract bool ValueAsBoolean { get; }
		public abstract string ValueAsString { get; }
		public abstract object Value { get; }

		// ReSharper disable SwitchStatementHandlesSomeKnownEnumValuesWithDefault
		public virtual float ValueAsSingle
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((float)this.ValueAsInteger);
					case ReaderToken.Number: return checked((float)this.ValueAsNumber);
					case ReaderToken.String: return float.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual double ValueAsDouble
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((double)this.ValueAsInteger);
					case ReaderToken.Number: return checked((double)this.ValueAsNumber);
					case ReaderToken.String: return double.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual sbyte ValueAsSByte
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((sbyte)this.ValueAsInteger);
					case ReaderToken.Number: return checked((sbyte)this.ValueAsNumber);
					case ReaderToken.String: return sbyte.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual byte ValueAsByte
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((byte)this.ValueAsInteger);
					case ReaderToken.Number: return checked((byte)this.ValueAsNumber);
					case ReaderToken.String: return byte.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual short ValueAsInt16
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((short)this.ValueAsInteger);
					case ReaderToken.Number: return checked((short)this.ValueAsNumber);
					case ReaderToken.String: return short.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual ushort ValueAsUInt16
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((ushort)this.ValueAsInteger);
					case ReaderToken.Number: return checked((ushort)this.ValueAsNumber);
					case ReaderToken.String: return ushort.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual int ValueAsInt32
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((int)this.ValueAsInteger);
					case ReaderToken.Number: return checked((int)this.ValueAsNumber);
					case ReaderToken.String: return int.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual uint ValueAsUInt32
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((uint)this.ValueAsInteger);
					case ReaderToken.Number: return checked((uint)this.ValueAsNumber);
					case ReaderToken.String: return uint.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual long ValueAsInt64
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((long)this.ValueAsInteger);
					case ReaderToken.Number: return checked((long)this.ValueAsNumber);
					case ReaderToken.String: return long.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual ulong ValueAsUInt64
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return unchecked((ulong)this.ValueAsInteger);
					case ReaderToken.Number: return checked((ulong)this.ValueAsNumber);
					case ReaderToken.String: return ulong.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}

		public virtual DateTime ValueAsDateTime
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.String:
						return DateTime.ParseExact(this.ValueAsString, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture,
							DateTimeStyles.RoundtripKind);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual TimeSpan ValueAsTimeSpan
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.String: return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}

		// ReSharper restore SwitchStatementHandlesSomeKnownEnumValuesWithDefault

		public bool HasValue => this.Token == ReaderToken.Member ||
			this.Token == ReaderToken.Null ||
			this.Token == ReaderToken.Boolean ||
			this.Token == ReaderToken.Integer ||
			this.Token == ReaderToken.Number ||
			this.Token == ReaderToken.Bytes ||
			this.Token == ReaderToken.String;

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (!this.HasValue)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, new[] {
					ReaderToken.Member, ReaderToken.Null, ReaderToken.Boolean, ReaderToken.Integer,
					ReaderToken.Number, ReaderToken.Bytes, ReaderToken.String
				});
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(this, expected, propertyName, schemaName);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			switch (this.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null:
					if (nextToken) this.NextToken();
					return null;
				case ReaderToken.Number:
					var numberValue = this.ValueAsNumber;
					if (nextToken) this.NextToken();
					return numberValue;
				case ReaderToken.Boolean:
					var boolValue = this.ValueAsBoolean;
					if (nextToken) this.NextToken();
					return boolValue;
				case ReaderToken.Integer:
					var intValue = this.ValueAsInteger;
					if (nextToken) this.NextToken();
					return intValue;
				case ReaderToken.String:
					var strValue = this.ValueAsString;
					if (nextToken) this.NextToken();
					return strValue;
				case ReaderToken.Bytes:
					var objValue = this.ValueAsBytes;
					if (nextToken) this.NextToken();
					return objValue;
				case ReaderToken.None:
				case ReaderToken.Member:
				case ReaderToken.EndOfArray:
				case ReaderToken.EndOfObject:
				case ReaderToken.EndOfStream:
				default:
					throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Number,
						ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while (this.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}

			this.ReadArrayEnd(nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while (this.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}

			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			switch (this.Token)
			{
				case ReaderToken.BeginArray:
					this.SkipArray(nextToken);
					break;
				case ReaderToken.BeginObject:
					this.SkipObject(nextToken);
					break;
				case ReaderToken.Member:
				case ReaderToken.String:
				case ReaderToken.Integer:
				case ReaderToken.Number:
				case ReaderToken.Boolean:
				case ReaderToken.Bytes:
				case ReaderToken.Null:
					if (nextToken) this.NextToken();
					break;
				case ReaderToken.None:
				case ReaderToken.EndOfArray:
				case ReaderToken.EndOfObject:
				case ReaderToken.EndOfStream:
				default:
					throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Number,
						ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while (this.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}

			this.ReadArrayEnd(nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while (this.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}

			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Token != ReaderToken.Member && this.Token != ReaderToken.String)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.Member, ReaderToken.String);
			}

			var memberName = this.ValueAsString;
			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Token, CultureInfo.InvariantCulture) +
					(this.HasValue ? "[" + Convert.ToString(this.Value, CultureInfo.InvariantCulture) + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Token == ReaderToken.EndOfObject || this.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Token == ReaderToken.EndOfObject || this.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}

				if (this.Token == ReaderToken.BeginObject || this.Token == ReaderToken.BeginArray || this.Token == ReaderToken.Member)
				{
					stack.Push(this.Token);
				}
			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return Convert.ToString(this.Token, CultureInfo.InvariantCulture) +
				(this.HasValue ? "[" + Convert.ToString(this.Value, CultureInfo.InvariantCulture) + "]" : "");
		}
	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int LEXER_STATE_COMPLETE = -1;
		private const int LEXER_STATE_START = 0;
		private const int LEXER_STATE_LEXEME = 1;
		private const int LEXER_STATE_QUOTED = 2;
		private const int LEXER_STATE_QUOTED_ESCAPE = 3;
		private const int LEXER_STATE_COMMENT_BEGINNING = 4;
		private const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		private const int LEXER_STATE_COMMENT_MULTILINE = 6;
		private const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly char[] charBuffer;
		private readonly Stack<ReaderToken> structure;
		private readonly Dictionary<ulong, string> stringPool;
		private readonly bool useStringPooling;
		private readonly Decoder utf8Decoder;

		private int bufferOffset;
		private int bufferAvailable;
		private int columnNumber;
		private int lineNumber;
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		private byte[] binaryBuffer;
#endif
		private ReaderToken token;
		private bool boolValue;
		private ArraySegment<byte> rawJsonValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		public override ArraySegment<byte> ValueAsBytes => this.ReadJsonAsBase64();

		public override bool ValueAsBoolean => this.boolValue;
		public override double ValueAsNumber => this.ReadJsonAsNumber();
		public override long ValueAsInteger => this.ReadJsonAsInteger();
		public override string ValueAsString => this.ReadJsonAsString();
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		public override DateTime ValueAsDateTime => this.ReadJsonAsDateTime();
		public override TimeSpan ValueAsTimeSpan => this.ReadJsonAsTimeSpan();
#endif
		public override object Value => this.BoxAnyValue();

		public override int LineNumber => this.lineNumber;
		public override int ColumnNumber => this.columnNumber;

		public JsonGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE, bool useStringPooling = false)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
			{
				bufferSize = DEFAULT_BUFFER_SIZE;
			}

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.useStringPooling = useStringPooling;
			this.buffer = new byte[bufferSize];
			this.charBuffer = new char[bufferSize / 2];
			this.bufferOffset = 0;
			this.bufferAvailable = 0;
			this.lineNumber = 1;
			this.structure = new Stack<ReaderToken>();
			this.stringPool = new Dictionary<ulong, string>();
			this.token = ReaderToken.None;
			this.boolValue = false;
			this.rawJsonValue = new ArraySegment<byte>(Array.Empty<byte>());
			this.utf8Decoder = Encoding.UTF8.GetDecoder();
		}

		public override bool NextToken()
		{
			var nextStringTokenType = ReaderToken.String;
			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(nextStringTokenType = ReaderToken.Member);
						break;
				}
			}

			if (!this.NextLexeme())
			{
				return false;
			}

			var rawJsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
			var rawJsonOffset = this.rawJsonValue.Offset;
			var rawJsonLength = this.rawJsonValue.Count;
			if (rawJsonLength == 1)
			{
				var oneCharNotation = rawJsonArray[rawJsonOffset];
				switch (oneCharNotation)
				{
					case JsonNotation.BEGIN_ARRAY_CHAR_CODE:
						this.token = ReaderToken.BeginArray;
						this.structure.Push(ReaderToken.BeginArray);
						return true;
					case JsonNotation.END_ARRAY_CHAR_CODE:
						this.token = ReaderToken.EndOfArray;
						this.PopStructureToken();
						return true;
					case JsonNotation.BEGIN_OBJECT_CHAR_CODE:
						this.token = ReaderToken.BeginObject;
						this.structure.Push(ReaderToken.BeginObject);
						return true;
					case JsonNotation.END_OBJECT_CHAR_CODE:
						this.token = ReaderToken.EndOfObject;
						this.PopStructureToken();
						return true;
					default:
						if (oneCharNotation >= JsonNotation.ZERO_CHAR_CODE && oneCharNotation <= JsonNotation.NINE_CHAR_CODE)
						{
							this.token = ReaderToken.Integer;
							return true;
						}

						throw ReaderException.UnknownNotation(this, ((char)oneCharNotation).ToString());
				}
			}
			else if (rawJsonLength == 4 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.Null))
			{
				this.token = ReaderToken.Null;
				return true;
			}
			else if (rawJsonLength == 4 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.True))
			{
				this.token = ReaderToken.Boolean;
				this.boolValue = true;
				return true;
			}
			else if (rawJsonLength == 5 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.False))
			{
				this.token = ReaderToken.Boolean;
				this.boolValue = false;
				return true;
			}

			if (rawJsonLength > 0 && rawJsonArray[rawJsonOffset] == JsonNotation.QUOTE_CHAR_CODE)
			{
				if (rawJsonArray[rawJsonOffset + rawJsonLength - 1] != JsonNotation.QUOTE_CHAR_CODE)
				{
					throw ReaderException.UnterminatedStringLiteral(this);
				}

				// remove quotes
				this.rawJsonValue = new ArraySegment<byte>(this.rawJsonValue.Array ?? this.buffer, this.rawJsonValue.Offset + 1, this.rawJsonValue.Count - 2);

				this.token = nextStringTokenType;
				return true;
			}

			switch (this.GetNumberType())
			{
				case NumberType.Integer:
					this.token = ReaderToken.Integer;
					return true;
				case NumberType.Number:
					this.token = ReaderToken.Number;
					return true;
				case NumberType.NotANumber:
				default:
					throw ReaderException.UnknownNotation(this, this.ReadJsonAsString());
			}
		}

		private bool NextLexeme()
		{
			var state = LEXER_STATE_COMPLETE;

			var lexemeStart = -1;
			var buffer = this.buffer;
			var bufferOffset = this.bufferOffset;
			var bufferAvailable = this.bufferAvailable;

			while (true)
			{
				this.columnNumber++;

				if (state == LEXER_STATE_COMPLETE)
				{
					state = LEXER_STATE_START;
				}

				if (bufferAvailable == 0)
				{
					if (!this.TryFillBuffer(ref lexemeStart, ref bufferOffset, ref bufferAvailable))
					{
						return false; // end of stream
					}
				}

				var charCode = buffer[bufferOffset];
				bufferAvailable--;
				bufferOffset++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (charCode)
						{
							case JsonNotation.NEWLINE_CHAR_CODE:
								this.lineNumber++;
								this.columnNumber = 0;
								break;
							case JsonNotation.SPACE_CHAR_CODE:
							case JsonNotation.RETURN_CHAR_CODE:
							case JsonNotation.TAB_CHAR_CODE:
							case JsonNotation.IDENTIFIER_SEPARATOR_CHAR_CODE:
								continue; // insignificant whitespaces
							case JsonNotation.VALUE_SEPARATOR_CHAR_CODE:
							{
								if (this.structure.Count == 0 || this.structure.Peek() == ReaderToken.BeginObject)
								{
									throw ReaderException.ReadingBrokenDocument(this, "A value is expected");
								}

								break;
							}
							case JsonNotation.COMMENT_CHAR_CODE:
								state = LEXER_STATE_COMMENT_BEGINNING;
								break;
							case JsonNotation.END_ARRAY_CHAR_CODE:
							case JsonNotation.BEGIN_ARRAY_CHAR_CODE:
							case JsonNotation.END_OBJECT_CHAR_CODE:
							case JsonNotation.BEGIN_OBJECT_CHAR_CODE:
								this.rawJsonValue = new ArraySegment<byte>(buffer, bufferOffset - 1, 1);
								this.bufferOffset = bufferOffset;
								this.bufferAvailable = bufferAvailable;
								return true;
							default:
							{
								if (IsWhiteSpace(charCode))
								{
									continue;
								}

								lexemeStart = bufferOffset - 1;
								state = charCode == JsonNotation.QUOTE_CHAR_CODE ? LEXER_STATE_QUOTED : LEXER_STATE_LEXEME;
								break;
							}
						}

						break;
					case LEXER_STATE_LEXEME:
						if (IsLexemeTerminator(charCode))
						{
							bufferOffset--;
							bufferAvailable++;

							this.rawJsonValue = new ArraySegment<byte>(buffer, lexemeStart, bufferOffset - lexemeStart);
							this.bufferOffset = bufferOffset;
							this.bufferAvailable = bufferAvailable;
							return true;
						}
						else
						{
							continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (charCode)
						{
							case JsonNotation.NEWLINE_CHAR_CODE:
							case JsonNotation.RETURN_CHAR_CODE:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.QUOTE_CHAR_CODE:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									break;
								}
								else
								{
									this.rawJsonValue = new ArraySegment<byte>(buffer, lexemeStart, bufferOffset - lexemeStart);
									this.bufferOffset = bufferOffset;
									this.bufferAvailable = bufferAvailable;
									return true;
								}
							case JsonNotation.ESCAPE_CHAR_CODE:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								break;
							default:
								state = LEXER_STATE_QUOTED;
								break;
						}

						break;
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (charCode)
						{
							case JsonNotation.COMMENT_CHAR_CODE:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								break;
							case JsonNotation.COMMENT_MULTILINE_CHAR_CODE:
								state = LEXER_STATE_COMMENT_MULTILINE;
								break;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.COMMENT + "\\u" + (char)charCode);
						}

						break;
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						if (charCode == JsonNotation.NEWLINE_CHAR_CODE || charCode == JsonNotation.RETURN_CHAR_CODE)
						{
							state = LEXER_STATE_START; // skip comment, start over again
						}

						break;
					case LEXER_STATE_COMMENT_MULTILINE:
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
						switch (charCode)
						{
							case JsonNotation.COMMENT_MULTILINE_CHAR_CODE:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								break;
							case JsonNotation.COMMENT_CHAR_CODE:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
								{
									state = LEXER_STATE_START; // skip comment, start over again
								}

								break;
						}

						break;
				}
			}
		}

		private bool TryFillBuffer(ref int lexemeStart, ref int bufferOffset, ref int bufferAvailable)
		{
			if (lexemeStart + bufferOffset > 0)
			{
				if (lexemeStart >= 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStart, this.buffer, 0, bufferAvailable + bufferOffset - lexemeStart);
					bufferOffset -= lexemeStart;
					lexemeStart = 0;
				}
				else
				{
					bufferOffset = 0;
				}
			}

			var readOffset = bufferOffset + bufferAvailable;
			var toRead = this.buffer.Length - readOffset;

			if (toRead == 0)
			{
				throw ReaderException.StringLiteralIsTooLong(this, (ulong)this.buffer.Length, this.charBuffer.Length);
			}

			var read = this.inputStream.Read(this.buffer, readOffset, toRead);
			bufferAvailable += read;

			return read > 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsWhiteSpace(byte charCode)
		{
			return charCode < JsonNotation.WhitespaceChars.Length && JsonNotation.WhitespaceChars[charCode];
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsLexemeTerminator(byte charCode)
		{
			return charCode < JsonNotation.LexemeTerminatorChars.Length && JsonNotation.LexemeTerminatorChars[charCode];
		}

		private object BoxAnyValue()
		{
			switch (this.token)
			{
				case ReaderToken.Null: return null;
				case ReaderToken.String:
				case ReaderToken.Member: return this.ReadJsonAsString();
				case ReaderToken.Integer: return this.ReadJsonAsInteger();
				case ReaderToken.Number: return this.ReadJsonAsNumber();
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.ReadJsonAsBase64();
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default:
					throw ReaderException.UnexpectedToken(this, this.token,
						new[] {
							ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes
						});
			}
		}

		private string ReadJsonAsString()
		{
			if (this.rawJsonValue.Count == 0)
			{
				return string.Empty;
			}
			else if (this.rawJsonValue.Count <= 8 && this.useStringPooling)
			{
				var stringCacheKey = 0UL;
				var rawJsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
				var end = this.rawJsonValue.Offset + this.rawJsonValue.Count;
				for (var offset = this.rawJsonValue.Offset; offset < end; offset++)
				{
					var charCode = rawJsonArray[offset];
					stringCacheKey = stringCacheKey << 8 | charCode;
				}

				if (this.stringPool.TryGetValue(stringCacheKey, out var stringValue))
				{
					return stringValue;
				}
				else
				{
					var chars = this.ReadJsonAsChars();
					return this.stringPool[stringCacheKey] = stringValue = new string(chars.Array ?? this.charBuffer, chars.Offset, chars.Count);
				}
			}
			else
			{
				var chars = this.ReadJsonAsChars();
				return new string(chars.Array ?? this.charBuffer, chars.Offset, chars.Count);
			}
		}
		private ArraySegment<char> ReadJsonAsChars()
		{
			var jsonArray = this.rawJsonValue.Array;
			var offset = this.rawJsonValue.Offset;
			var count = this.rawJsonValue.Count;
			if (count == 0)
			{
				return new ArraySegment<char>(Array.Empty<char>());
			}

			if (jsonArray == null)
			{
				throw new InvalidOperationException("Unexpected raw json memory segment.");
			}

			this.utf8Decoder.Convert(jsonArray, offset, count, this.charBuffer, 0, this.charBuffer.Length, flush: true,
				out var bytesUsed, out var charsUsed, out var completed);

			if (!completed || bytesUsed != count)
			{
				throw new DecoderFallbackException("Failed to decode bytes as UTF-8 string.");
			}

			var stringLength = this.UnescapeStringInplace(this.charBuffer, charsUsed);

			return new ArraySegment<char>(this.charBuffer, 0, stringLength);
		}
		private ArraySegment<byte> ReadJsonAsBase64()
		{
			if (this.rawJsonValue.Count == 0)
			{
				return new ArraySegment<byte>(Array.Empty<byte>());
			}

#if !( NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL)
			var charsSegment = this.ReadJsonAsChars();
			if (charsSegment.Array == null)
			{
				throw new InvalidOperationException("Unexpected raw character memory segment.");
			}

			var bytes = Convert.FromBase64CharArray(charsSegment.Array, charsSegment.Offset, charsSegment.Count);
			return new ArraySegment<byte>(bytes);
#else
			var requiredSize = (this.rawJsonValue.Count + 3) / 4 * 3;
			if (this.binaryBuffer == null || this.binaryBuffer.Length < requiredSize)
			{
				this.binaryBuffer = new byte[Math.Max(this.buffer.Length, requiredSize)];
			}
			var result = System.Buffers.Text.Base64.DecodeFromUtf8(this.rawJsonValue.AsSpan(), this.binaryBuffer, out _, out var bytesWritten);
			if (result != System.Buffers.OperationStatus.Done)
			{
				throw new DecoderFallbackException("Failed to decode bytes as Base64 bytes.");
			}
			return new ArraySegment<byte>(this.binaryBuffer, 0, bytesWritten);
#endif
		}
		private double ReadJsonAsNumber()
		{
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out double value, out _))
			{
				return value;
			}
#endif
			return double.Parse(this.ReadJsonAsString(), CultureInfo.InvariantCulture);
		}
		private long ReadJsonAsInteger()
		{
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out long value, out _))
			{
				return value;
			}
#endif
			if (this.rawJsonValue.Count == 0)
			{
				throw new FormatException("Invalid integer value '' (empty string).");
			}
			else if (this.rawJsonValue.Count < 17)
			{
				// this algorithm is bad at Int64.MaxValue border
				return this.ParseInt64(this.rawJsonValue);
			}
			else
			{
				return long.Parse(this.ValueAsString, NumberStyles.Integer, CultureInfo.InvariantCulture);
			}
		}
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		private DateTime ReadJsonAsDateTime()
		{
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out DateTime dateTime, out _, 'O'))
			{
				return dateTime;
			}
			return DateTime.ParseExact(this.ValueAsString, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture,
				DateTimeStyles.RoundtripKind);
		}
		private TimeSpan ReadJsonAsTimeSpan()
		{
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out TimeSpan timeSpan, out _))
			{
				return timeSpan;
			}
			return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
		}
#endif

		private int UnescapeStringInplace(char[] charBuffer, int length)
		{
			var writeOffset = 0;
			for (var readOffset = 0; readOffset < length; readOffset++, writeOffset++)
			{
				if (charBuffer[readOffset] == JsonNotation.ESCAPE_CHAR_CODE)
				{
					if (readOffset + 1 >= length)
					{
						throw ReaderException.UnknownEscapeSequence(this, "\0");
					}

					switch (charBuffer[readOffset + 1])
					{
						case 'n':
							charBuffer[writeOffset] = JsonNotation.NEWLINE;
							readOffset++;
							break;
						case 'r':
							charBuffer[writeOffset] = JsonNotation.RETURN;
							readOffset++;
							break;
						case 'b':
							charBuffer[writeOffset] = '\b';
							readOffset++;
							break;
						case 'f':
							charBuffer[writeOffset] = '\f';
							readOffset++;
							break;
						case 't':
							charBuffer[writeOffset] = JsonNotation.TAB;
							readOffset++;
							break;
						case '"':
							charBuffer[writeOffset] = JsonNotation.QUOTE;
							readOffset++;
							break;
						case '\\':
							charBuffer[writeOffset] = JsonNotation.ESCAPE;
							readOffset++;
							break;
						case '/':
							charBuffer[writeOffset] = '/';
							readOffset++;
							break;
						case 'u':
							if (readOffset + 5 >= length)
							{
								throw ReaderException.UnknownEscapeSequence(this, new string(charBuffer, readOffset, charBuffer.Length - readOffset));
							}

							charBuffer[writeOffset] = checked((char)this.ParseIntHex(new ArraySegment<char>(charBuffer, readOffset + 2, 4)));
							readOffset += 5;
							break;
						default:
							throw ReaderException.UnknownEscapeSequence(this, new string(charBuffer, readOffset, 2));
					}
				}
				else
				{
					charBuffer[writeOffset] = charBuffer[readOffset];
				}
			}

			return writeOffset;
		}

		private bool SequenceEqual(byte[] firstArray, int firstOffset, byte[] secondArray)
		{
			if (firstArray.Length - firstOffset < secondArray.Length)
			{
				return false;
			}

			for (var index = 0; index < secondArray.Length; index++)
			{
				if (firstArray[firstOffset + index] != secondArray[index])
				{
					return false;
				}
			}

			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private long ParseIntHex(ArraySegment<char> hexSegment)
		{
			var result = 0L;
			var hexChars = hexSegment.Array ?? Array.Empty<char>();
			var end = hexSegment.Offset + hexSegment.Count;
			for (var offset = hexSegment.Offset; offset < end; offset++)
			{
				var hexChar = hexChars[offset];
				var hexCharCode = (long)hexChar;
				var hexDigit = 0L;
				if (hexCharCode >= JsonNotation.ZERO_CHAR_CODE && hexCharCode <= JsonNotation.NINE_CHAR_CODE)
				{
					hexDigit = (hexCharCode - JsonNotation.ZERO_CHAR_CODE);
				}
				else if (hexCharCode >= JsonNotation.A_LOWER_CASE_CHAR_CODE && hexCharCode <= JsonNotation.F_LOWER_CASE_CHAR_CODE)
				{
					hexDigit = 10 + (hexCharCode - JsonNotation.A_LOWER_CASE_CHAR_CODE);
				}
				else if (hexCharCode >= JsonNotation.A_UPPER_CASE_CHAR_CODE && hexCharCode <= JsonNotation.F_UPPER_CASE_CHAR_CODE)
				{
					hexDigit = 10 + (hexCharCode - JsonNotation.A_UPPER_CASE_CHAR_CODE);
				}
				else
				{
					throw new FormatException($"Unknown HEX character {(char)hexCharCode}.");
				}

				result = 16L * result + hexDigit;
			}

			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private long ParseInt64(ArraySegment<byte> intSegment)
		{
			var result = 0L;
			var neg = false;
			var intChars = intSegment.Array ?? Array.Empty<byte>();
			var offset = intSegment.Offset;
			if (intChars[offset] == JsonNotation.MINUS_CHAR_CODE)
			{
				neg = true;
				offset++;
			}

			for (var end = intSegment.Offset + intSegment.Count; offset < end; offset++)
			{
				var digitChar = intChars[offset];
				if (digitChar < JsonNotation.ZERO_CHAR_CODE || digitChar > JsonNotation.NINE_CHAR_CODE)
				{
					throw new FormatException($"Invalid integer value '{Encoding.ASCII.GetString(intChars, intSegment.Offset, intSegment.Count)}'.");
				}

				result = checked(10L * result + (digitChar - JsonNotation.ZERO_CHAR_CODE));
			}

			return neg ? -result : result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void PopStructureToken()
		{
			if (this.structure.Count == 0)
			{
				throw ReaderException.UnexpectedToken(this, this.token, ReaderToken.EndOfStream);
			}
			else
			{
				this.structure.Pop();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private NumberType GetNumberType()
		{
			var offset = this.rawJsonValue.Offset;
			var jsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
			if (jsonArray.Length > 0 && jsonArray[offset] == JsonNotation.MINUS_CHAR_CODE)
			{
				offset++;
			}

			var numberType = NumberType.Integer;
			for (var end = this.rawJsonValue.Offset + this.rawJsonValue.Count; offset < end; offset++)
			{
				var charCode = jsonArray[offset];
				if (charCode >= JsonNotation.ZERO_CHAR_CODE && charCode <= JsonNotation.NINE_CHAR_CODE)
				{
					continue;
				}
				else if (charCode == JsonNotation.MINUS_CHAR_CODE ||
						charCode == JsonNotation.PLUS_CHAR_CODE ||
						charCode == JsonNotation.DOT_CHAR_CODE ||
						charCode == JsonNotation.E_UPPER_CASE_CHAR_CODE ||
						charCode == JsonNotation.E_LOWER_CASE_CHAR_CODE)
				{
					numberType = NumberType.Number;
				}
			}

			return numberType;
		}

		public static string EscapeString(string value, bool forUnicodeEncoding)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			var newSize = 0;
			for (var offset = 0; offset < value.Length; offset++)
			{
				var charCode = value[offset];
				var previousCharCode = offset > 0 ? value[offset - 1] : '\0';
				if (ShouldBeEscaped(charCode, previousCharCode, forUnicodeEncoding))
				{
					newSize += 6; // \u0000
				}
				else
				{
					newSize++;
				}
			}

			if (newSize == value.Length)
			{
				return value;
			}

			var newStringValue = new StringBuilder(newSize);
			for (var offset = 0; offset < value.Length; offset++)
			{
				var charCode = value[offset];
				var previousCharCode = offset > 0 ? value[offset - 1] : '\0';
				if (ShouldBeEscaped(charCode, previousCharCode, forUnicodeEncoding))
				{
					newStringValue.Append("\\u");
					UInt16ToPaddedHexBuffer(charCode, newStringValue);
				}
				else newStringValue.Append(charCode);
			}

			return newStringValue.ToString();
		}
		private static bool ShouldBeEscaped(ushort charCode, char prevCharCode, bool forUnicodeEncoding)
		{
			return

				// quote symbol
				charCode == '"' ||
				charCode == '\\' ||

				// non-latin symbol
				!forUnicodeEncoding && charCode > '~' ||

				// control symbol
				charCode < ' ' ||

				// surrogates
				(charCode >= '\uD800' && charCode <= '\uDBFF') ||
				(charCode >= '\uDC00' && charCode <= '\uDFFF') ||

				// JavaScript escape
				charCode == '\u2028' ||
				charCode == '\u2029' ||
				charCode == '/' && prevCharCode == '<';
		}
		private static void UInt16ToPaddedHexBuffer(ushort value, StringBuilder buffer)
		{
			var offset = buffer.Length;
			buffer.Append("0000");
			if (value == 0)
			{
				return;
			}

			const int LENGTH = 4;
			const string HEX = "0123456789ABCDEF";

			var end = offset + LENGTH;
			for (var i = 0; i < LENGTH; i++)
			{
				var hexChar = HEX[(int)((value >> (i * 4)) & 15u)];
				buffer[end - i - 1] = hexChar;
			}
		}

		public override void Dispose()
		{
			this.token = ReaderToken.None;
			Array.Clear(this.buffer, 0, this.buffer.Length);
			Array.Clear(this.charBuffer, 0, this.charBuffer.Length);
			this.structure.Clear();
			this.stringPool.Clear();
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			this.binaryBuffer = null;
#endif
			this.bufferOffset = 0;
			this.bufferAvailable = 0;
			this.boolValue = false;
			this.rawJsonValue = new ArraySegment<byte>(Array.Empty<byte>());

			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}

		private enum NumberType
		{
			Integer,
			Number,
			NotANumber
		}

		private static class JsonNotation
		{
			public const char TAB = '\t';
			public const int TAB_CHAR_CODE = 9;
			public const int SPACE_CHAR_CODE = 32;
			public const int NO_BREAK_SPACE_CHAR_CODE = 160;
			public const char NEWLINE = '\n';
			public const int NEWLINE_CHAR_CODE = 10;
			public const char RETURN = '\r';
			public const int RETURN_CHAR_CODE = 13;
			public const int IDENTIFIER_SEPARATOR_CHAR_CODE = 58;
			public const int VALUE_SEPARATOR_CHAR_CODE = 44;
			public const int BEGIN_ARRAY_CHAR_CODE = 91;
			public const int END_ARRAY_CHAR_CODE = 93;
			public const int BEGIN_OBJECT_CHAR_CODE = 123;
			public const int END_OBJECT_CHAR_CODE = 125;
			public const char ESCAPE = '\\';
			public const int ESCAPE_CHAR_CODE = 92;
			public const char COMMENT = '/';
			public const int COMMENT_CHAR_CODE = 47;
			public const int COMMENT_MULTILINE_CHAR_CODE = 42;
			public const char QUOTE = '\"';
			public const int QUOTE_CHAR_CODE = 34;

			public const int ZERO_CHAR_CODE = 48;
			public const int NINE_CHAR_CODE = 57;
			public const int A_LOWER_CASE_CHAR_CODE = 97;
			public const int A_UPPER_CASE_CHAR_CODE = 65;
			public const int F_LOWER_CASE_CHAR_CODE = 102;
			public const int F_UPPER_CASE_CHAR_CODE = 70;

			public const int MINUS_CHAR_CODE = 45;
			public const int PLUS_CHAR_CODE = 43;
			public const int DOT_CHAR_CODE = 46;
			public const int E_UPPER_CASE_CHAR_CODE = 69;
			public const int E_LOWER_CASE_CHAR_CODE = 101;

			public static readonly byte[] True = Encoding.ASCII.GetBytes("true");
			public static readonly byte[] False = Encoding.ASCII.GetBytes("false");
			public static readonly byte[] Null = Encoding.ASCII.GetBytes("null");

			public static readonly bool[] WhitespaceChars = Enumerable.Range(0, 180).Select(
				charCode => charCode == SPACE_CHAR_CODE ||
					(charCode >= TAB_CHAR_CODE && charCode <= RETURN_CHAR_CODE) ||
					(charCode == NO_BREAK_SPACE_CHAR_CODE)
			).ToArray();
			public static readonly bool[] LexemeTerminatorChars = Enumerable.Range(0, 180).Select(
				charCode => charCode == SPACE_CHAR_CODE ||
					(charCode >= TAB_CHAR_CODE && charCode <= RETURN_CHAR_CODE) ||
					charCode == NO_BREAK_SPACE_CHAR_CODE ||
					charCode == IDENTIFIER_SEPARATOR_CHAR_CODE ||
					charCode == VALUE_SEPARATOR_CHAR_CODE ||
					charCode == END_ARRAY_CHAR_CODE ||
					charCode == END_OBJECT_CHAR_CODE ||
					charCode == BEGIN_OBJECT_CHAR_CODE ||
					charCode == BEGIN_ARRAY_CHAR_CODE
			).ToArray();
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct CurrentStructureToken
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<CurrentStructureToken> structure;
		private readonly Dictionary<ulong, string> stringPool;
		private readonly bool useStringPooling;

		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private ReaderToken token;
		private string stringValue;
		private bool boolValue;
		private double numberValue;
		private long integerValue;
		private ArraySegment<byte> bytesValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		public override ArraySegment<byte> ValueAsBytes => this.bytesValue;
		public override bool ValueAsBoolean => this.boolValue;
		public override double ValueAsNumber => this.numberValue;
		public override long ValueAsInteger => this.integerValue;
		public override string ValueAsString => this.stringValue;
		public override object Value => this.BoxAnyValue();

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE, bool useStringPooling = false)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
			{
				bufferSize = DEFAULT_BUFFER_SIZE;
			}

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.useStringPooling = useStringPooling;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.structure = new Stack<CurrentStructureToken>();
			this.stringPool = new Dictionary<ulong, string>();
			this.token = ReaderToken.None;
			this.boolValue = false;
			this.numberValue = 0;
			this.integerValue = 0;
			this.stringValue = string.Empty;
		}
		public override bool NextToken()
		{
			if (this.structure.Count > 0 && this.structure.Peek().Counter == 0)
			{
				var closingToken = this.structure.Pop();
				this.token = closingToken.Token;

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.token = ReaderToken.EndOfStream;
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.token = ReaderToken.BeginArray;
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var closingToken = this.structure.Count > 0 ? this.structure.Peek() : new CurrentStructureToken();
				if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
				{
					this.token = ReaderToken.Member;
				}
				else
				{
					this.token = ReaderToken.String;
				}

				var strBytesCount = formatValue - (byte)MessagePackType.FixStrStart;
				this.stringValue = this.ReadString(strBytesCount);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.token = ReaderToken.BeginObject;
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.token = ReaderToken.Integer;
				this.integerValue = unchecked((sbyte)formatValue);
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.token = ReaderToken.Integer;
				this.integerValue = formatValue;
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.token = ReaderToken.Null;
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0U;
						switch (formatValue)
						{
							case (int)MessagePackType.Array16:
								this.ReadToBuffer(2, throwOnEos: true);
								arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Array32:
								this.ReadToBuffer(4, throwOnEos: true);
								arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}
						this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.token = ReaderToken.BeginArray;
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0U;
						switch (formatValue)
						{
							case (int)MessagePackType.Map16:
								this.ReadToBuffer(2, throwOnEos: true);
								mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Map32:
								this.ReadToBuffer(4, throwOnEos: true);
								mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.token = ReaderToken.BeginObject;
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.Str8:
								this.ReadToBuffer(1, throwOnEos: true);
								strBytesCount = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Str16:
								this.ReadToBuffer(2, throwOnEos: true);
								strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Str32:
								this.ReadToBuffer(4, throwOnEos: true);
								strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						var closingToken = this.structure.Count > 0 ? this.structure.Peek() : new CurrentStructureToken();
						if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						{
							this.token = ReaderToken.Member;
						}
						else
						{
							this.token = ReaderToken.String;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, strBytesCount, MAX_STRING_LENGTH);

						this.stringValue = this.ReadString(checked((int)strBytesCount));
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.Bin8:
								this.ReadToBuffer(1, throwOnEos: true);
								bytesCount = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Bin16:
								this.ReadToBuffer(2, throwOnEos: true);
								bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Bin32:
								this.ReadToBuffer(4, throwOnEos: true);
								bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, bytesCount, MAX_BINARY_LENGTH);

						this.token = ReaderToken.Bytes;
						this.bytesValue = this.ReadBytes(checked((int)bytesCount));
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.FixExt1:
								extLength = 1;
								break;
							case (int)MessagePackType.FixExt2:
								extLength = 2;
								break;
							case (int)MessagePackType.FixExt4:
								extLength = 4;
								break;
							case (int)MessagePackType.FixExt8:
								extLength = 8;
								break;
							case (int)MessagePackType.FixExt16:
								extLength = 16;
								break;
							case (int)MessagePackType.Ext8:
								this.ReadToBuffer(1, throwOnEos: true);
								extLength = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Ext16:
								this.ReadToBuffer(2, throwOnEos: true);
								extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Ext32:
								this.ReadToBuffer(4, throwOnEos: true);
								extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						this.ReadToBuffer(1, throwOnEos: true);
						// var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, extLength, MAX_BINARY_LENGTH);

						this.token = ReaderToken.Bytes;
						this.bytesValue = this.ReadBytes(checked((int)extLength));
						break;
					case MessagePackType.False:
						this.token = ReaderToken.Boolean;
						this.boolValue = false;
						break;
					case MessagePackType.True:
						this.token = ReaderToken.Boolean;
						this.boolValue = true;
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Number;
						this.numberValue = this.bitConverter.ToSingle(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Number;
						this.numberValue = this.bitConverter.ToDouble(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = unchecked((sbyte)this.buffer[this.bufferOffset]);
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt16(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.buffer[this.bufferOffset];
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = unchecked((long)this.bitConverter.ToUInt64(this.buffer, this.bufferOffset));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(this, ((MessagePackType)formatValue).ToString());
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}


		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			// commit previous reads
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;
			//

			if (bytesRequired > this.buffer.Length)
			{
				throw new InvalidOperationException($"Requested buffer for string (size: {bytesRequired}) or binary data is larger than working buffer (size: {this.buffer.Length}).");
			}

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0 && this.bufferOffset != 0)
				{
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);
				}
				this.bufferOffset = 0;

				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;
					if (read == 0)
					{
						break;
					}
				}

				if (this.bufferAvailable < bytesRequired)
				{
					if (throwOnEos)
					{
						throw ReaderException.UnexpectedEndOfStream(this);
					}
					else
					{
						return false;
					}
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}

		private ArraySegment<byte> ReadBytes(int bytesRequired)
		{
			if (bytesRequired == 0)
			{
				return new ArraySegment<byte>(Array.Empty<byte>());
			}

			this.ReadToBuffer(bytesRequired, throwOnEos: true);
			var bufferSegment = new ArraySegment<byte>(this.buffer, this.bufferOffset, bytesRequired);
			return bufferSegment;
		}
		private string ReadString(int strBytesCount)
		{
			if (strBytesCount == 0)
			{
				return string.Empty;
			}

			this.ReadToBuffer(strBytesCount, throwOnEos: true);

			if (strBytesCount < 8 && this.useStringPooling)
			{
				var stringCacheKey = 0UL;
				for (var i = 0; i < strBytesCount; i++)
				{
					stringCacheKey = stringCacheKey << 8 | this.buffer[this.bufferOffset + i];
				}

				if (this.stringPool.TryGetValue(stringCacheKey, out var utf8String))
				{
					return utf8String;
				}
				else
				{
					return this.stringPool[stringCacheKey] = utf8String = Encoding.UTF8.GetString(this.buffer, this.bufferOffset, strBytesCount);
				}
			}
			else
			{
				return Encoding.UTF8.GetString(this.buffer, this.bufferOffset, strBytesCount);
			}
		}

		private object BoxAnyValue()
		{
			switch (this.token)
			{
				case ReaderToken.Member: return this.stringValue;
				case ReaderToken.Null: return null;
				case ReaderToken.Integer: return this.integerValue;
				case ReaderToken.Number: return this.numberValue;
				case ReaderToken.String: return this.stringValue;
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.bytesValue;
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default: throw ReaderException.UnexpectedToken(this, this.token, new [] { ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes });
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void DecrementClosingTokenCounter()
		{
			if (this.structure.Count <= 0) return;

			var closingToken = this.structure.Pop();
			closingToken.Counter--;
			this.structure.Push(closingToken);
		}

		public override void Dispose()
		{
			this.token = ReaderToken.None;
			Array.Clear(this.buffer, 0, this.buffer.Length);
			this.structure.Clear();
			this.stringPool.Clear();
			this.stringValue = null;
			this.integerValue = 0;
			this.numberValue = 0;
			this.boolValue = false;
			this.bytesValue = new ArraySegment<byte>(Array.Empty<byte>());
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.totalBytesRead = 0;
			this.boolValue = false;

			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}

		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}
	}


	public class ReaderException : Exception
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, ILineInfo lineInfo)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (lineInfo == null) return;

			this.LineNumber = lineInfo.LineNumber;
			this.ColumnNumber = lineInfo.ColumnNumber;
		}

		public static Exception UnexpectedEndOfStream(ILineInfo lineInfo)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException("Unexpected end of stream.", lineInfo);
		}
		public static Exception UnexpectedToken(ILineInfo lineInfo, ReaderToken currentToken, params ReaderToken[] expectedTokens)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var expectedTokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				expectedTokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				expectedTokensStr = string.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{expectedTokensStr}' but found '{currentToken}'.",
				lineInfo);
		}
		public static Exception UnknownEscapeSequence(ILineInfo lineInfo, string escape)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown escape sequence '{escape}'.", lineInfo);
		}
		public static Exception UnterminatedStringLiteral(ILineInfo lineInfo)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException("An unterminated string literal.", lineInfo);
		}
		public static Exception UnknownNotation(ILineInfo lineInfo, string notation)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown notation '{notation}'.", lineInfo);
		}
		public static Exception StringLiteralIsTooLong(ILineInfo lineInfo, ulong size, int maxSize)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", lineInfo);
		}
		public static Exception BinaryDataIsTooLong(ILineInfo lineInfo, ulong size, int maxSize)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", lineInfo);
		}
		public static Exception ReadingBrokenDocument(ILineInfo lineInfo, string additionalInformation)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", lineInfo);
		}
		public static Exception UnknownMessagePackType(ILineInfo lineInfo, string type)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown Message Pack type '{type}'.", lineInfo);
		}
		public static Exception UnexpectedNullValue(ILineInfo lineInfo, string expected, string propertyName, string schemaName)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				lineInfo);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Integer,
		Number,
		String,
		Boolean,
		Bytes,
		EndOfStream
	}

#>
