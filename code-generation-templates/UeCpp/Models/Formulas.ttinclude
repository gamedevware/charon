<#+
	private void WriteFormulaHeader(FormulaDefinition formulaDef, CodeGenerationContext context)
	{
		var invokeParameters = string.Join(", ", formulaDef.ParameterNames.Select((name, i) => MakePtrTypeIfNeeded(formulaDef.ParameterTypes[i], context) + " " + name).ToArray());
		var invokeReturnType = MakePtrTypeIfNeeded(formulaDef.ReturnType, context);

#>/* # move to Public/<#= formulaDef #>.h */
#pragma once
<#+
	WriteFileHeader();
#>
// ReSharper disable All

#include "UObject/Class.h"
#include "UObject/StrongObjectPtr.h"
#include "UObject/WeakFieldPtr.h"
#include "UObject/UnrealType.h"
#include "Templates/SharedPointer.h"
#include "Dom/JsonObject.h"
#include "JsonObjectWrapper.h"
#if defined(CHARON_FEATURE_FORMULAS_V2) && CHARON_FEATURE_FORMULAS_V2
#include "GameData/Formulas/Expressions/FFormulaExpression.h"
#include "GameData/Formulas/FExpressionBuildHelper.h"
#include "GameData/Formulas/FFormulaTypeResolver.h"
#include "GameData/Formulas/FFormulaExecutionContext.h"
#include "GameData/Formulas/FFormulaValue.h"
#endif
#if __has_include("<#= context.TargetLanguage.GameDataClassName #>FormulaTypes.h")
    #include "<#= context.TargetLanguage.GameDataClassName #>FormulaTypes.h"
#endif

DECLARE_LOG_CATEGORY_EXTERN(Log<#= formulaDef #>, Log, All);

#include "<#= formulaDef #>.generated.h"

/**
  * <#= formulaDef.Description ?? string.Empty #>
  */
UCLASS(BlueprintType)
class <#= context.CppLanguage.ApiName #> <#= formulaDef #> : public UObject
{
	GENERATED_BODY()

private:
#if defined(CHARON_FEATURE_FORMULAS_V2) && CHARON_FEATURE_FORMULAS_V2
	TSharedPtr<FFormulaExpression> mutable Expression;
#endif
public:
	/**
	  * Gets or sets the Abstract Syntax Tree (AST) of the formula. Used internally.
	  */
	UPROPERTY()
	FJsonObjectWrapper ExpressionTree;
	/**
	  * Gets or sets the root provider for global identifiers. Properties and methods of this
	  * object can be referenced directly within the formula without a qualifier.
	  */
	UPROPERTY()
	TObjectPtr<UObject> Global;
	/**
	  * Gets or sets a value indicating whether null propagation should be applied
	  * implicitly to this formula during evaluation or code generation.
	  */
	UPROPERTY()
	bool AutoNullPropagation;

	/**
	  * Evaluates the formula and returns the resulting value.
	  */
	UFUNCTION()
	<#= invokeReturnType #> Invoke(<#= invokeParameters #>) const;

#if defined(CHARON_FEATURE_FORMULAS_V2) && CHARON_FEATURE_FORMULAS_V2
	/**
	  * Gets original formula expression for custom interpretation.
	  */
	TSharedPtr<FFormulaExpression> GetExpression() const;
#endif
};
<#+
	}
#>
<#+
	private void WriteFormulaImplementation(FormulaDefinition formulaDef, CodeGenerationContext context)
	{
		var invokeParameters = string.Join(", ", formulaDef.ParameterNames.Select((name, i) => MakePtrTypeIfNeeded(formulaDef.ParameterTypes[i], context) + " " + name).ToArray());
		var invokeReturnType = MakePtrTypeIfNeeded(formulaDef.ReturnType, context);
#>
/* # move to Private/<#= formulaDef #>.cpp */
<#+
	WriteFileHeader();
#>
// ReSharper disable All

#include "<#= formulaDef #>.h"
#include "<#= context.TargetLanguage.GameDataClassName #>.h"

DEFINE_LOG_CATEGORY(Log<#= formulaDef #>);

#if defined(CHARON_FEATURE_FORMULAS_V2) && CHARON_FEATURE_FORMULAS_V2

static TSharedRef<FFormulaTypeResolver> GetOrCreateTypeResolver()
{
	static TSharedRef<FFormulaTypeResolver> __TypeResolver = MakeShared<FFormulaTypeResolver>(<#= context.TargetLanguage.GameDataClassName #>::GetSharedFormulaTypeResolver(), TArray<UObject*> {
<#+
		foreach (var typeRef in formulaDef.GetReferenceTypes().Concat(formulaDef.GetReferencedExternalTypes()))
		{
			if (IsUObjectType(typeRef))
			{
#>
		<#= typeRef #>::StaticClass(),
<#+
			}
			else if (IsUEnumType(typeRef))
			{
#>
		StaticEnum<<#= typeRef #>>(),
<#+
			}
			else
			{
#>
		// <#= typeRef #> <- unknown name prefix
<#+
			}
		}
#>
	});

	return __TypeResolver;
}

static UFunction* GetInvokeFunction()
{
	static TWeakObjectPtr<UFunction> InvokeFunction = <#= formulaDef #>::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(<#= formulaDef #>, Invoke));

	if (!InvokeFunction.IsValid())
	{
		UE_LOG(Log<#= formulaDef #>, Error, TEXT("Failed to find required 'Invoke' function on '<#= formulaDef #>' type."));
	}
	return InvokeFunction.Get();
}

static FProperty* GetGlobalProperty()
{
	static TWeakFieldPtr<FProperty> GlobalProperty = <#= formulaDef #>::StaticClass()->FindPropertyByName(GET_MEMBER_NAME_CHECKED(<#= formulaDef #>, Global));

	if (!GlobalProperty.IsValid())
	{
		UE_LOG(Log<#= formulaDef #>, Error, TEXT("Failed to find required 'Global' property on '<#= formulaDef #>' type."));
	}
	return GlobalProperty.Get();
}

static FProperty* GetInvokeParameterAt(int32 Index)
{
	static TArray<FProperty*> Parameters = []()
	{
		TArray<FProperty*> Params;
		for (TFieldIterator<FProperty> It(GetInvokeFunction()); It; ++It)
		{
			FProperty* Prop = *It;

			if (Prop->HasAnyPropertyFlags(CPF_Parm) && !Prop->HasAnyPropertyFlags(CPF_ReturnParm))
			{
				Params.Add(Prop);
			}
		}
		return Params;
	}();

	check(Index >= 0 && Index < Parameters.Num());
	return Parameters[Index];
}

<#= invokeReturnType #> <#= formulaDef #>::Invoke(<#= invokeParameters #>) const
{
<#+
		for (var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>
	const int32 PARAMETER_<#= formulaDef.ParameterNames[p].ToUpperInvariant() #>_INDEX = <#= p #>;
<#+
		}
#>

	auto __ParsedExpression = this->GetExpression();
	auto __InvokeFunction = GetInvokeFunction();

	<#= invokeReturnType #> __Result = {};
	if (!__ParsedExpression.IsValid() || !__InvokeFunction)
	{
		UE_LOG(Log<#= formulaDef #>, Error, TEXT("The expression tree is missing or contains errors, or the function metadata is not available."));
		return __Result; // default
	}

	const TMap<FString, const TSharedRef<FFormulaValue>> __Arguments = {
<#+
		for (var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>		{ TEXT("<#= formulaDef.ParameterRawNames[p] #>"), MakeShared<FFormulaValue>(GetInvokeParameterAt(PARAMETER_<#= formulaDef.ParameterNames[p].ToUpperInvariant() #>_INDEX), &<#= formulaDef.ParameterNames[p] #> ) },
<#+
		}
#>
	};

	auto __Global = MakeShared<FFormulaValue>(GetGlobalProperty(), &this->Global);
	auto __Context = FFormulaExecutionContext(this->AutoNullPropagation, __Arguments, __Global, GetOrCreateTypeResolver());

	auto __ReturnValueType = __InvokeFunction->GetReturnProperty();
	auto __InvokeResult = __ParsedExpression->Execute(__Context, __ReturnValueType);
	if (__InvokeResult.HasError())
	{
		UE_LOG(Log<#= formulaDef #>, Error, TEXT("The formula [%s] execution failed. In this case, the default '<#= invokeReturnType #>' result will be returned. Error: %s"), *__ParsedExpression->ToString(), *__InvokeResult.GetError().Message);
	}
	else if (!__InvokeResult.GetValue()->TryCopyCompleteValue(__ReturnValueType, &__Result))
	{
		UE_LOG(Log<#= formulaDef #>, Error, TEXT("Failed to convert Formula execution result '%s' to '<#= invokeReturnType #>' type."), *__InvokeResult.GetValue()->ToString());
	}
	return __Result;
}

TSharedPtr<FFormulaExpression> <#= formulaDef #>::GetExpression() const
{
	if (!this->Expression.IsValid() && this->ExpressionTree.JsonObject.IsValid())
	{
		this->Expression = FExpressionBuildHelper::CreateExpression(&this->ExpressionTree.JsonObject);
	}
	return this->Expression;
}
#else
<#= invokeReturnType #> <#= formulaDef #>::Invoke(<#= invokeParameters #>) const
{
	UE_LOG(Log<#= formulaDef #>, Error, TEXT("Formulas are not supported or disabled in this version of the plugin. Please update the Unreal Engine plugin to the latest version or enable the feature by adding the 'CHARON_FEATURE_FORMULAS_V2=1' compilation constant."));
	return {}; // default
}
#endif
<#+
	}
	private ITypeReference MakePtrTypeIfNeeded(ITypeReference typeRef, CodeGenerationContext context)
	{
		if (IsUObjectType(typeRef))
		{
			return context.CppLanguage.MakePtrType(typeRef);
		}
		else
		{
			return typeRef;
		}
	}

	private bool IsUEnumType(ITypeReference typeRef)
	{
		var typeName = typeRef.ToString();
		return typeName.StartsWith("E", StringComparison.Ordinal);
	}

	private bool IsUObjectType(ITypeReference typeRef)
	{
		var typeName = typeRef.ToString();
		return typeName.StartsWith("U", StringComparison.Ordinal) ||
			    typeName.StartsWith("A", StringComparison.Ordinal) ||
				typeName.StartsWith("BP_", StringComparison.Ordinal) ||
				typeName.StartsWith("WBP_", StringComparison.Ordinal) ||
				typeName.StartsWith("S", StringComparison.Ordinal);
	}
#>
