<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentBaseClass(CodeGenerationContext context)
	{
#>
abstract class <#= context.TargetLanguage.DocumentClassName #> {
	public var parent(default, set):<#= context.TargetLanguage.DocumentClassName #>;

	private function set_parent(value:<#= context.TargetLanguage.DocumentClassName #>) {
		return this.parent = value;
	}

	public function toString() {
		return "<#= context.TargetLanguage.DocumentClassName #>";
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentCollection(CodeGenerationContext context)
	{
#>
class DocumentCollection<KeyT, DocumentT:<#= context.TargetLanguage.DocumentClassName #>> {

	private var documentsByKey:BalancedTree<KeyT, DocumentT>;
	private var byPropertyDictionary:Map<String, Any>;

	public var list(default, null):ReadOnlyArray<DocumentT>;
	public var count(get, never):Int;
	public var keys(get, never):Iterator<KeyT>;

	public function get(key:KeyT) {
		return this.documentsByKey.get(key);
	}

	private function get_keys() {
		return this.documentsByKey.keys();
	}

	private function get_count():Int {
		return this.list.length;
	}

	public function new(documents:ReadOnlyArray<DocumentT>, keyName:String, keySelectorFunc:(document:DocumentT) -> KeyT) {
		if (documents == null)
			throw 'documents cannot be null';
		if (keyName == null)
			throw 'keyName cannot be null';
		if (keySelectorFunc == null)
			throw 'keySelectorFunc cannot be null';

		this.list = documents;
		this.documentsByKey = new BalancedTree<KeyT, DocumentT>();
		for (document in documents) {
			if (document == null) {
				continue;
			}
			var key = keySelectorFunc(document);
			if (key == null) {
				continue;
			}
			this.documentsByKey.set(key, document);
		}
	}

	public function exists(key:KeyT) {
		return this.documentsByKey.exists(key);
	}

	public function byKey<NewKeyT>(keyName:String, keySelectorFunc:(document:DocumentT) -> NewKeyT):DocumentCollection<NewKeyT, DocumentT> {
		if (keyName == null)
			throw 'keyName cannot be null';
		if (keySelectorFunc == null)
			throw 'keySelectorFunc cannot be null';

		if (this.byPropertyDictionary == null) {
			this.byPropertyDictionary = new Map();
			this.byPropertyDictionary.set(keyName, this);
		}

		var otherCollection = this.byPropertyDictionary.get(keyName);
		if (otherCollection != null) {
			return cast otherCollection;
		}

		var newCollection = new DocumentCollection<NewKeyT, DocumentT>(this.list, keyName, keySelectorFunc);
		this.byPropertyDictionary.set(keyName, newCollection);
		newCollection.byPropertyDictionary = this.byPropertyDictionary;
		return newCollection;
	}

	/**
		Returns an iterator of the Array values.
	**/
	@:runtime inline function iterator():haxe.iterators.ArrayIterator<DocumentT> {
		return this.list.iterator();
	}

	/**
		Returns an iterator of the Array indices and values.
	**/
	@:pure @:runtime public inline function keyValueIterator():KeyValueIterator<KeyT, DocumentT> {
		return this.documentsByKey.keyValueIterator();
	}

	public function toString() {
		return this.list.toString();
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceBaseClass(CodeGenerationContext context)
	{
#>
class <#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT:<#= context.TargetLanguage.DocumentClassName #>> {
	private var schemaIdOrName(default, null):String;
	private var findFunc(default, null):(schemaIdOrName:String, documentId:ReaderValue) -> <#= context.TargetLanguage.DocumentClassName #>;
	private var document:DocumentT;

	public var id(default, null):ReaderValue;

	public function new(id:ReaderValue, schemaIdOrName:String, findFunc:(schemaIdOrName:String, documentId:ReaderValue) -> <#= context.TargetLanguage.DocumentClassName #>) {
		if (id == null)
			throw 'id cannot be null';
		if (findFunc == null)
			throw 'findFunc cannot be null';
		if (schemaIdOrName == null)
			throw 'schemaIdOrName cannot be null';

		this.id = id;
		this.schemaIdOrName = schemaIdOrName;
		this.findFunc = findFunc;
	}

	public function dereference():DocumentT {
		if (this.document != null) {
			return this.document;
		}

		return this.document = cast this.findFunc(this.schemaIdOrName, this.id);
	}

	public function toString() {
		return 'Id: ${Std.string(this.id)}, Schema: ${this.schemaIdOrName}, Resolved: ${Std.string(this.document != null)}';
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteDocumentReferenceCollection(CodeGenerationContext context)
	{
#>
class DocumentReferenceCollection<DocumentT:<#= context.TargetLanguage.DocumentClassName #>> {

	private var documentList:ReadOnlyArray<DocumentT>;
	private var referenceList:Array<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>;
	private var documentCollectionById:Map<String, Any>;

	public var count(get, null):Int;

	private function get_count() {
		return this.referenceList.length;
	}

	public function get(index:Int):Null<DocumentT> {
		return this.dereference()[index];
	}

	public function new(referenceList:Array<<#= context.TargetLanguage.DocumentReferenceClassName #><DocumentT>>) {
		if (referenceList == null)
			throw 'referenceList cannot be null';

		this.referenceList = referenceList;
		this.documentList = null;
		this.documentCollectionById = null;
	}

	public function dereference():ReadOnlyArray<DocumentT> {
		if (this.documentList != null) {
			return this.documentList;
		}

		var documentList = new Array();
		for (reference in this.referenceList) {
			documentList.push(reference.dereference());
		}
		return this.documentList = documentList;
	}

	/**
		Returns an iterator of the Array values.
	**/
	@:runtime inline function iterator():haxe.iterators.ArrayIterator<DocumentT> {
		return this.dereference().iterator();
	}

	/**
		Returns an iterator of the Array indices and values.
	**/
	@:pure @:runtime public inline function keyValueIterator():ArrayKeyValueIterator<DocumentT> {
		return this.dereference().keyValueIterator();
	}

	public function toString() {
		return this.dereference().toString();
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteLanguageFallbackOption(CodeGenerationContext context)
	{
#>
enum LanguageFallbackOption {
	/**
		Fallback when the localized text is null (default)
	 **/
	OnNull;

	/**
		Fallback when the localized text is an empty string
	 **/
	OnEmpty;
	/**
		Fallback when the localized text is not defined in the LocalizedText
	 **/
	OnNotDefined;
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteLanguageSwitcher(CodeGenerationContext context)
	{
#>
class LanguageSwitcher {
	public var currentLanguageId: String;
	public var fallbackLanguageId: String;
	public var primaryLanguageId: String;
	public var fallbackOption: LanguageFallbackOption;

	public function new() {
		this.currentLanguageId = "en-US";
		this.fallbackLanguageId = "en-US";
		this.primaryLanguageId = "en-US";
		this.fallbackOption = LanguageFallbackOption.OnNull;
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteLocalizedText(CodeGenerationContext context)
	{
#>
class LocalizedText {
	public static var _empty = new LocalizedText(new Map<String, String>(), new LanguageSwitcher());
	public static function empty() { return _empty; }

	private var textByLanguageId:Map<String, String>;
	private var languageSwitcher:LanguageSwitcher;
	private var currentValue:String;
	private var currentValueLanguageId:String;

	public var count(default, null):Int;

	public var value(get, null):String;

	private function get_value():String {
		var currentLanguageId = this.languageSwitcher.currentLanguageId;
		var fallbackLanguageId = this.languageSwitcher.fallbackLanguageId;
		var primaryLanguageId = this.languageSwitcher.primaryLanguageId;

		if (currentLanguageId != this.currentValueLanguageId) {
			this.currentValueLanguageId = currentLanguageId;
			switch (this.languageSwitcher.fallbackOption) {
				case LanguageFallbackOption.OnNotDefined:
					if (this.textByLanguageId.exists(currentLanguageId)) {
						this.currentValue = this.textByLanguageId.get(currentLanguageId) ?? "";
					} else if (this.textByLanguageId.exists(fallbackLanguageId)) {
						this.currentValue = this.textByLanguageId.get(fallbackLanguageId) ?? "";
					} else {
						this.currentValue = this.textByLanguageId.get(primaryLanguageId) ?? "";
					}
				case LanguageFallbackOption.OnEmpty:
					this.currentValue = this.get(currentLanguageId);
					if ((this.currentValue ?? "") == "") {
						this.currentValue = this.get(fallbackLanguageId);
					}
					if ((this.currentValue ?? "") == "") {
						this.currentValue = this.get(primaryLanguageId);
					}
					if ((this.currentValue ?? "") == "") {
						this.currentValue = "";
					}
				case LanguageFallbackOption.OnNull, (_):
					this.currentValue = this.get(currentLanguageId) ?? this.get(fallbackLanguageId) ?? this.get(primaryLanguageId) ?? "";
			}
		}
		return this.currentValue;
	}

	public function get(key:String):String {
		return this.textByLanguageId.get(key);
	}

	public function new(textByLanguageId:Map<String, String>, languageSwitcher:LanguageSwitcher) {
		if (textByLanguageId == null)
			throw 'textByLanguageId cannot be null';
		if (languageSwitcher == null)
			throw 'languageSwitcher cannot be null';

		this.textByLanguageId = textByLanguageId;
		this.languageSwitcher = languageSwitcher;
		this.count = Lambda.count(textByLanguageId);
		this.currentValue = null;
		this.currentValueLanguageId = null;
	}

	/**
		Returns an iterator of the language keys and values.
	**/
	@:pure @:runtime public inline function keyValueIterator():KeyValueIterator<String, String> {
		return this.textByLanguageId.keyValueIterator();
	}

	public function toString() {
		return this.get_value();
	}
}
<#+ 
	}
#>
<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteTimeSpan(CodeGenerationContext context)
	{
#>
class TimeSpan {
	private static var ticksPerMillisecond = haxe.Int64.parseString("10000");
	private static var ticksPerSecond = haxe.Int64.parseString("10000000");
	private static var ticksPerMinute = haxe.Int64.parseString("600000000");
	private static var ticksPerHour = haxe.Int64.parseString("36000000000");
	private static var ticksPerDay = haxe.Int64.parseString("864000000000");
	private static var int64MaxValue = haxe.Int64.parseString("9223372036854775807");
	private static var int64MinValue = haxe.Int64.parseString("-9223372036854775808");
	private static var testDigitsOnly:EReg = ~/^\\d+$/i;
	private static var splitRegex:EReg = ~/[\.:]+/gi;

	public static var maxValue(default, null):TimeSpan = new TimeSpan(int64MaxValue);
	public static var minValue(default, null):TimeSpan = new TimeSpan(int64MinValue);
	public static var zero(default, null):TimeSpan = new TimeSpan(0);

	public var ticks(default, null):haxe.Int64;

	public var sign(get, never):Int;

	function get_sign():Int {
		return haxe.Int64.compare(this.ticks, zero.ticks);
	}

	public var milliseconds(get, never):Int;

	function get_milliseconds():Int {
		return haxe.Int64.toInt(haxe.Int64.div(this.ticks, ticksPerMillisecond));
	}

	public function new(ticks:haxe.Int64) {
		this.ticks = ticks;
	}

	public static function fromTicks(ticks:haxe.Int64) {
		return new TimeSpan(ticks);
	}

	public static function fromSeconds(seconds:Int) {
		return new TimeSpan(haxe.Int64.mul(haxe.Int64.ofInt(seconds), ticksPerSecond));
	}

	public static function fromString(value:String) {
		if (value == null)
			throw 'value cannot be null';

		if (value.length == 0)
			throw 'value cannot be empty string';

		var isNegative = false;
		if (value.charCodeAt(0) == 45 /* minus */) {
			value = value.substring(1);
			isNegative = true;
		}

		if (testDigitsOnly.match(value)) {
			return fromSeconds(Std.parseInt(value) * (isNegative ? -1 : 1));
		}

		var ticks = haxe.Int64.ofInt(0);
		if (value.lastIndexOf('.') >= value.indexOf('.') && value.lastIndexOf('.') > value.indexOf(':')) {
			var splitIndex = value.lastIndexOf('.');
			var tickStr = value.substring(splitIndex + 1);
			value = value.substring(0, splitIndex);
			ticks = ticks + haxe.Int64.parseString(tickStr);
		}

		var parts = splitRegex.split(value);
		while (parts.length < 4) {
			parts.unshift('0');
		}

		ticks = haxe.Int64.add(ticks, haxe.Int64.mul(haxe.Int64.parseString(parts[0]), ticksPerDay));
		ticks = haxe.Int64.add(ticks, haxe.Int64.mul(haxe.Int64.parseString(parts[1]), ticksPerHour));
		ticks = haxe.Int64.add(ticks, haxe.Int64.mul(haxe.Int64.parseString(parts[2]), ticksPerMinute));
		ticks = haxe.Int64.add(ticks, haxe.Int64.mul(haxe.Int64.parseString(parts[3]), ticksPerSecond));

		return new TimeSpan(haxe.Int64.mul(ticks, (isNegative ? haxe.Int64.ofInt(-1) : haxe.Int64.ofInt(1))));
	}

	private static function padNumber(value:haxe.Int64, total:Int):String {
		var valueStr = haxe.Int64.toStr(value);
		while (valueStr.length < total) {
			valueStr = '0' + valueStr;
		}
		return valueStr;
	}

	public function toString() {
		var ticks = haxe.Int64.divMod(this.ticks, ticksPerSecond).modulus;
		var seconds = haxe.Int64.divMod(haxe.Int64.div(this.ticks, ticksPerSecond), haxe.Int64.ofInt(60)).modulus;
		var minutes = haxe.Int64.divMod(haxe.Int64.div(this.ticks, ticksPerMinute), haxe.Int64.ofInt(60)).modulus;
		var hours = haxe.Int64.divMod(haxe.Int64.div(this.ticks, ticksPerHour), haxe.Int64.ofInt(24)).modulus;
		var days = haxe.Int64.div(this.ticks, ticksPerDay);

		var result = padNumber(hours, 2) + ':' + padNumber(minutes, 2) + ':' + padNumber(seconds, 2);
		if (ticks > zero.ticks) {
			result = result + '.' + TimeSpan.padNumber(ticks, 7);
		}
		if (days > zero.ticks) {
			result = days + '.' + result;
		}
		return result;
	}
}
<#+ 
	}
#>
