<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormatters()
	{
#> 
enum GameDataFormat {
    Json;
    MessagePack;
}
class GameDataLoadOptions {
	public var format:GameDataFormat;
	public var patches:ReadOnlyArray<Input>;
	public var leaveInputsOpen:Bool;

	public function new() {
		this.format = GameDataFormat.Json;
		this.patches = [];
		this.leaveInputsOpen = false;
	}

	// ToString equivalent in Haxe
	public function toString():String {
		var patchNames = this.patches.map(function(patch) return Std.string(patch));
		return 'Format: ' + Std.string(this.format) + ', Patches: ' + patchNames.join(", ") + ', Leave Open: ' + this.leaveInputsOpen;
	}
}
class GameDataObjectReader extends GameDataReader {
	private static inline var FIRST_FRAME_MARKER = -2147483648;

	private var framePool:Array<GameDataObjectReaderFrame>;
	private var frames:Array<GameDataObjectReaderFrame>;
	private var topFrameIndex:Int;

	public function get_lineNumber() {
		return 0;
	};

	public function get_columnNumber() {
		return 0;
	}

	public function new(document:Map<String, ReaderValue>) {
		if (document == null)
			throw 'document cannot be null';

		super();

		this.frames = new Array();
		this.framePool = new Array();
		this.topFrameIndex = -1;
		this.pushDocumentFrame(document);
		this.topFrameIndex = FIRST_FRAME_MARKER;
	}

	public function nextToken():Bool {
		if (this.topFrameIndex == FIRST_FRAME_MARKER) {
			this.topFrameIndex = 0;
			this.token = this.frames[this.topFrameIndex].getContainerType();
			this.value = ReaderValue.Void;
			return true;
		}

		while (this.topFrameIndex >= 0) {
			var nextToken = this.frames[this.topFrameIndex].getState();
			switch (nextToken) {
				case ReaderToken.Member:
					var memberName = this.frames[this.topFrameIndex].getMemberName();
					this.token = nextToken;
					this.value = ReaderValue.String(memberName);
					return true;
				case ReaderToken.Value:
					this.token = nextToken;
					this.value = this.frames[this.topFrameIndex].getCurrent();
					this.frames[this.topFrameIndex].next();
					return true;
				case ReaderToken.EndOfObject, ReaderToken.EndOfArray:
					this.popFrame();
					this.token = nextToken;
					this.value = ReaderValue.Void;
					return true;
				case ReaderToken.BeginObject:
					switch (this.frames[this.topFrameIndex].getCurrent()) {
						case Document(document):
							this.frames[this.topFrameIndex].next();
							this.pushDocumentFrame(document);
							this.token = nextToken;
							this.value = ReaderValue.Void;
							return true;
						case otherValue: throw ReaderException.readingBrokenDocument(this,
								"unexpected value in document structure - " + Std.string(otherValue));
					}
				case ReaderToken.BeginArray:
					switch (this.frames[this.topFrameIndex].getCurrent()) {
						case Collection(collection):
							this.frames[this.topFrameIndex].next();
							this.pushCollectionFrame(collection);
							this.token = nextToken;
							this.value = ReaderValue.Void;
							return true;
						case otherValue: throw ReaderException.readingBrokenDocument(this,
								"unexpected value in document structure - " + Std.string(otherValue));
					}
				case ReaderToken.Null:
					this.frames[this.topFrameIndex].next();
					this.token = nextToken;
					this.value = ReaderValue.Null;
					return true;
				default:
					throw ReaderException.unexpectedToken(this, nextToken, this.value, [
						ReaderToken.Member,
						ReaderToken.Value,
						ReaderToken.Null,
						ReaderToken.BeginObject,
						ReaderToken.BeginArray
					]);
			}
		}

		this.token = ReaderToken.EndOfStream;
		this.value = ReaderValue.Void;
		return false;
	}

	public function close() {
		while (this.frames.length > 0) {
			this.frames.pop();
		}
		while (this.framePool.length > 0) {
			this.framePool.pop();
		}
	}

	private function pushDocumentFrame(document:Map<String, ReaderValue>) {
		var newFrame = this.framePool.pop() ?? new GameDataObjectReaderFrame();
		newFrame.collection = null;
		newFrame.document = document;
		for (key in document.keys()) {
			newFrame.documentKeys.push(key);
		}
		this.frames.push(newFrame);
		this.topFrameIndex++;
	}

	private function pushCollectionFrame(collection:Array<ReaderValue>) {
		var newFrame = this.framePool.pop() ?? new GameDataObjectReaderFrame();
		newFrame.document = null;
		newFrame.collection = collection;
		this.frames.push(newFrame);
		this.topFrameIndex++;
	}

	private function popFrame() {
		var frame = this.frames.pop();
		this.topFrameIndex--;
		if (frame == null) {
			return;
		}
		frame.reset();
		this.framePool.push(frame);
	}
}
class GameDataObjectReaderFrame {
	public var memberNameVisited:Bool;
	public var currentIndex:Int;
	public var collection:Array<ReaderValue>;
	public var document:Map<String, ReaderValue>;
	public var documentKeys:Array<String>;

	public function new() {
		this.memberNameVisited = false;
		this.currentIndex = 0;
		this.collection = null;
		this.document = null;
		this.documentKeys = new Array();
	}

	public function getMemberName():String {
		return this.documentKeys != null ? this.documentKeys[this.currentIndex] : null;
	}

	public function getCurrent():ReaderValue {
		return this.collection != null ? this.collection[this.currentIndex] : this.document.get(this.getMemberName());
	}

	public function getContainerType():ReaderToken {
		return this.collection != null ? ReaderToken.BeginArray : this.document != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
	}

	public function isInBounds():Bool {
		return this.currentIndex < (this.collection?.length ?? this.documentKeys?.length ?? 0);
	}

	public function getState():ReaderToken {
		var isDocumentIteration = this.document != null;
		if (!this.isInBounds()) {
			return isDocumentIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
		}

		if (isDocumentIteration && !this.memberNameVisited) {
			this.memberNameVisited = true;
			return ReaderToken.Member;
		}

		this.memberNameVisited = false;
		var currentValue = this.getCurrent();
		switch (currentValue) {
			case Document(_):
				return ReaderToken.BeginObject;
			case Collection(_):
				return ReaderToken.BeginArray;
			case Null:
				return ReaderToken.Null;
			default:
				return ReaderToken.Value;
		}
	}

	public function next() {
		this.currentIndex++;
		this.memberNameVisited = false;
	}

	public function reset() {
		this.memberNameVisited = false;
		this.currentIndex = 0;
		this.collection = null;
		this.document = null;
		while (this.documentKeys.length > 0) {
			this.documentKeys.pop();
		}
	}

	public function toString() {
		if (this.document != null) {
			return "document: " + Std.string(this.documentKeys.length);
		} else if (this.collection != null) {
			return "collection: " + Std.string(this.collection.length);
		} else {
			return "empty";
		}
	}
}
abstract class GameDataReader implements LineInfo {
	public var token:ReaderToken;
	public var value:ReaderValue;

	public function hasValue():Bool {
		return value != ReaderValue.Void;
	}

	public function new() {
		this.token = ReaderToken.None;
		this.value = ReaderValue.Void;
	}

	public abstract function get_lineNumber():Int;

	public abstract function get_columnNumber():Int;

	public abstract function nextToken():Bool;

	public function isEndOfStream():Bool {
		return this.token == ReaderToken.EndOfStream;
	}

	public function isNull():Bool {
		return this.token == ReaderToken.Null;
	}

	public function throwIfNotValue():Void {
		if (this.token != ReaderToken.Value) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.Value]);
		}
	}

	public function throwIfNull(expected:String, propertyName:String, schemaName:String):Void {
		if (this.token == ReaderToken.Null) {
			throw ReaderException.unexpectedNullValue(this, expected, propertyName, schemaName);
		}
	}

	public function readAny(nextToken:Bool = true):ReaderValue {
		switch (this.token) {
			case ReaderToken.BeginArray:
				return ReaderValue.Collection(this.readArray(nextToken));
			case ReaderToken.BeginObject:
				return ReaderValue.Document(this.readObject(nextToken));
			case ReaderToken.Null:
				if (nextToken)
					this.nextToken();
				return ReaderValue.Null;
			case ReaderToken.Value:
				var value = this.value;
				if (nextToken)
					this.nextToken();
				return value;
			default:
				throw ReaderException.unexpectedToken(this, this.token, this.value, [
					ReaderToken.BeginArray,
					ReaderToken.BeginObject,
					ReaderToken.Null,
					ReaderToken.Value
				]);
		}
	}

	public function readArray(nextToken:Bool = true):Array<ReaderValue> {
		var list = new Array<ReaderValue>();
		this.readArrayBegin();
		while (this.token != ReaderToken.EndOfArray) {
			list.push(this.readAny());
		}
		this.readArrayEnd(nextToken);
		return list;
	}

	public function readObject(nextToken:Bool = true):Map<String, ReaderValue> {
		var dictionary = new Map<String, ReaderValue>();
		this.readObjectBegin();
		while (this.token != ReaderToken.EndOfObject) {
			var key = this.readMember();
			dictionary.set(key, this.readAny());
		}
		this.readObjectEnd(nextToken);
		return dictionary;
	}

	public function skipAny(nextToken:Bool = true):Void {
		switch (this.token) {
			case ReaderToken.BeginArray:
				this.skipArray(nextToken);
			case ReaderToken.BeginObject:
				this.skipObject(nextToken);
			case ReaderToken.Member, ReaderToken.Value, ReaderToken.Null:
				if (nextToken)
					this.nextToken();
			default:
				throw ReaderException.unexpectedToken(this, this.token, this.value, [
					ReaderToken.BeginArray,
					ReaderToken.BeginObject,
					ReaderToken.Null,
					ReaderToken.Value
				]);
		}
	}

	public function skipArray(nextToken:Bool = true):Void {
		this.readArrayBegin();
		while (this.token != ReaderToken.EndOfArray) {
			this.skipAny();
		}
		this.readArrayEnd(nextToken);
	}

	public function skipObject(nextToken:Bool = true):Void {
		this.readObjectBegin();
		while (this.token != ReaderToken.EndOfObject) {
			this.skipAny();
			this.skipAny();
		}
		this.readObjectEnd(nextToken);
	}

	public function readArrayBegin(nextToken:Bool = true):Void {
		if (this.token != ReaderToken.BeginArray) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.BeginArray]);
		}
		if (this.isEndOfStream()) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.EndOfArray]);
		}
		if (nextToken)
			this.nextToken();
	}

	public function readArrayEnd(nextToken:Bool = true):Void {
		if (this.token != ReaderToken.EndOfArray) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.EndOfArray]);
		}
		if (!this.isEndOfStream() && nextToken) {
			this.nextToken();
		}
	}

	public function readObjectBegin(nextToken:Bool = true):Void {
		if (this.token != ReaderToken.BeginObject) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.BeginObject]);
		}
		if (this.isEndOfStream()) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.EndOfObject]);
		}
		if (nextToken)
			this.nextToken();
	}

	public function readObjectEnd(nextToken:Bool = true):Void {
		if (this.token != ReaderToken.EndOfObject) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.EndOfObject]);
		}
		if (!this.isEndOfStream() && nextToken) {
			this.nextToken();
		}
	}

	public function readMember(nextToken:Bool = true):String {
		if (this.token != ReaderToken.Member && this.token != ReaderToken.Value) {
			throw ReaderException.unexpectedToken(this, this.token, this.value, [ReaderToken.Member, ReaderToken.Value]);
		}
		var memberName = this.readString(false);
		if (!this.isEndOfStream() && nextToken) {
			this.nextToken();
		}
		return memberName;
	}

	private function readString(nextToken:Bool):String {
		var value = this.value;
		if (!this.isEndOfStream() && nextToken) {
			this.nextToken();
		}
		switch (value) {
			case Bool(value):
				return value ? "true" : "false";
			case Int(value):
				return Std.string(value);
			case String(value):
				return value;
			case Float(value):
				return Std.string(value);
			case Int64(value):
				return haxe.Int64.toStr(value);
			case Bytes(value):
				return haxe.crypto.Base64.encode(value);
			case Document(value):
				return Std.string(value);
			case Collection(value):
				return Std.string(value);
			case Null:
				return '';
			case Void:
				throw ReaderException.unexpectedToken(this, this.token, value, [ReaderToken.Value, ReaderToken.Null, ReaderToken.Member]);
		}
	}

	public function debugPrintTokens():String {
		var output = new StringBuf();
		var stack = new List<ReaderToken>();
		stack.push(ReaderToken.None);
		while (this.nextToken()) {
			var strValue = Std.string(this.token) + (this.hasValue() ? "[" + this.readString(false) + "]" : "");
			if (stack.last() != ReaderToken.Member) {
				var endingTokenIndent = (this.token == ReaderToken.EndOfObject || this.token == ReaderToken.EndOfArray) ? -1 : 0;
				output.add("\n");
				for (i in 0...stack.length + endingTokenIndent) {
					output.add("\t");
				}
			} else {
				output.add(" ");
			}
			output.add(strValue);
			if (this.token == ReaderToken.EndOfObject || this.token == ReaderToken.EndOfArray || stack.last() == ReaderToken.Member) {
				stack.pop();
			}
			if (this.token == ReaderToken.BeginObject || this.token == ReaderToken.BeginArray || this.token == ReaderToken.Member) {
				stack.push(this.token);
			}
		}
		return output.toString();
	}

	public abstract function close():Void;
}
class JsonGameDataReader extends GameDataReader {
	private static var IS_UC2_RUNTIME = '😊'.length == 2;

	private static inline var DEFAULT_BUFFER_SIZE:Int = 65 * 1024 * 1024;
	private static inline var LEXER_STATE_COMPLETE = -1;
	private static inline var LEXER_STATE_START = 0;
	private static inline var LEXER_STATE_LEXEME = 1;
	private static inline var LEXER_STATE_QUOTED = 2;
	private static inline var LEXER_STATE_QUOTED_ESCAPE = 3;
	private static inline var LEXER_STATE_COMMENT_BEGINNING = 4;
	private static inline var LEXER_STATE_COMMENT_SINGLE_LINE = 5;
	private static inline var LEXER_STATE_COMMENT_MULTILINE = 6;
	private static inline var LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

	private static inline var NUMBER_FLOAT = 2;
	private static inline var NUMBER_INTEGER = 0;
	private static inline var NUMBER_NEGATIVE_INTEGER = 1;
	private static inline var NUMBER_NOT = -1;

	private static inline var Int32MaxLength = 10;

	private var inputBuffer:BufferInput;
	private var utf8Buff:Array<Int>;
	private var lexemeBuff:Array<Int>;
	private var stringCache:Map<Int64, String>;
	private var leaveOpen:Bool;
	private var useStringCache:Bool;
		private var frames:GenericStack<ReaderToken>;

	private var columnNumber:Int;
	private var lineNumber:Int;

	public function get_lineNumber() {
		return this.lineNumber;
	};

	public function get_columnNumber() {
		return this.columnNumber;
	}

	public function new(input:Input, leaveOpen:Bool, useStringCache: Bool, bufferSize:Int = DEFAULT_BUFFER_SIZE) {
		if (input == null)
			throw 'input cannot be null';

		super();

		this.lineNumber = 1;
		this.columnNumber = 0;
		this.inputBuffer = new BufferInput(input, haxe.io.Bytes.alloc(bufferSize));
		this.inputBuffer.bigEndian = false;

		this.leaveOpen = leaveOpen;
		this.useStringCache = useStringCache;
		this.utf8Buff = new Array();
		this.lexemeBuff = new Array();
		this.frames = new GenericStack();
		this.stringCache = new Map();
	}

	public function nextToken():Bool {
		var memberOrValueToken = ReaderToken.Value;
		if (!this.frames.isEmpty()) {
			if (this.frames.head.elt == ReaderToken.Member) {
				this.frames.pop();
			} else if (this.frames.head.elt == ReaderToken.BeginObject) {
				this.frames.add(memberOrValueToken = ReaderToken.Member);
			}
		}

		var lexeme:String;
		try {
			lexeme = this.nextLexeme();
		} catch (eof:Eof) {
			this.token = ReaderToken.EndOfStream;
			this.value = ReaderValue.Void;
			return false;
		}

		if (lexeme.length == 1) {
			var charCode = lexeme.charCodeAt(0);
			if (charCode >= JsonNotation.ZeroCharCode && charCode <= JsonNotation.NineCharCode) {
				this.token = memberOrValueToken;
				this.value = ReaderValue.Int(charCode - JsonNotation.ZeroCharCode);
				return true;
			} else if (charCode == JsonNotation.BeginArrayCharCode) {
				this.frames.add(ReaderToken.BeginArray);
				this.token = ReaderToken.BeginArray;
				this.value = ReaderValue.Void;
				return true;
			} else if (charCode == JsonNotation.BeginObjectCharCode) {
				this.frames.add(ReaderToken.BeginObject);
				this.token = ReaderToken.BeginObject;
				this.value = ReaderValue.Void;
				return true;
			} else if (charCode == JsonNotation.EndArrayCharCode) {
				this.frames.pop();
				this.token = ReaderToken.EndOfArray;
				this.value = ReaderValue.Void;
				return true;
			} else if (charCode == JsonNotation.EndObjectCharCode) {
				this.frames.pop();
				this.frames.pop();
				this.token = ReaderToken.EndOfObject;
				this.value = ReaderValue.Void;
				return true;
			} else {
				throw ReaderException.unknownNotation(this, lexeme);
			}
		} else if (lexeme.length == 4) {
			if (lexeme == JsonNotation.True) {
				this.token = memberOrValueToken;
				this.value = ReaderValue.Bool(true);
				return true;
			} else if (lexeme == JsonNotation.Null) {
				this.token = ReaderToken.Null;
				this.value = ReaderValue.Null;
				return true;
			}
		} else if (lexeme.length == 5) {
			if (lexeme == JsonNotation.False) {
				this.token = memberOrValueToken;
				this.value = ReaderValue.Bool(false);
				return true;
			}
		}

		if (lexeme.charCodeAt(0) == JsonNotation.QuoteCharCode) {
			if (lexeme.charCodeAt(lexeme.length - 1) != JsonNotation.QuoteCharCode) {
				return throw ReaderException.unterminatedStringLiteral(this, lexeme);
			}
			if (lexeme.length == 2) {
				this.token = memberOrValueToken;
				this.value = ReaderValue.String("");
				return true;
			} else {
				this.token = memberOrValueToken;
				this.value = ReaderValue.String(this.unescapeString(lexeme));
				return true;
			}
		}

		switch (this.getNumberType(lexeme)) {
			case NUMBER_INTEGER, NUMBER_NEGATIVE_INTEGER:
				if (lexeme.length < Int32MaxLength + (lexeme.charCodeAt(0) == JsonNotation.MinusCharCode ? 1 : 0)) {
					this.token = memberOrValueToken;
					this.value = ReaderValue.Int(Std.parseInt(lexeme) ?? 0);
					return true;
				} else {
					this.token = memberOrValueToken;
					this.value = ReaderValue.Int64(haxe.Int64.parseString(lexeme));
					return true;
				}
			case NUMBER_FLOAT:
				this.token = memberOrValueToken;
				this.value = ReaderValue.Float(Std.parseFloat(lexeme));
				return true;
			default:
				throw ReaderException.unknownNotation(this, lexeme);
		}
	}

	public function close() {
		if (!this.leaveOpen) {
			this.inputBuffer.close();
		}
		this.stringCache.clear();
	}

	private function unescapeString(lexeme:String):String {
		if (lexeme.indexOf("\\") < 0) {
			return lexeme.substr(1, lexeme.length - 2);
		}

		var unescapedBuff = new StringBuf();
		var index = 1;
		while (index < lexeme.length - 1) {
			var charCode = lexeme.charCodeAt(index);
			if (charCode == JsonNotation.EscapeCharCode) {
				charCode = this.getEscapedCharCode(lexeme, index);
				if (lexeme.charCodeAt(index + 1) == 117) { // 'u'
					index += 5;
				} else {
					index += 1;
				}
			}
			unescapedBuff.addChar(charCode);
			index++;
		}

		return unescapedBuff.toString();
	}

	private function getEscapedCharCode(lexeme:String, i:Int):Int {
		var nextCharCode = lexeme.charCodeAt(i + 1);
		switch (nextCharCode) {
			case 110:
				return 10;
			case 114:
				return 13;
			case 98:
				return 8;
			case 102:
				return 12;
			case 116:
				return 9;
			case JsonNotation.EscapeCharCode:
				return JsonNotation.EscapeCharCode;
			case JsonNotation.CommentCharCode:
				return JsonNotation.CommentCharCode;
			case 39:
				return 39;
			case JsonNotation.QuoteCharCode:
				return JsonNotation.QuoteCharCode;
			case 117: // 'u' \\
				var b0 = this.hexToByte(lexeme, i + 2);
				var b1 = this.hexToByte(lexeme, i + 4);
				return ((b0 << 8) | b1) & 0xFFFFFFFF;
			case _:
				throw ReaderException.unknownEscapeSequence(this, "\\" + lexeme.charAt(i + 1));
		}
	}

	private function hexToByte(lexeme:String, offset:Int) {
		var result = 0;
		for (i in 0...2) {
			var charCode = lexeme.charCodeAt(offset + i) ?? 0;
			var d = 0;
			if (charCode >= JsonNotation.ZeroCharCode && charCode <= JsonNotation.NineCharCode)
				d = (charCode - JsonNotation.ZeroCharCode);
			else if (charCode >= JsonNotation.ALowerCaseCharCode && charCode <= JsonNotation.FLowerCaseCharCode)
				d = 10 + (charCode - JsonNotation.ALowerCaseCharCode);
			else if (charCode >= JsonNotation.AUpperCaseCharCode && charCode <= JsonNotation.FUpperCaseCharCode)
				d = 10 + (charCode - JsonNotation.AUpperCaseCharCode);
			else
				throw ReaderException.unknownNotation(this, lexeme.substr(offset, 2));

			result = 16 * result + d;
		}
		return result;
	}

	private function getNumberType(lexeme:String):Int {
		var index = 0;
		var signed = false;

		if (lexeme.charCodeAt(0) == JsonNotation.MinusCharCode) {
			signed = true;
			index = 1;
		}

		while (index < lexeme.length) {
			var charCode = lexeme.charCodeAt(index);
			if (charCode < JsonNotation.ZeroCharCode || charCode > JsonNotation.NineCharCode) {
				return NUMBER_FLOAT;
			}
			index++;
		}
		return signed ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
	}

	private function nextLexeme():String {
		var state = LEXER_STATE_COMPLETE;

		while (this.lexemeBuff.length > 0) {
			this.lexemeBuff.pop();
		}

		while (true) {
			this.columnNumber++;

			if (state == LEXER_STATE_COMPLETE) {
				state = LEXER_STATE_START;
			}

			var charCode = this.readNexCharCode();
			switch (state) {
				case LEXER_STATE_START:
					if (charCode == JsonNotation.NewlineCharCode) {
						this.lineNumber++;
						this.columnNumber = 0;
					} else if (charCode == JsonNotation.SpaceCharCode
						|| charCode == JsonNotation.ReturnCharCode
						|| charCode == JsonNotation.TabCharCode
						|| charCode == JsonNotation.IdentifierSeparatorCharCode) {
						continue; // insignificant whitespaces
					} else if (charCode == JsonNotation.ValueSeparatorCharCode) {
						if (this.frames.head.elt == ReaderToken.BeginObject) {
							throw ReaderException.readingBrokenDocument(this, "A value is expected");
						}
					} else if (charCode == JsonNotation.CommentCharCode) {
						state = LEXER_STATE_COMMENT_BEGINNING;
						continue;
					} else if (charCode == JsonNotation.EndArrayCharCode) {
						return JsonNotation.EndArray;
					} else if (charCode == JsonNotation.EndObjectCharCode) {
						return JsonNotation.EndObject;
					} else if (charCode == JsonNotation.BeginObjectCharCode) {
						return JsonNotation.BeginObject;
					} else if (charCode == JsonNotation.BeginArrayCharCode) {
						return JsonNotation.BeginArray;
					} else {
						if (this.isWhiteSpaceLatin(charCode)) {
							continue;
						}
						this.lexemeBuff.push(charCode);
						state = (charCode == JsonNotation.QuoteCharCode ? LEXER_STATE_QUOTED : LEXER_STATE_LEXEME);
					}
				case LEXER_STATE_LEXEME:
					if (isWhiteSpaceLatin(charCode)
						|| charCode == JsonNotation.SpaceCharCode
						|| charCode == JsonNotation.NewlineCharCode
						|| charCode == JsonNotation.ReturnCharCode
						|| charCode == JsonNotation.TabCharCode
						|| charCode == JsonNotation.IdentifierSeparatorCharCode
						|| charCode == JsonNotation.ValueSeparatorCharCode
						|| charCode == JsonNotation.EndArrayCharCode
						|| charCode == JsonNotation.EndObjectCharCode
						|| charCode == JsonNotation.BeginObjectCharCode
						|| charCode == JsonNotation.BeginArrayCharCode) {
						this.utf8Buff.unshift(charCode);
						return this.lexemeToString();
					} else {
						this.lexemeBuff.push(charCode);
					}
				case LEXER_STATE_QUOTED, LEXER_STATE_QUOTED_ESCAPE:
					if (charCode == JsonNotation.NewlineCharCode || charCode == JsonNotation.ReturnCharCode) {
						throw ReaderException.unterminatedStringLiteral(this, this.lexemeToString());
					} else if (charCode == JsonNotation.QuoteCharCode) {
						this.lexemeBuff.push(charCode);
						if (state == LEXER_STATE_QUOTED_ESCAPE) {
							state = LEXER_STATE_QUOTED;
						} else {
							return this.lexemeToString();
						}
					} else if (charCode == JsonNotation.EscapeCharCode) {
						this.lexemeBuff.push(charCode);
						state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
					} else {
						this.lexemeBuff.push(charCode);
						if (state == LEXER_STATE_QUOTED_ESCAPE) {
							state = LEXER_STATE_QUOTED;
						}
					}
				case LEXER_STATE_COMMENT_BEGINNING:
					if (charCode == JsonNotation.CommentCharCode) {
						state = LEXER_STATE_COMMENT_SINGLE_LINE;
					} else if (charCode == JsonNotation.CommentMultilineCharCode) {
						state = LEXER_STATE_COMMENT_MULTILINE;
					} else {
						throw ReaderException.unknownNotation(this, JsonNotation.Comment + "\\u" + Std.string(charCode));
					}
				case LEXER_STATE_COMMENT_SINGLE_LINE:
					if (charCode == JsonNotation.NewlineCharCode || charCode == JsonNotation.ReturnCharCode) {
						state = LEXER_STATE_START; // skip comment, start over again
					}
				case LEXER_STATE_COMMENT_MULTILINE, LEXER_STATE_COMMENT_MULTILINE_ENDING:
					if (charCode == JsonNotation.CommentMultilineCharCode) {
						state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
					} else if (charCode == JsonNotation.CommentCharCode) {
						if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING) {
							state = LEXER_STATE_START; // skip comment, start over again
						}
					}
				default:
					state = LEXER_STATE_START;
			}
		}
	}

	private function lexemeToString():String {
		if (this.lexemeBuff.length == 0) {
			return "";
		}

		var lexemeKey:Int64 = 0;
		if (this.useStringCache && this.lexemeBuff.length <= 8) {
			// compute Int64 key from this short lexeme
			for (charCode in this.lexemeBuff) {
				if (charCode >= 256) {
					lexemeKey = 0;
					break;
				}
				lexemeKey = (lexemeKey << 8) | charCode;
			}
		}

		if (lexemeKey != 0 && this.stringCache.exists(lexemeKey)) {
			return this.stringCache.get(lexemeKey) ?? "";
		}

		var stringBuff = new StringBuf();
		for (charCode in this.lexemeBuff) {
			stringBuff.addChar(charCode);
		}
		var lexeme = stringBuff.toString();
		if (lexemeKey != 0) {
			this.stringCache.set(lexemeKey, lexeme);
		}
		return lexeme;
	}

	private function isWhiteSpaceLatin(codePoint:Int) {
		return codePoint == JsonNotation.SpaceCharCode
			|| (codePoint >= JsonNotation.TabCharCode && codePoint <= JsonNotation.ReturnCharCode)
			|| (codePoint == JsonNotation.NoBreakSpaceCharCode);
	}

	private function readNexCharCode():Int {
		if (this.utf8Buff.length == 0) {
			this.fillUtf8Buff();
		}
		if (this.utf8Buff.length == 0) {
			throw ReaderException.unexpectedEndOfStream(this);
		}
		return this.utf8Buff.shift();
	}

	private function fillUtf8Buff() {
		var byte1 = this.inputBuffer.readByte() ?? 0;
		if ((byte1 & 0x80) == 0) {
			// 1 byte
			this.utf8Buff.push(byte1);
		} else if ((byte1 & 0xe0) == 0xc0) {
			// 2 bytes
			var byte2 = this.inputBuffer.readByte() & 0x3f;
			this.utf8Buff.push(((byte1 & 0x1f) << 6) | byte2);
		} else if ((byte1 & 0xf0) == 0xe0) {
			// 3 bytes
			var byte2 = this.inputBuffer.readByte() & 0x3f;
			var byte3 = this.inputBuffer.readByte() & 0x3f;
			this.utf8Buff.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
		} else if ((byte1 & 0xf8) == 0xf0) {
			// 4 bytes
			var byte2 = this.inputBuffer.readByte() & 0x3f;
			var byte3 = this.inputBuffer.readByte() & 0x3f;
			var byte4 = this.inputBuffer.readByte() & 0x3f;
			var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
			// split in surrogate pair if it is UC2 runtime
			if (IS_UC2_RUNTIME && unit > 0xffff) {
				unit -= 0x10000;
				this.utf8Buff.push(((unit >>> 10) & 0x3ff) | 0xd800);
				unit = 0xdc00 | (unit & 0x3ff);
			}
			this.utf8Buff.push(unit);
		} else {
			this.utf8Buff.push(byte1);
		}
	}
}
class JsonNotation {
	public static inline var Tab = "\t";
	public static inline var TabCharCode = 9;
	public static inline var Space = " ";
	public static inline var SpaceCharCode = 32;
	public static inline var NoBreakSpaceCharCode = 160;
	public static inline var Newline = "\n";
	public static inline var NewlineCharCode = 10;
	public static inline var NextLineCharCode = 10;
	public static inline var Return = "\r";
	public static inline var ReturnCharCode = 13;
	public static inline var IdentifierSeparator = ":";
	public static inline var IdentifierSeparatorCharCode = 58;
	public static inline var ValueSeparator = ",";
	public static inline var ValueSeparatorCharCode = 44;
	public static inline var BeginArray = "[";
	public static inline var BeginArrayCharCode = 91;
	public static inline var EndArray = "]";
	public static inline var EndArrayCharCode = 93;
	public static inline var BeginObject = "{";
	public static inline var BeginObjectCharCode = 123;
	public static inline var EndObject = "}";
	public static inline var EndObjectCharCode = 125;
	public static inline var Escape = "\\";
	public static inline var EscapeCharCode = 92;
	public static inline var Comment = "/";
	public static inline var CommentCharCode = 47;
	public static inline var CommentMultiline = "*";
	public static inline var CommentMultilineCharCode = 42;
	public static inline var Quote = "\"";
	public static inline var QuoteCharCode = 34;

	public static inline var ZeroCharCode = 48;
	public static inline var NineCharCode = 57;
	public static inline var ALowerCaseCharCode = 97;
	public static inline var AUpperCaseCharCode = 65;
	public static inline var FLowerCaseCharCode = 102;
	public static inline var FUpperCaseCharCode = 70;

	public static inline var MinusCharCode = 45;

	public static inline var True = "true";
	public static inline var False = "false";
	public static inline var Null = "null";
}
interface LineInfo
{
    public function get_lineNumber():Int;
    public function get_columnNumber():Int;
}
class MessagePackExtentionType {
	public static inline var None: Int = 0;
	public static inline var DateTime: Int = 40;
	public static inline var DateTimeOffset: Int = 41;
	public static inline var Decimal: Int = 42;
}
class MessagePackGameDataReader extends GameDataReader {
	private static inline var DEFAULT_BUFFER_SIZE:Int = 65 * 1024 * 1024;
	private static inline var MAX_BINARY_LENGTH:Int = 16 * 1024 * 1024;
	private static inline var MAX_STRING_LENGTH:Int = 16 * 1024 * 1024;

	private var inputBuffer:BufferInput;
	private var stringCache:Map<Int64, String>;
	private var leaveOpen:Bool;
	private var useStringCache:Bool;
	private var frames:GenericStack<{
		public var token:ReaderToken;
		public var counter:Int;
	}>;

	private var totalBytesRead:Int;

	public function get_lineNumber() {
		return 0;
	};

	public function get_columnNumber() {
		return this.totalBytesRead;
	}

	public function new(input:Input, leaveOpen:Bool, useStringCache: Bool, bufferSize:Int = DEFAULT_BUFFER_SIZE) {
		if (input == null)
			throw 'input cannot be null';

		super();

		this.inputBuffer = new BufferInput(input, haxe.io.Bytes.alloc(bufferSize));
		this.inputBuffer.bigEndian = true;

		this.leaveOpen = leaveOpen;
		this.useStringCache = useStringCache;
		this.frames = new GenericStack();
		this.stringCache = new Map();
	}

	public function nextToken():Bool {
		this.token = ReaderToken.None;
		this.value = ReaderValue.Void;

		if (!this.frames.isEmpty() && this.frames.head.elt.counter == 0) {
			var openingFrame = this.frames.pop();
			this.token = openingFrame.token;
			this.value = ReaderValue.Void;
			this.decrementClosingTokenCounter();
			return true;
		}

		try {
			if (this.inputBuffer.available <= 0) {
				this.inputBuffer.refill();
			}

			if (this.inputBuffer.available <= 0) {
				this.token = ReaderToken.EndOfStream;
				this.value = ReaderValue.Void;
				return false;
			}

			var fieldType = this.inputBuffer.readByte();
			if (fieldType >= MessagePackType.FixArrayStart && fieldType <= MessagePackType.FixArrayEnd) {
				var arrayCount = fieldType - MessagePackType.FixArrayStart;

				this.frames.add({
					token: ReaderToken.EndOfArray,
					counter: arrayCount + 1
				});
				this.token = ReaderToken.BeginArray;
				this.value = ReaderValue.Void;
			} else if (fieldType >= MessagePackType.FixStrStart && fieldType <= MessagePackType.FixStrEnd) {
				var strCount = fieldType - MessagePackType.FixStrStart;
				var strBytes = this.readBytes(strCount);

				var token = ReaderToken.Value;
				if (!this.frames.isEmpty()) {
					var openingFrame = this.frames.head.elt;
					if (openingFrame.token == ReaderToken.EndOfObject && openingFrame.counter > 0 && openingFrame.counter % 2 == 0) {
						token = ReaderToken.Member;
					}
				}

				var strValue = this.bytesToString(strBytes);
				this.token = token;
				this.value = ReaderValue.String(strValue);
			} else if (fieldType >= MessagePackType.FixMapStart && fieldType <= MessagePackType.FixMapEnd) {
				var mapCount = fieldType - MessagePackType.FixMapStart;
				this.frames.add({token: ReaderToken.EndOfObject, counter: mapCount * 2 + 1});
				this.token = ReaderToken.BeginObject;
				this.value = ReaderValue.Void;
			} else if (fieldType >= MessagePackType.NegativeFixIntStart) {
				this.token = ReaderToken.Value;
				if (fieldType >= 128) {
					this.value = ReaderValue.Int(fieldType - 256);
				} else {
					this.value = ReaderValue.Int(fieldType);
				}
			} else if (fieldType <= MessagePackType.PositiveFixIntEnd) {
				this.token = ReaderToken.Value;
				this.value = ReaderValue.Int(fieldType);
			} else {
				switch (fieldType) {
					case MessagePackType.Nil:
						this.token = ReaderToken.Null;
						this.value = ReaderValue.Null;
					case MessagePackType.Array16, MessagePackType.Array32:
						var arrayCount = 0;
						if (fieldType == MessagePackType.Array16) {
							arrayCount = this.inputBuffer.readUInt16();
						} else if (fieldType == MessagePackType.Array32) {
							arrayCount = haxe.Int64.toInt(this.readUInt32());
						}

						if (arrayCount < 0) {
							throw ReaderException.readingBrokenDocument(this, "negative size of array");
						}

						this.frames.add({token: ReaderToken.EndOfArray, counter: arrayCount + 1});
						this.token = ReaderToken.BeginArray;
						this.value = ReaderValue.Void;
					case MessagePackType.Map16, MessagePackType.Map32:
						var mapCount = 0;
						if (fieldType == MessagePackType.Map16) {
							mapCount = this.inputBuffer.readUInt16();
						} else if (fieldType == MessagePackType.Map32) {
							mapCount = haxe.Int64.toInt(this.readUInt32());
						}

						if (mapCount < 0) {
							throw ReaderException.readingBrokenDocument(this, "negative size of map");
						}

						this.frames.add({token: ReaderToken.EndOfObject, counter: mapCount * 2 + 1});
						this.token = ReaderToken.BeginObject;
						this.value = ReaderValue.Void;
					case MessagePackType.Str8, MessagePackType.Str16, MessagePackType.Str32:
						var strBytesCount = 0;
						if (fieldType == MessagePackType.Str8) {
							strBytesCount = this.inputBuffer.readByte();
						} else if (fieldType == MessagePackType.Str16) {
							strBytesCount = this.inputBuffer.readUInt16();
						} else if (fieldType == MessagePackType.Str32) {
							strBytesCount = haxe.Int64.toInt(this.readUInt32());
						}

						var token = ReaderToken.Value;
						if (!this.frames.isEmpty()) {
							var openingFrame = this.frames.head.elt;
							if (openingFrame.token == ReaderToken.EndOfObject && openingFrame.counter > 0 && openingFrame.counter % 2 == 0)
								token = ReaderToken.Member;
						}

						if (strBytesCount > MAX_STRING_LENGTH)
							throw ReaderException.stringLiteralIsTooLong(this, strBytesCount, MAX_STRING_LENGTH);

						var strBytes = this.readBytes(strBytesCount);
						var stringValue = this.bytesToString(strBytes);

						this.token = token;
						this.value = ReaderValue.String(stringValue);
					case MessagePackType.Bin8, MessagePackType.Bin16, MessagePackType.Bin32:
						var bytesCount = 0;
						if (fieldType == MessagePackType.Bin8) {
							bytesCount = this.inputBuffer.readByte();
						} else if (fieldType == MessagePackType.Bin16) {
							bytesCount = this.inputBuffer.readUInt16();
						} else if (fieldType == MessagePackType.Bin32) {
							bytesCount = haxe.Int64.toInt(this.readUInt32());
						}

						if (bytesCount > MAX_BINARY_LENGTH) {
							throw ReaderException.binaryDataIsTooLong(this, bytesCount, MAX_BINARY_LENGTH);
						}
						if (bytesCount < 0) {
							throw ReaderException.readingBrokenDocument(this, "negative size of binary data");
						}

						var bytes = this.readBytes(bytesCount);
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Bytes(bytes);
					case MessagePackType.FixExt1, MessagePackType.FixExt2, MessagePackType.FixExt4, MessagePackType.FixExt8, MessagePackType.FixExt16,
						MessagePackType.Ext8, MessagePackType.Ext16, MessagePackType.Ext32:
						var extLength = 0;
						if (fieldType == MessagePackType.FixExt1)
							extLength = 1;
						else if (fieldType == MessagePackType.FixExt2)
							extLength = 2;
						else if (fieldType == MessagePackType.FixExt4)
							extLength = 4;
						else if (fieldType == MessagePackType.FixExt8)
							extLength = 8;
						else if (fieldType == MessagePackType.FixExt16)
							extLength = 16;
						if (fieldType == MessagePackType.Ext8) {
							extLength = this.inputBuffer.readByte();
						} else if (fieldType == MessagePackType.Ext16) {
							extLength = this.inputBuffer.readUInt16();
						} else if (fieldType == MessagePackType.Ext32) {
							extLength = haxe.Int64.toInt(this.readUInt32());
						}

						// var extType = this.inputBuffer.readByte();
						if (extLength > MAX_BINARY_LENGTH) {
							throw ReaderException.binaryDataIsTooLong(this, extLength, MAX_BINARY_LENGTH);
						}

						var bytes = this.readBytes(extLength);
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Bytes(bytes);
					case MessagePackType.False:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Bool(false);
					case MessagePackType.True:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Bool(true);
					case MessagePackType.Float32:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Float(this.inputBuffer.readFloat());
					case MessagePackType.Float64:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Float(this.inputBuffer.readDouble());
					case MessagePackType.Int16:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int(this.inputBuffer.readInt16());
					case MessagePackType.Int32:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int(this.inputBuffer.readInt32());
					case MessagePackType.Int64:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int64(this.readInt64());
					case MessagePackType.Int8:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int(this.inputBuffer.readInt8());
					case MessagePackType.UInt16:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int(this.inputBuffer.readUInt16());
					case MessagePackType.UInt32:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int64(this.readUInt32());
					case MessagePackType.UInt64:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int64(this.readInt64());
					case MessagePackType.UInt8:
						this.token = ReaderToken.Value;
						this.value = ReaderValue.Int64(this.inputBuffer.readByte());
					default:
						throw ReaderException.unknownMessagePackType(this, Std.string(fieldType));
				}
			}
		} catch (eof:Eof) {
			this.token = ReaderToken.EndOfStream;
			this.value = ReaderValue.Void;
			return false;
		}

		this.decrementClosingTokenCounter();

		return true;
	}

	public function close() {
		if (!this.leaveOpen) {
			this.inputBuffer.close();
		}
	}

	private function readUInt32():Int64 {
		var b0:UInt = this.inputBuffer.readByte();
		var b1:UInt = this.inputBuffer.readByte();
		var b2:UInt = this.inputBuffer.readByte();
		var b3:UInt = this.inputBuffer.readByte();
		var n = ((b0 << 24) | (b1 << 16) | (b2 << 8) | b3);

		var result = haxe.Int64.make(0, n);
		return result;
	}

	private function readInt64():Int64 {
		var b0 = this.inputBuffer.readByte();
		var b1 = this.inputBuffer.readByte();
		var b2 = this.inputBuffer.readByte();
		var b3 = this.inputBuffer.readByte();
		var b4 = this.inputBuffer.readByte();
		var b5 = this.inputBuffer.readByte();
		var b6 = this.inputBuffer.readByte();
		var b7 = this.inputBuffer.readByte();

		return haxe.Int64.make((b0 << 24) | (b1 << 16) | (b2 << 8) | b3, (b4 << 24) | (b5 << 16) | (b6 << 8) | b7);
	}

	private function readBytes(bytesCount:Int):Bytes {
		var bytes = haxe.io.Bytes.alloc(bytesCount);
		var offset = 0;

		while (bytesCount > 0) {
			var read = this.inputBuffer.readBytes(bytes, offset, bytesCount);
			offset += read;
			bytesCount -= read;
			if (read == 0) {
				break;
			}
		}

		if (bytesCount > 0) {
			throw ReaderException.unexpectedEndOfStream(this);
		}
		return bytes;
	}

	private function bytesToString(strBytes:Bytes) {
		var lexemeKey:Int64 = 0;
		if (this.useStringCache && strBytes.length <= 8) {
			for (i in 0...strBytes.length) {
				var charCode = strBytes.get(i);
				if (charCode >= 256) {
					lexemeKey = 0;
					break;
				}
				lexemeKey = (lexemeKey << 8) | charCode;
			}
		}

		if (lexemeKey != 0 && this.stringCache.exists(lexemeKey)) {
			return this.stringCache.get(lexemeKey) ?? "";
		}

		var lexeme = strBytes.toString();
		if (lexemeKey != 0) {
			this.stringCache.set(lexemeKey, lexeme);
		}
		return lexeme;
	}

	private function decrementClosingTokenCounter() {
		if (this.frames.isEmpty()) {
			return;
		}
		var openingFrame = this.frames.pop();
		openingFrame.counter = openingFrame.counter - 1;
		this.frames.add(openingFrame);
	}
}
class MessagePackType {
	public static inline var PositiveFixIntStart:Int = 0x00;
	public static inline var PositiveFixIntEnd:Int = 0x7f;
	public static inline var FixMapStart:Int = 0x80;
	public static inline var FixMapEnd:Int = 0x8f;
	public static inline var FixArrayStart:Int = 0x90;
	public static inline var FixArrayEnd:Int = 0x9f;
	public static inline var FixStrStart:Int = 0xa0;
	public static inline var FixStrEnd:Int = 0xbf;
	public static inline var Nil:Int = 0xc0;
	public static inline var Unused:Int = 0xc1;
	public static inline var False:Int = 0xc2;
	public static inline var True:Int = 0xc3;
	public static inline var Bin8:Int = 0xc4;
	public static inline var Bin16:Int = 0xc5;
	public static inline var Bin32:Int = 0xc6;
	public static inline var Ext8:Int = 0xc7;
	public static inline var Ext16:Int = 0xc8;
	public static inline var Ext32:Int = 0xc9;
	public static inline var Float32:Int = 0xca;
	public static inline var Float64:Int = 0xcb;
	public static inline var UInt8:Int = 0xcc;
	public static inline var UInt16:Int = 0xcd;
	public static inline var UInt32:Int = 0xce;
	public static inline var UInt64:Int = 0xcf;
	public static inline var Int8:Int = 0xd0;
	public static inline var Int16:Int = 0xd1;
	public static inline var Int32:Int = 0xd2;
	public static inline var Int64:Int = 0xd3;
	public static inline var FixExt1:Int = 0xd4;
	public static inline var FixExt2:Int = 0xd5;
	public static inline var FixExt4:Int = 0xd6;
	public static inline var FixExt8:Int = 0xd7;
	public static inline var FixExt16:Int = 0xd8;
	public static inline var Str8:Int = 0xd9;
	public static inline var Str16:Int = 0xda;
	public static inline var Str32:Int = 0xdb;
	public static inline var Array16:Int = 0xdc;
	public static inline var Array32:Int = 0xdd;
	public static inline var Map16:Int = 0xde;
	public static inline var Map32:Int = 0xdf;
	public static inline var NegativeFixIntStart:Int = 0xe0;
	public static inline var NegativeFixIntEnd:Int = 0xff;
}
class ReaderException extends haxe.Exception {
	public var lineNumber:Int;
	public var columnNumber:Int;

	public function new(message:String, lineInfo:LineInfo) {
		super(message);

		if (lineInfo == null)
			throw 'lineInfo cannot be null';

		this.lineNumber = lineInfo.get_lineNumber();
		this.columnNumber = lineInfo.get_columnNumber();
	}

	public static function unexpectedEndOfStream(lineInfo:LineInfo):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("Unexpected end of stream.", lineInfo);
	}

	public static function unexpectedToken(lineInfo:LineInfo, token:ReaderToken, value:ReaderValue, ?expectedTokens:Array<ReaderToken>):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		if (expectedTokens == null)
			throw 'expectedTokens cannot be null';
		var tokensStr:String = "<no tokens>";
		if (expectedTokens.length > 0) {
			tokensStr = expectedTokens.map(function(token) return Std.string(token)).join(", ");
		}
		return new ReaderException("Expected one of these '" + tokensStr + "' but found '" + token + "'("
			+ (value != ReaderValue.Void ? value.getName() : "<null>") + ").", lineInfo);
	}

	public static function unknownEscapeSequence(lineInfo:LineInfo, escape:String):ReaderException {
		if (escape == null)
			throw 'escape cannot be null';
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("An unknown escape sequence '" + escape + "'.", lineInfo);
	}

	public static function unterminatedStringLiteral(lineInfo:LineInfo, literal:String):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("An unterminated string literal - '" + literal + "'.", lineInfo);
	}

	public static function unknownNotation(lineInfo:LineInfo, notation:String):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("An unknown notation '" + notation + "'.", lineInfo);
	}

	public static function stringLiteralIsTooLong(lineInfo:LineInfo, size:Int, maxSize:Int):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("String literal is too long '" + size + "'. Maximum size is " + maxSize + ".", lineInfo);
	}

	public static function binaryDataIsTooLong(lineInfo:LineInfo, size:Int, maxSize:Int):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("Binary data is too long '" + size + "'. Maximum size is " + maxSize + ".", lineInfo);
	}

	public static function readingBrokenDocument(lineInfo:LineInfo, additionalInformation:String):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("Failed to continue deserialize because document's structure is invalid. Additional information: " + additionalInformation,
			lineInfo);
	}

	public static function unknownMessagePackType(lineInfo:LineInfo, type:String):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("An unknown Message Pack type '" + type + "'.", lineInfo);
	}

	public static function unexpectedNullValue(lineInfo:LineInfo, expected:String, propertyName:String, schemaName:String):ReaderException {
		if (lineInfo == null)
			throw 'lineInfo cannot be null';
		return new ReaderException("A null value is deserialized instead of " + expected + " for required property '" + propertyName + "' in schema '"
			+ schemaName + "'.", lineInfo);
	}
}
enum ReaderToken {
	None;
	BeginArray;
	EndOfArray;
	BeginObject;
	EndOfObject;
	Member;
	Null;
	Value;
	Comment;
	EndOfStream;
}
enum ReaderValue {
	Void;
	Null;
	Bool(value:Bool);
	Int(value:Int);
	Int64(value:Int64);
	String(value:String);
	Bytes(value:Bytes);
	Float(value:Float);
	Document(value:Map<String, ReaderValue>);
	Collection(value:Array<ReaderValue>);
}
<#+ 
	}
#>
