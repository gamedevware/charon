<#+
	private void WriteFormula(FormulaDefinition formulaDef, CodeGenerationContext context)
	{
		var expressionGenericArguments = new string[formulaDef.ParameterTypes.Length + 1];
		for (var parameterIndex = 0; parameterIndex < formulaDef.ParameterTypes.Length; parameterIndex++)
		{
			expressionGenericArguments[parameterIndex] = formulaDef.ParameterTypes[parameterIndex].TypeName;
		}
		expressionGenericArguments[expressionGenericArguments.Length - 1] = formulaDef.ReturnType.TypeName;
		var functionType = "Func<" + string.Join(", ", expressionGenericArguments) + ">";
		var invokeParameters = string.Join(", ", formulaDef.ParameterNames.Select((n, i) => formulaDef.ParameterTypes[i] + " " + n).ToArray());
		var lambdaExpressionType = "Expression<" + functionType + ">";
#>	/// <summary>
	/// <#= formulaDef.Description #>
	/// </summary>
	[GeneratedCode(<#= context.TargetLanguage.GameDataClassName #>.GeneratorName, <#= context.TargetLanguage.GameDataClassName #>.GeneratorVersion)]
	public partial class <#= formulaDef #>
	{
#if USE_DYNAMIC_EXPRESSIONS
		private static readonly GameDevWare.Dynamic.Expressions.Binder ExpressionBinder;

		private readonly <#= lambdaExpressionType #> expression;
		private System.Linq.Expressions.Expression globalExpression;
		private <#= functionType #> compiledExpression;

		static <#= formulaDef #>()
		{
			var formulaTypes = new Type[]
			{
<#+
		for (var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>
				typeof(<#= formulaDef.ParameterTypes[p] #>),
<#+
		}
#>
<#+
		foreach (var knownType in formulaDef.Specification.GetKnownTypes())
		{
#>
				typeof(<#= knownType #>),
<#+
		}
#>
				typeof(<#= formulaDef.ReturnType #>)
			};

			var parameters = new ParameterExpression[]
			{
<#+
		for(var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>
				Expression.Parameter(typeof(<#= formulaDef.ParameterTypes[p] #>), "<#= formulaDef.ParameterRawNames[p] #>"),
<#+
		}
#>
			};

			var typeResolver = new GameDevWare.Dynamic.Expressions.KnownTypeResolver(formulaTypes, <#= context.TargetLanguage.GameDataClassName #>.TypeResolver);
			ExpressionBinder = new GameDevWare.Dynamic.Expressions.Binder(parameters, typeof(<#= formulaDef.ReturnType #>), typeResolver);

			// AOT preparation
			if (typeof(object).Name == string.Empty)
			{
<#+
		foreach(var knownType in formulaDef.Specification.GetKnownTypes())
		{
#>
				new System.Runtime.CompilerServices.StrongBox<<#= knownType #>>(default(<#= knownType #>));
<#+
		}
#>
			}
			GameDevWare.Dynamic.Expressions.AotCompilation.RegisterFunc<<#= string.Join(", ", expressionGenericArguments) #>>();
		}
		public <#= formulaDef #>(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));

			var syntaxTreeNode = new GameDevWare.Dynamic.Expressions.SyntaxTreeNode((IDictionary<string, object>)expressionTree);
			this.expression = (<#=lambdaExpressionType#>)<#= formulaDef #>.ExpressionBinder.Bind(syntaxTreeNode, this.globalExpression);
		}

		/// <summary>
		/// Sets the root provider for global identifiers. Properties and methods of this
		/// object can be referenced directly within the formula without a qualifier.
		/// </summary>
		public void SetGlobal<T>(T globalObject)
		{
			this.globalExpression = Expression.Constant(globalObject);
		}

		public <#= formulaDef.ReturnType #> Invoke(<#= invokeParameters #>)
		{
			var __fn = this.CompileAot();
			return __fn.Invoke(<#= string.Join(", ", formulaDef.ParameterNames) #>);
		}

		public <#= functionType #> CompileAot()
		{
			try
			{
				if (this.compiledExpression == null)
				{
					this.compiledExpression = this.expression.CompileAot();
				}
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}
		public <#= functionType #> Compile()
		{
			try
			{
				if (this.compiledExpression == null)
				{
					this.compiledExpression = this.expression.Compile();
				}
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}
#elif !SUPPRESS_BUILD_IN_FORMULAS
		private static readonly Formulas.IFormulaTypeResolver TypeResolver;

		private Formulas.FormulaExpression expression;
		private object globalObject;

		/// <summary>
		/// Gets or sets a value indicating whether null propagation should be applied
		/// implicitly to this formula during evaluation or code generation.
		/// </summary>
		public bool AutoNullPropagation { get; set; }

		static <#= formulaDef #>()
		{
			var formulaTypes = new Type[]
			{
<#+
		for (var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>
				typeof(<#= formulaDef.ParameterTypes[p] #>),
<#+
		}
#>
<#+
		foreach (var knownType in formulaDef.Specification.GetKnownTypes())
		{
#>
				typeof(<#= knownType #>),
<#+
		}
#>
				typeof(<#= formulaDef.ReturnType #>),
			};

			TypeResolver = new Formulas.KnownFormulaTypeResolver(formulaTypes, Formulas.FormulaOptions.None, <#= context.TargetLanguage.GameDataClassName #>.TypeResolver);
			// AOT
			Formulas.FormulaExpression.RegisterFunc<<#= string.Join(", ", expressionGenericArguments) #>>();
		}
		public <#= formulaDef #>(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));

			this.expression = Formulas.FormulaExpression.Create(expressionTree, typeof(<#= formulaDef.ReturnType #>));
		}

		/// <summary>
		/// Sets the root provider for global identifiers. Properties and methods of this
		/// object can be referenced directly within the formula without a qualifier.
		/// </summary>
		public void SetGlobal<T>(T globalObject)
		{
			this.globalObject = globalObject;
		}

		public <#= formulaDef.ReturnType #> Invoke(<#= invokeParameters #>)
		{
			var __lambdaArguments = new Dictionary<string, Formulas.VariableValue>();

<#+
		for (var p = 0; p < formulaDef.ParameterNames.Length; p++)
		{
#>			__lambdaArguments["<#= formulaDef.ParameterRawNames[p] #>"] = new Formulas.VariableValue(<#= formulaDef.ParameterNames[p] #>);
<#+
		}
#>

			var __globalObject = new Formulas.VariableValue(this.globalObject);
			var __executionContext = new Formulas.FormulaExecutionContext(__lambdaArguments, typeResolver: <#= formulaDef #>.TypeResolver, global: __globalObject, autoNullPropagation: this.AutoNullPropagation);
			var __result = this.expression.Execute(__executionContext);
			return __result.To<<#= formulaDef.ReturnType #>>();
		}
#else
		public <#= formulaDef #>(IReadOnlyDictionary<string, object> expressionTree)
		{
			if (expressionTree == null) throw new ArgumentNullException(nameof(expressionTree));
		}

		/// <summary>
		/// Sets the root provider for global identifiers. Properties and methods of this
		/// object can be referenced directly within the formula without a qualifier.
		/// </summary>
		public void SetGlobal<T>(T globalObject)
		{

		}

		/// <summary>
		/// Evaluates the formula and returns the resulting value.
		/// </summary>
		public <#= formulaDef.ReturnType #> Invoke(<#= invokeParameters #>)
		{
			throw new NotSupportedException();
		}
#endif

		/// <summary>
		/// Returns a string representation of the formula's Abstract Syntax Tree (AST)
		/// or its equivalent source code.
		/// </summary>
		/// <returns>A string that represents the current formula.</returns>
		public override string ToString()
		{
			return this.expression.ToString();
		}
	}
<#+
	}
#>
