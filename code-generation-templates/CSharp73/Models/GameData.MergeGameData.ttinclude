<#+
	private void WriteReadGameDataMergeCode(CodeGenerationContext context)
	{
		if (context.DisablePatching)
		{
			return;
		}
#>
		#region Merge Game Data

		public Formatters.IndexedDictionary<string, object> MergeGameData(IReadOnlyDictionary<string, object> gameDataDocument, IReadOnlyDictionary<string, object> patchDocument)
		{
			gameDataDocument.TryGetValue("Collections", out var gameDataCollectionsObj);
			var gameDataCollections = gameDataCollectionsObj as IReadOnlyDictionary<string, object> ?? new Formatters.IndexedDictionary<string,object>();
			patchDocument.TryGetValue("Collections", out var patchCollectionsObj);
			var patchCollections = patchCollectionsObj as IReadOnlyDictionary<string, object> ?? new Formatters.IndexedDictionary<string,object>();

			var newGameDataDocument = new Formatters.IndexedDictionary<string, object>(gameDataDocument);
			var newCollections = new Formatters.IndexedDictionary<string, object>(gameDataCollections);

			var visitedSchemas = new HashSet<string>(StringComparer.Ordinal);
			foreach (var schemaName in gameDataCollections.Keys.Concat(patchCollections.Keys))
			{
				if (visitedSchemas.Contains(schemaName)) {
					continue; // already has been visited
				}

				var gameDataDocumentCollection = default(object);
				var patchDocumentCollection = default(object);
#pragma warning disable 1522 // Empty switch block
				switch (schemaName)
				{
<#+
		foreach (var typeDef in context.ObjectModel.Types)
		{
#>
					case "<#= typeDef.Schema.Id #>":
					case "<#= typeDef.Schema.Name #>":
						visitedSchemas.Add("<#= typeDef.Schema.Id #>");
						visitedSchemas.Add("<#= typeDef.Schema.Name #>");

						if (!gameDataCollections.TryGetValue("<#= typeDef.Schema.Id #>", out gameDataDocumentCollection)) {
							gameDataCollections.TryGetValue("<#= typeDef.Schema.Name #>", out gameDataDocumentCollection);
						}
						if (!patchCollections.TryGetValue("<#= typeDef.Schema.Id #>", out patchDocumentCollection)) {
							patchCollections.TryGetValue("<#= typeDef.Schema.Name #>", out patchDocumentCollection);
						}

						if (gameDataDocumentCollection == null || patchDocumentCollection == null)
						{
							newCollections["<#= typeDef.Schema.Name #>"] = gameDataDocumentCollection ?? patchDocumentCollection;
						}
						else
						{
							newCollections["<#= typeDef.Schema.Name #>"] = MergeDocumentCollection<<#= typeDef #>>(gameDataDocumentCollection, patchDocumentCollection, purgeRest: false);
						}
						break;
<#+
		}
#>
				}
#pragma warning restore 1522

			}

			var changeNumber = 0;
			if (gameDataDocument.TryGetValue("ChangeNumber", out var gameDataChangeNumberObj) &&
				gameDataChangeNumberObj != null) {
				changeNumber = Convert.ToInt32(gameDataChangeNumberObj, CultureInfo.InvariantCulture);
			}
			if (patchDocument.TryGetValue("ChangeNumber", out var patchChangeNumberObj) &&
				patchChangeNumberObj != null) {
				changeNumber = Convert.ToInt32(patchChangeNumberObj, CultureInfo.InvariantCulture);
			}

			var revisionHash = default(string);
			if (gameDataDocument.TryGetValue("RevisionHash", out var gameDataRevisionHashObj) &&
				gameDataRevisionHashObj != null) {
				revisionHash = Convert.ToString(gameDataRevisionHashObj, CultureInfo.InvariantCulture);
			}
			if (patchDocument.TryGetValue("RevisionHash", out var patchRevisionHashObj) &&
				patchRevisionHashObj != null) {
				revisionHash = Convert.ToString(patchRevisionHashObj, CultureInfo.InvariantCulture);
			}

			newGameDataDocument["RevisionHash"] = revisionHash;
			newGameDataDocument["ChangeNumber"] = changeNumber;
			newGameDataDocument["Collections"] = newCollections;

			return newGameDataDocument;
		}

		public object MergeDocumentCollection<DocumentT>(object originalDocumentCollection, object modifiedDocumentCollection, bool purgeRest)
		{
			if (modifiedDocumentCollection == null && !purgeRest)
			{
				return Array.Empty<object>();
			}

			var originalCollectionById = ToDocumentsById(originalDocumentCollection);
			var modifiedCollectionById = ToDocumentsById(modifiedDocumentCollection);
			var mergedCollection = new Formatters.IndexedDictionary<string, object>(Math.Max(originalCollectionById.Count, modifiedCollectionById.Count) + 5);
			var documentIds = purgeRest ? modifiedCollectionById.Keys : originalCollectionById.Keys.Union(modifiedCollectionById.Keys);

			foreach (var documentId in documentIds)
			{
				var originalValueExists = originalCollectionById.TryGetValue(documentId, out var originalValue);
				var modifiedValueExists = modifiedCollectionById.TryGetValue(documentId, out var modifiedValue);

				object mergedDocument;
				if (originalValueExists && !modifiedValueExists)
				{
					// unchanged
					mergedDocument = originalValue;
				}
				else if (originalValueExists && originalValue == null)
				{
 					// keep deleted documents as deleted
					mergedDocument = null;
				}
				else if (!originalValueExists && modifiedValueExists)
				{
					// modified
					mergedDocument = modifiedValue;
				}
				else if (originalValue is IReadOnlyDictionary<string, object> originalValueDocument &&
						modifiedValue is IReadOnlyDictionary<string, object> modifiedValueDocument)
				{
					// merged
					mergedDocument = MergeDocument<DocumentT>(originalValueDocument, modifiedValueDocument);
				}
				else
				{
					// modified
					mergedDocument = modifiedValue;
				}

				mergedCollection[documentId] = mergedDocument;
			}
			return mergedCollection;
		}

		public object MergeDocument<DocumentT>(IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument)
		{
			var mergedDocument = new Formatters.IndexedDictionary<string, object>(Math.Max(originalDocument.Count, modifiedDocument.Count) + 5);

<#+
		foreach (var typeDef in context.ObjectModel.Types)
		{
#>
			if (typeof(DocumentT) == typeof(<#= typeDef #>))
			{
<#+
			foreach (var propertyDef in typeDef.Properties)
			{
				if (propertyDef.DataType == DataType.Text && propertyDef.SchemaProperty.Name == "Languages" && typeDef.Schema.Name == "ProjectSettings")
				{
#>
				MergePropertyLanguagesValue(mergedDocument, originalDocument, modifiedDocument, "<#= propertyDef.SchemaProperty.Name #>");
<#+
				}
				else if (propertyDef.DataType == DataType.ReferenceCollection || propertyDef.DataType == DataType.DocumentCollection)
				{
#>
				MergePropertyValue<object>(mergedDocument, originalDocument, modifiedDocument, "<#= propertyDef.SchemaProperty.Name #>", (original, modified) => MergeDocumentCollection<<#= propertyDef.DocumentOrReferenceType #>>(original, modified, purgeRest:true));
<#+
				}
				else if (propertyDef.DataType == DataType.Document)
				{
#>
				MergePropertyDocumentValue<IReadOnlyDictionary<string, object>>(mergedDocument, originalDocument, modifiedDocument, "<#= propertyDef.SchemaProperty.Name #>", (original, modified) => MergeDocument<<#= propertyDef.DocumentOrReferenceType #>>(original, modified));
<#+
				}
				else if (propertyDef.DataType == DataType.LocalizedText)
				{
#>
				MergePropertyValue<IReadOnlyDictionary<string, object>>(mergedDocument, originalDocument, modifiedDocument, "<#= propertyDef.SchemaProperty.Name #>", (original, modified) => MergeLocalizedText(original, modified));
<#+
				}
				else
				{
#>
				MergePropertyValue<object>(mergedDocument, originalDocument, modifiedDocument, "<#= propertyDef.SchemaProperty.Name #>");
<#+
				}
			}
#>
			}
<#+
		}
#>
			return mergedDocument;
		}


		private static void MergePropertyDocumentValue<ValueT>(Formatters.IndexedDictionary<string, object> mergedDocument, IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument, string propertyName, Func<ValueT, ValueT, object> mergeFunc = null)
		{
			if (mergedDocument == null) throw new ArgumentNullException(nameof(mergedDocument));
			if (originalDocument == null) throw new ArgumentNullException(nameof(originalDocument));
			if (modifiedDocument == null) throw new ArgumentNullException(nameof(modifiedDocument));

			originalDocument.TryGetValue(propertyName, out var originalValue);
			modifiedDocument.TryGetValue(propertyName, out var modifiedValue);

			if (originalValue == null &&
				modifiedDocument is IReadOnlyDictionary<string, object> document &&
				!document.ContainsKey("Id"))
			{
				// unable to merge into missing document
				mergedDocument[propertyName] = null;
				return;
			}

			MergePropertyValue<ValueT>(mergedDocument, originalDocument, modifiedDocument, propertyName, mergeFunc);
		}

		private static void MergePropertyLanguagesValue(Formatters.IndexedDictionary<string, object> mergedDocument, IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument, string propertyName)
		{
			if (mergedDocument == null) throw new ArgumentNullException(nameof(mergedDocument));
			if (originalDocument == null) throw new ArgumentNullException(nameof(originalDocument));
			if (modifiedDocument == null) throw new ArgumentNullException(nameof(modifiedDocument));
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			var originalValueExists = originalDocument.TryGetValue(propertyName, out var originalValue);
			var modifiedValueExists = modifiedDocument.TryGetValue(propertyName, out var modifiedValue);

			if (!originalValueExists && !modifiedValueExists)
			{
				return; // nothing to merge
			}

			var originalLanguages = (originalValue as string ?? "").Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
			var modifiedLanguages = (modifiedValue as string ?? "").Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

			mergedDocument[propertyName] = string.Join(",", System.Linq.Enumerable.Union(originalLanguages, modifiedLanguages));
		}

		private static void MergePropertyValue<ValueT>(Formatters.IndexedDictionary<string, object> mergedDocument, IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument, string propertyName, Func<ValueT, ValueT, object> mergeFunc = null)
		{
			if (mergedDocument == null) throw new ArgumentNullException(nameof(mergedDocument));
			if (originalDocument == null) throw new ArgumentNullException(nameof(originalDocument));
			if (modifiedDocument == null) throw new ArgumentNullException(nameof(modifiedDocument));
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			var originalValueExists = originalDocument.TryGetValue(propertyName, out var originalValue);
			var modifiedValueExists = modifiedDocument.TryGetValue(propertyName, out var modifiedValue);

			if (!originalValueExists && !modifiedValueExists)
			{
				return; // nothing to merge
			}

			object mergedValue;
			if (originalValueExists && !modifiedValueExists)
			{
				// unchanged
				mergedValue = originalValue;
			}
			else if (!originalValueExists && modifiedValueExists)
			{
				// modified
				mergedValue = modifiedValue;
			}
			else if (originalValue is ValueT originalTypedValue &&
					modifiedValue is ValueT modifiedTypedValue)
			{
				// merged
				if (mergeFunc != null)
				{
					mergedValue = mergeFunc(originalTypedValue, modifiedTypedValue);
				}
				else
				{
					mergedValue = modifiedValue;
				}
			}
			else
			{
				// modified
				mergedValue = modifiedValue;
			}

			mergedDocument[propertyName] = mergedValue;
		}

		private static object MergeLocalizedText(IReadOnlyDictionary<string, object> originalLocalizedText, IReadOnlyDictionary<string, object> modifiedLocalizedText)
		{
			if (originalLocalizedText == null && modifiedLocalizedText == null)
			{
				return null;
			}
			else if (originalLocalizedText != null && modifiedLocalizedText == null)
			{
				return null;
			}
			else if (originalLocalizedText == null)
			{
				return modifiedLocalizedText;
			}
			else if (LocalizedTextAreEquals(originalLocalizedText, modifiedLocalizedText))
			{
				return originalLocalizedText;
			}

			var mergedLocalizedText = new Formatters.IndexedDictionary<string, object>();
			foreach (var languageId in originalLocalizedText.Keys.Union(modifiedLocalizedText.Keys))
			{
				if (modifiedLocalizedText.ContainsKey(languageId) == false)
				{
					originalLocalizedText.TryGetValue(languageId, out var originalText);
					mergedLocalizedText[languageId] = originalText;
				}
				else
				{
					modifiedLocalizedText.TryGetValue(languageId, out var modifiedText);
					mergedLocalizedText[languageId] = modifiedText;
				}
			}
			return mergedLocalizedText;
		}

		private static bool LocalizedTextAreEquals(IReadOnlyDictionary<string, object> x, IReadOnlyDictionary<string, object> y)
		{
			if (ReferenceEquals(x, y)) return true;
			if (ReferenceEquals(x, null)) return false;
			if (ReferenceEquals(y, null)) return false;
			if (x.GetType() != y.GetType()) return false;
			if (x.Count != y.Count) return false;

			foreach (var kv in x)
			{
				if (string.Equals(kv.Key, "notes", StringComparison.Ordinal))
				{
					continue;
				}

				var xValue = kv.Value;
				y.TryGetValue(kv.Key, out var yValue);

				if (!string.Equals(xValue as string, yValue as string, StringComparison.Ordinal))
				{
					return false;
				}
			}
			return true;
		}

		public IReadOnlyDictionary<string, object> ToDocumentsById(object gameDataDocumentCollection)
		{
			if (gameDataDocumentCollection is IReadOnlyDictionary<string, object> documentsById)
			{
				return documentsById;
			}
			else if (gameDataDocumentCollection is IReadOnlyList<object> list)
			{
				var newDocumentsById = new Formatters.IndexedDictionary<string, object>(list.Count);
				foreach (var documentObj in list)
				{
					if (documentObj is IReadOnlyDictionary<string, object> document &&
						document.TryGetValue("Id", out var idObj) &&
						idObj != null)
					{
						var idStr = Convert.ToString(idObj, CultureInfo.InvariantCulture);
						newDocumentsById[idStr] = documentObj;
					}
				}
				return newDocumentsById;
			}
			else
			{
				return new Formatters.IndexedDictionary<string, object>();
			}
		}

		#endregion
<#+
	}
#>
