<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormatters()
	{
#> 

	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	[Obsolete("Left for backward compatibility. Use GameDataFormat instead.")]
	public static class Format
	{
		public static readonly GameDataFormat Json = GameDataFormat.Json;
		public static readonly GameDataFormat MessagePack = GameDataFormat.MessagePack;
	}


	public enum GameDataFormat
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public GameDataFormat Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = GameDataFormat.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public class GameDataObjectReader : GameDataReader
	{
		private ReaderFrame[] frames;
		private int topFrameIndex;
		private ReaderToken token;
		private bool boolValue;
		private long integerValue;
		private double numberValue;
		private string stringValue;
		private object objectValue;
		private ArraySegment<byte> bytesValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		/// <inheritdoc />
		public override bool ValueAsBoolean => this.boolValue;
		/// <inheritdoc />
		public override long ValueAsInteger => this.integerValue;
		/// <inheritdoc />
		public override double ValueAsNumber => this.numberValue;
		/// <inheritdoc />
		public override string ValueAsString => this.stringValue;
		/// <inheritdoc />
		public override DateTime ValueAsDateTime => this.GetValueAsDateTime();
		/// <inheritdoc />
		public override TimeSpan ValueAsTimeSpan => this.GetValueAsTimeSpan();
		/// <inheritdoc />
		public override ArraySegment<byte> ValueAsBytes => this.bytesValue;
		/// <inheritdoc />
		public override object Value => this.GetValue();

		/// <inheritdoc />
		public override int LineNumber => 0;
		/// <inheritdoc />
		public override int ColumnNumber => 0;

		public GameDataObjectReader(IReadOnlyDictionary<string, object> gameDataPatch)
		{
			this.frames = new ReaderFrame[10];
			this.topFrameIndex = -1;
			this.PushFrame(gameDataPatch);
			this.topFrameIndex = int.MinValue;
			this.token = ReaderToken.None;
			this.boolValue= false;
			this.integerValue= 0;
			this.numberValue= 0;
			this.stringValue= null;
			this.objectValue = null;
			this.bytesValue = new ArraySegment<byte>(Array.Empty<byte>());
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			this.integerValue = 0;
			this.numberValue = 0;
			this.stringValue = null;
			this.objectValue = null;

			if (this.topFrameIndex == int.MinValue)
			{
				this.topFrameIndex = 0;
				this.token = this.frames[this.topFrameIndex].ContainerType;
				return true;
			}

			while (this.topFrameIndex >= 0)
			{
				var nextToken = ReaderFrame.GetState(ref this.frames[this.topFrameIndex]);
				switch (nextToken)
				{
					case ReaderToken.Member:
						var memberName = this.frames[this.topFrameIndex].MemberName;
						this.token = nextToken;
						this.SetValue(memberName);
						return true;
					case ReaderToken.Bytes:
					case ReaderToken.Integer:
					case ReaderToken.Number:
					case ReaderToken.Boolean:
					case ReaderToken.String:
						this.token = nextToken;
						this.SetValue(this.frames[this.topFrameIndex].Current);
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						return true;
					case ReaderToken.EndOfObject:
					case ReaderToken.EndOfArray:
						this.PopFrame();
						this.token = nextToken;
						return true;
					case ReaderToken.BeginObject:
						var dictionary = (IReadOnlyDictionary<string, object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(dictionary);
						this.token = nextToken;
						return true;
					case ReaderToken.BeginArray:
						var list = (IReadOnlyList<object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(list);
						this.token = nextToken;
						return true;
					case ReaderToken.Null:
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.token = nextToken;
						return true;
				}
			}

			return false;
		}

		private TimeSpan GetValueAsTimeSpan()
		{
			if (this.objectValue is TimeSpan timeSpan)
			{
				return timeSpan;
			}
			return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
		}
		private DateTime GetValueAsDateTime()
		{
			if (this.objectValue is DateTime dateTime)
			{
				return dateTime;
			}
			return DateTime.ParseExact(this.ValueAsString, DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind);
		}

		private void PushFrame(IReadOnlyDictionary<string, object> dictionary)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(dictionary);
		}
		private void PushFrame(IReadOnlyList<object> list)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(list);
		}
		private void PopFrame()
		{
			this.frames[this.topFrameIndex] = default;
			this.topFrameIndex--;
		}

		private object GetValue()
		{
			switch (this.token)
			{
				case ReaderToken.Null: return null;
				case ReaderToken.Member:
				case ReaderToken.String: return this.objectValue ?? this.stringValue;
				case ReaderToken.Integer: return this.integerValue;
				case ReaderToken.Number: return this.numberValue;
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.bytesValue;
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default:
					throw ReaderException.UnexpectedToken(this, this.token,
						new[] {
							ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes
						});
			}
		}
		private void SetValue(object value)
		{
			this.integerValue = 0;
			this.numberValue = 0;
			this.stringValue = null;
			this.objectValue = null;

			switch (value)
			{
				case null: return;
				case string stringValue: this.stringValue = stringValue; break;
				case sbyte sbyteValue: this.integerValue = sbyteValue; break;
				case byte byteValue: this.integerValue = byteValue; break;
				case short shortValue: this.integerValue = shortValue; break;
				case ushort ushortValue: this.integerValue = ushortValue; break;
				case int intValue: this.integerValue = intValue; break;
				case uint uintValue: this.integerValue = uintValue; break;
				case long longValue: this.integerValue = longValue; break;
				case ulong ulongValue: this.integerValue = unchecked((long)ulongValue); break;
				case float floatValue: this.numberValue = floatValue; break;
				case double doubleValue: this.numberValue = doubleValue; break;
				case decimal decimalValue: this.numberValue = (double)decimalValue; break;
				case bool boolValue: this.boolValue = boolValue; break;
				case ArraySegment<byte> bytes: this.bytesValue = bytes; break;
				default:
					this.objectValue = value;
					this.stringValue = Convert.ToString(value, CultureInfo.InvariantCulture);
					break;
			}
		}

		/// <inheritdoc />
		public override void Dispose()
		{
			Array.Clear(this.frames, 0, this.frames.Length);
			this.topFrameIndex = -1;
		}

		private struct ReaderFrame
		{
			private bool memberNameVisited;
			private int currentIndex;
			private readonly IReadOnlyList<object> list;
			private readonly IndexedDictionary<string, object> dictionary;

			public string MemberName => this.dictionary?.Keys[this.currentIndex];
			public object Current => this.list != null ? this.list[this.currentIndex] : this.dictionary?[this.dictionary.Keys[this.currentIndex]];
			public ReaderToken ContainerType => this.list != null ? ReaderToken.BeginArray : this.dictionary != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
			private bool IsInBounds => this.currentIndex < (this.list?.Count ?? (this.dictionary?.Count ?? 0));

			public ReaderFrame(IReadOnlyList<object> list)
			{
				if (list == null) throw new ArgumentNullException(nameof(list));

				this.dictionary = default;
				this.list = list;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}
			public ReaderFrame(IReadOnlyDictionary<string, object> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary as IndexedDictionary<string, object> ?? new IndexedDictionary<string, object>(dictionary);
				this.list = default;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}

			public static void Next(ref ReaderFrame readerFrame)
			{
				readerFrame.currentIndex++;
				readerFrame.memberNameVisited = false;
			}
			public static ReaderToken GetState(ref ReaderFrame readerFrame)
			{
				var isObjectIteration = readerFrame.dictionary != null;
				if (!readerFrame.IsInBounds)
				{
					return isObjectIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
				}

				if (isObjectIteration && !readerFrame.memberNameVisited)
				{
					readerFrame.memberNameVisited = true;
					return ReaderToken.Member;
				}

				readerFrame.memberNameVisited = false;
				var currentObject = readerFrame.Current;
				switch (currentObject)
				{
					case IReadOnlyDictionary<string, object> _:
						return ReaderToken.BeginObject;
					case IReadOnlyList<object> _:
						return ReaderToken.BeginArray;
					case null:
						return ReaderToken.Null;
					case string _:
						return ReaderToken.String;
					case sbyte _:
					case byte _:
					case short _:
					case ushort _:
					case int _:
					case uint _:
					case long _:
					case ulong _:
						return ReaderToken.Integer;
					case float _:
					case double _:
					case decimal _:
						return ReaderToken.Number;
					case bool _:
						return ReaderToken.Boolean;
					case ArraySegment<byte> _:
						return ReaderToken.Bytes;
					default:
						return ReaderToken.String;
				}
			}
		}
	}


	public interface ILineInfo
	{
		int LineNumber { get; }
		int ColumnNumber { get; }
	}

	public abstract partial class GameDataReader : IDisposable, ILineInfo
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderToken Token { get; }

		public abstract long ValueAsInteger { get; }
		public abstract double ValueAsNumber { get; }
		public abstract ArraySegment<byte> ValueAsBytes { get; }
		public abstract bool ValueAsBoolean { get; }
		public abstract string ValueAsString { get; }
		public abstract object Value { get; }

		// ReSharper disable SwitchStatementHandlesSomeKnownEnumValuesWithDefault
		public virtual float ValueAsSingle
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((float)this.ValueAsInteger);
					case ReaderToken.Number: return checked((float)this.ValueAsNumber);
					case ReaderToken.String: return float.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual double ValueAsDouble
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((double)this.ValueAsInteger);
					case ReaderToken.Number: return checked((double)this.ValueAsNumber);
					case ReaderToken.String: return double.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual sbyte ValueAsSByte
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((sbyte)this.ValueAsInteger);
					case ReaderToken.Number: return checked((sbyte)this.ValueAsNumber);
					case ReaderToken.String: return sbyte.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual byte ValueAsByte
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((byte)this.ValueAsInteger);
					case ReaderToken.Number: return checked((byte)this.ValueAsNumber);
					case ReaderToken.String: return byte.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual short ValueAsInt16
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((short)this.ValueAsInteger);
					case ReaderToken.Number: return checked((short)this.ValueAsNumber);
					case ReaderToken.String: return short.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual ushort ValueAsUInt16
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((ushort)this.ValueAsInteger);
					case ReaderToken.Number: return checked((ushort)this.ValueAsNumber);
					case ReaderToken.String: return ushort.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual int ValueAsInt32
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((int)this.ValueAsInteger);
					case ReaderToken.Number: return checked((int)this.ValueAsNumber);
					case ReaderToken.String: return int.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual uint ValueAsUInt32
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((uint)this.ValueAsInteger);
					case ReaderToken.Number: return checked((uint)this.ValueAsNumber);
					case ReaderToken.String: return uint.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual long ValueAsInt64
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return checked((long)this.ValueAsInteger);
					case ReaderToken.Number: return checked((long)this.ValueAsNumber);
					case ReaderToken.String: return long.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual ulong ValueAsUInt64
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.Integer: return unchecked((ulong)this.ValueAsInteger);
					case ReaderToken.Number: return checked((ulong)this.ValueAsNumber);
					case ReaderToken.String: return ulong.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}

		public virtual DateTime ValueAsDateTime
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.String:
						return DateTime.ParseExact(this.ValueAsString, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture,
							DateTimeStyles.RoundtripKind);
					default: throw new InvalidCastException();
				}
			}
		}
		public virtual TimeSpan ValueAsTimeSpan
		{
			get
			{
				switch (this.Token)
				{
					case ReaderToken.String: return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
					default: throw new InvalidCastException();
				}
			}
		}

		// ReSharper restore SwitchStatementHandlesSomeKnownEnumValuesWithDefault

		public bool HasValue => this.Token == ReaderToken.Member ||
			this.Token == ReaderToken.Null ||
			this.Token == ReaderToken.Boolean ||
			this.Token == ReaderToken.Integer ||
			this.Token == ReaderToken.Number ||
			this.Token == ReaderToken.Bytes ||
			this.Token == ReaderToken.String;

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (!this.HasValue)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, new[] {
					ReaderToken.Member, ReaderToken.Null, ReaderToken.Boolean, ReaderToken.Integer,
					ReaderToken.Number, ReaderToken.Bytes, ReaderToken.String
				});
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(this, expected, propertyName, schemaName);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			switch (this.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null:
					if (nextToken) this.NextToken();
					return null;
				case ReaderToken.Number:
					var numberValue = this.ValueAsNumber;
					if (nextToken) this.NextToken();
					return numberValue;
				case ReaderToken.Boolean:
					var boolValue = this.ValueAsBoolean;
					if (nextToken) this.NextToken();
					return boolValue;
				case ReaderToken.Integer:
					var intValue = this.ValueAsInteger;
					if (nextToken) this.NextToken();
					return intValue;
				case ReaderToken.String:
					var strValue = this.ValueAsString;
					if (nextToken) this.NextToken();
					return strValue;
				case ReaderToken.Bytes:
					var objValue = this.ValueAsBytes;
					if (nextToken) this.NextToken();
					return objValue;
				case ReaderToken.None:
				case ReaderToken.Member:
				case ReaderToken.EndOfArray:
				case ReaderToken.EndOfObject:
				case ReaderToken.EndOfStream:
				default:
					throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Number,
						ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while (this.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}

			this.ReadArrayEnd(nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while (this.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}

			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			switch (this.Token)
			{
				case ReaderToken.BeginArray:
					this.SkipArray(nextToken);
					break;
				case ReaderToken.BeginObject:
					this.SkipObject(nextToken);
					break;
				case ReaderToken.Member:
				case ReaderToken.String:
				case ReaderToken.Integer:
				case ReaderToken.Number:
				case ReaderToken.Boolean:
				case ReaderToken.Bytes:
				case ReaderToken.Null:
					if (nextToken) this.NextToken();
					break;
				case ReaderToken.None:
				case ReaderToken.EndOfArray:
				case ReaderToken.EndOfObject:
				case ReaderToken.EndOfStream:
				default:
					throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Number,
						ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while (this.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}

			this.ReadArrayEnd(nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while (this.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}

			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginArray);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Token != ReaderToken.Member && this.Token != ReaderToken.String)
			{
				throw ReaderException.UnexpectedToken(this, this.Token, ReaderToken.Member, ReaderToken.String);
			}

			var memberName = this.ValueAsString;
			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Token, CultureInfo.InvariantCulture) +
					(this.HasValue ? "[" + Convert.ToString(this.Value, CultureInfo.InvariantCulture) + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Token == ReaderToken.EndOfObject || this.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Token == ReaderToken.EndOfObject || this.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}

				if (this.Token == ReaderToken.BeginObject || this.Token == ReaderToken.BeginArray || this.Token == ReaderToken.Member)
				{
					stack.Push(this.Token);
				}
			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return Convert.ToString(this.Token, CultureInfo.InvariantCulture) +
				(this.HasValue ? "[" + Convert.ToString(this.Value, CultureInfo.InvariantCulture) + "]" : "");
		}
	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int LEXER_STATE_COMPLETE = -1;
		private const int LEXER_STATE_START = 0;
		private const int LEXER_STATE_LEXEME = 1;
		private const int LEXER_STATE_QUOTED = 2;
		private const int LEXER_STATE_QUOTED_ESCAPE = 3;
		private const int LEXER_STATE_COMMENT_BEGINNING = 4;
		private const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		private const int LEXER_STATE_COMMENT_MULTILINE = 6;
		private const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly char[] charBuffer;
		private readonly Stack<ReaderToken> structure;
		private readonly Dictionary<ulong, string> stringPool;
		private readonly bool useStringPooling;
		private readonly Decoder utf8Decoder;

		private int bufferOffset;
		private int bufferAvailable;
		private int columnNumber;
		private int lineNumber;
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		private byte[] binaryBuffer;
#endif
		private ReaderToken token;
		private bool boolValue;
		private ArraySegment<byte> rawJsonValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		public override ArraySegment<byte> ValueAsBytes => this.ReadJsonAsBase64();

		public override bool ValueAsBoolean => this.boolValue;
		public override double ValueAsNumber => this.ReadJsonAsNumber();
		public override long ValueAsInteger => this.ReadJsonAsInteger();
		public override string ValueAsString => this.ReadJsonAsString();
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		public override DateTime ValueAsDateTime => this.ReadJsonAsDateTime();
		public override TimeSpan ValueAsTimeSpan => this.ReadJsonAsTimeSpan();
#endif
		public override object Value => this.BoxAnyValue();

		public override int LineNumber => this.lineNumber;
		public override int ColumnNumber => this.columnNumber;

		public JsonGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE, bool useStringPooling = false)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
			{
				bufferSize = DEFAULT_BUFFER_SIZE;
			}

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.useStringPooling = useStringPooling;
			this.buffer = new byte[bufferSize];
			this.charBuffer = new char[bufferSize / 2];
			this.bufferOffset = 0;
			this.bufferAvailable = 0;
			this.lineNumber = 1;
			this.structure = new Stack<ReaderToken>();
			this.stringPool = new Dictionary<ulong, string>();
			this.token = ReaderToken.None;
			this.boolValue = false;
			this.rawJsonValue = new ArraySegment<byte>(Array.Empty<byte>());
			this.utf8Decoder = Encoding.UTF8.GetDecoder();
		}

		public override bool NextToken()
		{
			var nextStringTokenType = ReaderToken.String;
			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(nextStringTokenType = ReaderToken.Member);
						break;
				}
			}

			if (!this.NextLexeme())
			{
				return false;
			}

			var rawJsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
			var rawJsonOffset = this.rawJsonValue.Offset;
			var rawJsonLength = this.rawJsonValue.Count;
			if (rawJsonLength == 1)
			{
				var oneCharNotation = rawJsonArray[rawJsonOffset];
				switch (oneCharNotation)
				{
					case JsonNotation.BEGIN_ARRAY_CHAR_CODE:
						this.token = ReaderToken.BeginArray;
						this.structure.Push(ReaderToken.BeginArray);
						return true;
					case JsonNotation.END_ARRAY_CHAR_CODE:
						this.token = ReaderToken.EndOfArray;
						this.PopStructureToken();
						return true;
					case JsonNotation.BEGIN_OBJECT_CHAR_CODE:
						this.token = ReaderToken.BeginObject;
						this.structure.Push(ReaderToken.BeginObject);
						return true;
					case JsonNotation.END_OBJECT_CHAR_CODE:
						this.token = ReaderToken.EndOfObject;
						this.PopStructureToken();
						return true;
					default:
						if (oneCharNotation >= JsonNotation.ZERO_CHAR_CODE && oneCharNotation <= JsonNotation.NINE_CHAR_CODE)
						{
							this.token = ReaderToken.Integer;
							return true;
						}

						throw ReaderException.UnknownNotation(this, ((char)oneCharNotation).ToString());
				}
			}
			else if (rawJsonLength == 4 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.Null))
			{
				this.token = ReaderToken.Null;
				return true;
			}
			else if (rawJsonLength == 4 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.True))
			{
				this.token = ReaderToken.Boolean;
				this.boolValue = true;
				return true;
			}
			else if (rawJsonLength == 5 && SequenceEqual(rawJsonArray, rawJsonOffset, JsonNotation.False))
			{
				this.token = ReaderToken.Boolean;
				this.boolValue = false;
				return true;
			}

			if (rawJsonLength > 0 && rawJsonArray[rawJsonOffset] == JsonNotation.QUOTE_CHAR_CODE)
			{
				if (rawJsonArray[rawJsonOffset + rawJsonLength - 1] != JsonNotation.QUOTE_CHAR_CODE)
				{
					throw ReaderException.UnterminatedStringLiteral(this);
				}

				// remove quotes
				this.rawJsonValue = new ArraySegment<byte>(this.rawJsonValue.Array ?? this.buffer, this.rawJsonValue.Offset + 1, this.rawJsonValue.Count - 2);

				this.token = nextStringTokenType;
				return true;
			}

			switch (this.GetNumberType())
			{
				case NumberType.Integer:
					this.token = ReaderToken.Integer;
					return true;
				case NumberType.Number:
					this.token = ReaderToken.Number;
					return true;
				case NumberType.NotANumber:
				default:
					throw ReaderException.UnknownNotation(this, this.ReadJsonAsString());
			}
		}

		private bool NextLexeme()
		{
			var state = LEXER_STATE_COMPLETE;

			var lexemeStart = -1;
			var buffer = this.buffer;
			var bufferOffset = this.bufferOffset;
			var bufferAvailable = this.bufferAvailable;

			while (true)
			{
				this.columnNumber++;

				if (state == LEXER_STATE_COMPLETE)
				{
					state = LEXER_STATE_START;
				}

				if (bufferAvailable == 0)
				{
					if (!this.TryFillBuffer(ref lexemeStart, ref bufferOffset, ref bufferAvailable))
					{
						return false; // end of stream
					}
				}

				var charCode = buffer[bufferOffset];
				bufferAvailable--;
				bufferOffset++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (charCode)
						{
							case JsonNotation.NEWLINE_CHAR_CODE:
								this.lineNumber++;
								this.columnNumber = 0;
								break;
							case JsonNotation.SPACE_CHAR_CODE:
							case JsonNotation.RETURN_CHAR_CODE:
							case JsonNotation.TAB_CHAR_CODE:
							case JsonNotation.IDENTIFIER_SEPARATOR_CHAR_CODE:
								continue; // insignificant whitespaces
							case JsonNotation.VALUE_SEPARATOR_CHAR_CODE:
							{
								if (this.structure.Count == 0 || this.structure.Peek() == ReaderToken.BeginObject)
								{
									throw ReaderException.ReadingBrokenDocument(this, "A value is expected");
								}

								break;
							}
							case JsonNotation.COMMENT_CHAR_CODE:
								state = LEXER_STATE_COMMENT_BEGINNING;
								break;
							case JsonNotation.END_ARRAY_CHAR_CODE:
							case JsonNotation.BEGIN_ARRAY_CHAR_CODE:
							case JsonNotation.END_OBJECT_CHAR_CODE:
							case JsonNotation.BEGIN_OBJECT_CHAR_CODE:
								this.rawJsonValue = new ArraySegment<byte>(buffer, bufferOffset - 1, 1);
								this.bufferOffset = bufferOffset;
								this.bufferAvailable = bufferAvailable;
								return true;
							default:
							{
								if (IsWhiteSpace(charCode))
								{
									continue;
								}

								lexemeStart = bufferOffset - 1;
								state = charCode == JsonNotation.QUOTE_CHAR_CODE ? LEXER_STATE_QUOTED : LEXER_STATE_LEXEME;
								break;
							}
						}

						break;
					case LEXER_STATE_LEXEME:
						if (IsLexemeTerminator(charCode))
						{
							bufferOffset--;
							bufferAvailable++;

							this.rawJsonValue = new ArraySegment<byte>(buffer, lexemeStart, bufferOffset - lexemeStart);
							this.bufferOffset = bufferOffset;
							this.bufferAvailable = bufferAvailable;
							return true;
						}
						else
						{
							continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (charCode)
						{
							case JsonNotation.NEWLINE_CHAR_CODE:
							case JsonNotation.RETURN_CHAR_CODE:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.QUOTE_CHAR_CODE:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									break;
								}
								else
								{
									this.rawJsonValue = new ArraySegment<byte>(buffer, lexemeStart, bufferOffset - lexemeStart);
									this.bufferOffset = bufferOffset;
									this.bufferAvailable = bufferAvailable;
									return true;
								}
							case JsonNotation.ESCAPE_CHAR_CODE:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								break;
							default:
								state = LEXER_STATE_QUOTED;
								break;
						}

						break;
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (charCode)
						{
							case JsonNotation.COMMENT_CHAR_CODE:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								break;
							case JsonNotation.COMMENT_MULTILINE_CHAR_CODE:
								state = LEXER_STATE_COMMENT_MULTILINE;
								break;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.COMMENT + "\\u" + (char)charCode);
						}

						break;
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						if (charCode == JsonNotation.NEWLINE_CHAR_CODE || charCode == JsonNotation.RETURN_CHAR_CODE)
						{
							state = LEXER_STATE_START; // skip comment, start over again
						}

						break;
					case LEXER_STATE_COMMENT_MULTILINE:
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
						switch (charCode)
						{
							case JsonNotation.COMMENT_MULTILINE_CHAR_CODE:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								break;
							case JsonNotation.COMMENT_CHAR_CODE:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
								{
									state = LEXER_STATE_START; // skip comment, start over again
								}

								break;
						}

						break;
				}
			}
		}

		private bool TryFillBuffer(ref int lexemeStart, ref int bufferOffset, ref int bufferAvailable)
		{
			if (lexemeStart + bufferOffset > 0)
			{
				if (lexemeStart >= 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStart, this.buffer, 0, bufferAvailable + bufferOffset - lexemeStart);
					bufferOffset -= lexemeStart;
					lexemeStart = 0;
				}
				else
				{
					bufferOffset = 0;
				}
			}

			var readOffset = bufferOffset + bufferAvailable;
			var toRead = this.buffer.Length - readOffset;

			if (toRead == 0)
			{
				throw ReaderException.StringLiteralIsTooLong(this, (ulong)this.buffer.Length, this.charBuffer.Length);
			}

			var read = this.inputStream.Read(this.buffer, readOffset, toRead);
			bufferAvailable += read;

			return read > 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsWhiteSpace(byte charCode)
		{
			return charCode < JsonNotation.WhitespaceChars.Length && JsonNotation.WhitespaceChars[charCode];
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsLexemeTerminator(byte charCode)
		{
			return charCode < JsonNotation.LexemeTerminatorChars.Length && JsonNotation.LexemeTerminatorChars[charCode];
		}

		private object BoxAnyValue()
		{
			switch (this.token)
			{
				case ReaderToken.Null: return null;
				case ReaderToken.String:
				case ReaderToken.Member: return this.ReadJsonAsString();
				case ReaderToken.Integer: return this.ReadJsonAsInteger();
				case ReaderToken.Number: return this.ReadJsonAsNumber();
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.ReadJsonAsBase64();
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default:
					throw ReaderException.UnexpectedToken(this, this.token,
						new[] {
							ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes
						});
			}
		}

		private string ReadJsonAsString()
		{
			if (this.rawJsonValue.Count == 0)
			{
				return string.Empty;
			}
			else if (this.rawJsonValue.Count <= 8 && this.useStringPooling)
			{
				var stringCacheKey = 0UL;
				var rawJsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
				var end = this.rawJsonValue.Offset + this.rawJsonValue.Count;
				for (var offset = this.rawJsonValue.Offset; offset < end; offset++)
				{
					var charCode = rawJsonArray[offset];
					stringCacheKey = stringCacheKey << 8 | charCode;
				}

				if (this.stringPool.TryGetValue(stringCacheKey, out var stringValue))
				{
					return stringValue;
				}
				else
				{
					var chars = this.ReadJsonAsChars();
					return this.stringPool[stringCacheKey] = stringValue = new string(chars.Array ?? this.charBuffer, chars.Offset, chars.Count);
				}
			}
			else
			{
				var chars = this.ReadJsonAsChars();
				return new string(chars.Array ?? this.charBuffer, chars.Offset, chars.Count);
			}
		}
		private ArraySegment<char> ReadJsonAsChars()
		{
			var jsonArray = this.rawJsonValue.Array;
			var offset = this.rawJsonValue.Offset;
			var count = this.rawJsonValue.Count;
			if (count == 0)
			{
				return new ArraySegment<char>(Array.Empty<char>());
			}

			if (jsonArray == null)
			{
				throw new InvalidOperationException("Unexpected raw json memory segment.");
			}

			this.utf8Decoder.Convert(jsonArray, offset, count, this.charBuffer, 0, this.charBuffer.Length, flush: true,
				out var bytesUsed, out var charsUsed, out var completed);

			if (!completed || bytesUsed != count)
			{
				throw new DecoderFallbackException("Failed to decode bytes as UTF-8 string.");
			}

			var stringLength = this.UnescapeStringInplace(this.charBuffer, charsUsed);

			return new ArraySegment<char>(this.charBuffer, 0, stringLength);
		}
		private ArraySegment<byte> ReadJsonAsBase64()
		{
			if (this.rawJsonValue.Count == 0)
			{
				return new ArraySegment<byte>(Array.Empty<byte>());
			}

#if !( NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL)
			var charsSegment = this.ReadJsonAsChars();
			if (charsSegment.Array == null)
			{
				throw new InvalidOperationException("Unexpected raw character memory segment.");
			}

			var bytes = Convert.FromBase64CharArray(charsSegment.Array, charsSegment.Offset, charsSegment.Count);
			return new ArraySegment<byte>(bytes);
#else
			var requiredSize = (this.rawJsonValue.Count + 3) / 4 * 3;
			if (this.binaryBuffer == null || this.binaryBuffer.Length < requiredSize)
			{
				this.binaryBuffer = new byte[Math.Max(this.buffer.Length, requiredSize)];
			}
			var result = System.Buffers.Text.Base64.DecodeFromUtf8(this.rawJsonValue.AsSpan(), this.binaryBuffer, out _, out var bytesWritten);
			if (result != System.Buffers.OperationStatus.Done)
			{
				throw new DecoderFallbackException("Failed to decode bytes as Base64 bytes.");
			}
			return new ArraySegment<byte>(this.binaryBuffer, 0, bytesWritten);
#endif
		}
		private double ReadJsonAsNumber()
		{
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out double value, out _))
			{
				return value;
			}
#endif
			return double.Parse(this.ReadJsonAsString(), CultureInfo.InvariantCulture);
		}
		private long ReadJsonAsInteger()
		{
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out long value, out _))
			{
				return value;
			}
#endif
			if (this.rawJsonValue.Count == 0)
			{
				throw new FormatException("Invalid integer value '' (empty string).");
			}
			else if (this.rawJsonValue.Count < 17)
			{
				// this algorithm is bad at Int64.MaxValue border
				return this.ParseInt64(this.rawJsonValue);
			}
			else
			{
				return long.Parse(this.ValueAsString, NumberStyles.Integer, CultureInfo.InvariantCulture);
			}
		}
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
		private DateTime ReadJsonAsDateTime()
		{
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out DateTime dateTime, out _, 'O'))
			{
				return dateTime;
			}
			return DateTime.ParseExact(this.ValueAsString, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture,
				DateTimeStyles.RoundtripKind);
		}
		private TimeSpan ReadJsonAsTimeSpan()
		{
			if (System.Buffers.Text.Utf8Parser.TryParse(this.rawJsonValue.AsSpan(), out TimeSpan timeSpan, out _))
			{
				return timeSpan;
			}
			return TimeSpan.Parse(this.ValueAsString, CultureInfo.InvariantCulture);
		}
#endif

		private int UnescapeStringInplace(char[] charBuffer, int length)
		{
			var writeOffset = 0;
			for (var readOffset = 0; readOffset < length; readOffset++, writeOffset++)
			{
				if (charBuffer[readOffset] == JsonNotation.ESCAPE_CHAR_CODE)
				{
					if (readOffset + 1 >= length)
					{
						throw ReaderException.UnknownEscapeSequence(this, "\0");
					}

					switch (charBuffer[readOffset + 1])
					{
						case 'n':
							charBuffer[writeOffset] = JsonNotation.NEWLINE;
							readOffset++;
							break;
						case 'r':
							charBuffer[writeOffset] = JsonNotation.RETURN;
							readOffset++;
							break;
						case 'b':
							charBuffer[writeOffset] = '\b';
							readOffset++;
							break;
						case 'f':
							charBuffer[writeOffset] = '\f';
							readOffset++;
							break;
						case 't':
							charBuffer[writeOffset] = JsonNotation.TAB;
							readOffset++;
							break;
						case '"':
							charBuffer[writeOffset] = JsonNotation.QUOTE;
							readOffset++;
							break;
						case '\\':
							charBuffer[writeOffset] = JsonNotation.ESCAPE;
							readOffset++;
							break;
						case '/':
							charBuffer[writeOffset] = '/';
							readOffset++;
							break;
						case 'u':
							if (readOffset + 5 >= length)
							{
								throw ReaderException.UnknownEscapeSequence(this, new string(charBuffer, readOffset, charBuffer.Length - readOffset));
							}

							charBuffer[writeOffset] = checked((char)this.ParseIntHex(new ArraySegment<char>(charBuffer, readOffset + 2, 4)));
							readOffset += 5;
							break;
						default:
							throw ReaderException.UnknownEscapeSequence(this, new string(charBuffer, readOffset, 2));
					}
				}
				else
				{
					charBuffer[writeOffset] = charBuffer[readOffset];
				}
			}

			return writeOffset;
		}

		private bool SequenceEqual(byte[] firstArray, int firstOffset, byte[] secondArray)
		{
			if (firstArray.Length - firstOffset < secondArray.Length)
			{
				return false;
			}

			for (var index = 0; index < secondArray.Length; index++)
			{
				if (firstArray[firstOffset + index] != secondArray[index])
				{
					return false;
				}
			}

			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private long ParseIntHex(ArraySegment<char> hexSegment)
		{
			var result = 0L;
			var hexChars = hexSegment.Array ?? Array.Empty<char>();
			var end = hexSegment.Offset + hexSegment.Count;
			for (var offset = hexSegment.Offset; offset < end; offset++)
			{
				var hexChar = hexChars[offset];
				var hexCharCode = (long)hexChar;
				var hexDigit = 0L;
				if (hexCharCode >= JsonNotation.ZERO_CHAR_CODE && hexCharCode <= JsonNotation.NINE_CHAR_CODE)
				{
					hexDigit = (hexCharCode - JsonNotation.ZERO_CHAR_CODE);
				}
				else if (hexCharCode >= JsonNotation.A_LOWER_CASE_CHAR_CODE && hexCharCode <= JsonNotation.F_LOWER_CASE_CHAR_CODE)
				{
					hexDigit = 10 + (hexCharCode - JsonNotation.A_LOWER_CASE_CHAR_CODE);
				}
				else if (hexCharCode >= JsonNotation.A_UPPER_CASE_CHAR_CODE && hexCharCode <= JsonNotation.F_UPPER_CASE_CHAR_CODE)
				{
					hexDigit = 10 + (hexCharCode - JsonNotation.A_UPPER_CASE_CHAR_CODE);
				}
				else
				{
					throw new FormatException($"Unknown HEX character {(char)hexCharCode}.");
				}

				result = 16L * result + hexDigit;
			}

			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private long ParseInt64(ArraySegment<byte> intSegment)
		{
			var result = 0L;
			var neg = false;
			var intChars = intSegment.Array ?? Array.Empty<byte>();
			var offset = intSegment.Offset;
			if (intChars[offset] == JsonNotation.MINUS_CHAR_CODE)
			{
				neg = true;
				offset++;
			}

			for (var end = intSegment.Offset + intSegment.Count; offset < end; offset++)
			{
				var digitChar = intChars[offset];
				if (digitChar < JsonNotation.ZERO_CHAR_CODE || digitChar > JsonNotation.NINE_CHAR_CODE)
				{
					throw new FormatException($"Invalid integer value '{Encoding.ASCII.GetString(intChars, intSegment.Offset, intSegment.Count)}'.");
				}

				result = checked(10L * result + (digitChar - JsonNotation.ZERO_CHAR_CODE));
			}

			return neg ? -result : result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void PopStructureToken()
		{
			if (this.structure.Count == 0)
			{
				throw ReaderException.UnexpectedToken(this, this.token, ReaderToken.EndOfStream);
			}
			else
			{
				this.structure.Pop();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private NumberType GetNumberType()
		{
			var offset = this.rawJsonValue.Offset;
			var jsonArray = this.rawJsonValue.Array ?? Array.Empty<byte>();
			if (jsonArray.Length > 0 && jsonArray[offset] == JsonNotation.MINUS_CHAR_CODE)
			{
				offset++;
			}

			var numberType = NumberType.Integer;
			for (var end = this.rawJsonValue.Offset + this.rawJsonValue.Count; offset < end; offset++)
			{
				var charCode = jsonArray[offset];
				if (charCode >= JsonNotation.ZERO_CHAR_CODE && charCode <= JsonNotation.NINE_CHAR_CODE)
				{
					continue;
				}
				else if (charCode == JsonNotation.MINUS_CHAR_CODE ||
						charCode == JsonNotation.PLUS_CHAR_CODE ||
						charCode == JsonNotation.DOT_CHAR_CODE ||
						charCode == JsonNotation.E_UPPER_CASE_CHAR_CODE ||
						charCode == JsonNotation.E_LOWER_CASE_CHAR_CODE)
				{
					numberType = NumberType.Number;
				}
			}

			return numberType;
		}

		public static string EscapeString(string value, bool forUnicodeEncoding)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			var newSize = 0;
			for (var offset = 0; offset < value.Length; offset++)
			{
				var charCode = value[offset];
				var previousCharCode = offset > 0 ? value[offset - 1] : '\0';
				if (ShouldBeEscaped(charCode, previousCharCode, forUnicodeEncoding))
				{
					newSize += 6; // \u0000
				}
				else
				{
					newSize++;
				}
			}

			if (newSize == value.Length)
			{
				return value;
			}

			var newStringValue = new StringBuilder(newSize);
			for (var offset = 0; offset < value.Length; offset++)
			{
				var charCode = value[offset];
				var previousCharCode = offset > 0 ? value[offset - 1] : '\0';
				if (ShouldBeEscaped(charCode, previousCharCode, forUnicodeEncoding))
				{
					newStringValue.Append("\\u");
					UInt16ToPaddedHexBuffer(charCode, newStringValue);
				}
				else newStringValue.Append(charCode);
			}

			return newStringValue.ToString();
		}
		private static bool ShouldBeEscaped(ushort charCode, char prevCharCode, bool forUnicodeEncoding)
		{
			return

				// quote symbol
				charCode == '"' ||
				charCode == '\\' ||

				// non-latin symbol
				!forUnicodeEncoding && charCode > '~' ||

				// control symbol
				charCode < ' ' ||

				// surrogates
				(charCode >= '\uD800' && charCode <= '\uDBFF') ||
				(charCode >= '\uDC00' && charCode <= '\uDFFF') ||

				// JavaScript escape
				charCode == '\u2028' ||
				charCode == '\u2029' ||
				charCode == '/' && prevCharCode == '<';
		}
		private static void UInt16ToPaddedHexBuffer(ushort value, StringBuilder buffer)
		{
			var offset = buffer.Length;
			buffer.Append("0000");
			if (value == 0)
			{
				return;
			}

			const int LENGTH = 4;
			const string HEX = "0123456789ABCDEF";

			var end = offset + LENGTH;
			for (var i = 0; i < LENGTH; i++)
			{
				var hexChar = HEX[(int)((value >> (i * 4)) & 15u)];
				buffer[end - i - 1] = hexChar;
			}
		}

		public override void Dispose()
		{
			this.token = ReaderToken.None;
			Array.Clear(this.buffer, 0, this.buffer.Length);
			Array.Clear(this.charBuffer, 0, this.charBuffer.Length);
			this.structure.Clear();
			this.stringPool.Clear();
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER || BUFFERS_TEXT_DLL
			this.binaryBuffer = null;
#endif
			this.bufferOffset = 0;
			this.bufferAvailable = 0;
			this.boolValue = false;
			this.rawJsonValue = new ArraySegment<byte>(Array.Empty<byte>());

			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}

		private enum NumberType
		{
			Integer,
			Number,
			NotANumber
		}

		private static class JsonNotation
		{
			public const char TAB = '\t';
			public const int TAB_CHAR_CODE = 9;
			public const int SPACE_CHAR_CODE = 32;
			public const int NO_BREAK_SPACE_CHAR_CODE = 160;
			public const char NEWLINE = '\n';
			public const int NEWLINE_CHAR_CODE = 10;
			public const char RETURN = '\r';
			public const int RETURN_CHAR_CODE = 13;
			public const int IDENTIFIER_SEPARATOR_CHAR_CODE = 58;
			public const int VALUE_SEPARATOR_CHAR_CODE = 44;
			public const int BEGIN_ARRAY_CHAR_CODE = 91;
			public const int END_ARRAY_CHAR_CODE = 93;
			public const int BEGIN_OBJECT_CHAR_CODE = 123;
			public const int END_OBJECT_CHAR_CODE = 125;
			public const char ESCAPE = '\\';
			public const int ESCAPE_CHAR_CODE = 92;
			public const char COMMENT = '/';
			public const int COMMENT_CHAR_CODE = 47;
			public const int COMMENT_MULTILINE_CHAR_CODE = 42;
			public const char QUOTE = '\"';
			public const int QUOTE_CHAR_CODE = 34;

			public const int ZERO_CHAR_CODE = 48;
			public const int NINE_CHAR_CODE = 57;
			public const int A_LOWER_CASE_CHAR_CODE = 97;
			public const int A_UPPER_CASE_CHAR_CODE = 65;
			public const int F_LOWER_CASE_CHAR_CODE = 102;
			public const int F_UPPER_CASE_CHAR_CODE = 70;

			public const int MINUS_CHAR_CODE = 45;
			public const int PLUS_CHAR_CODE = 43;
			public const int DOT_CHAR_CODE = 46;
			public const int E_UPPER_CASE_CHAR_CODE = 69;
			public const int E_LOWER_CASE_CHAR_CODE = 101;

			public static readonly byte[] True = Encoding.ASCII.GetBytes("true");
			public static readonly byte[] False = Encoding.ASCII.GetBytes("false");
			public static readonly byte[] Null = Encoding.ASCII.GetBytes("null");

			public static readonly bool[] WhitespaceChars = Enumerable.Range(0, 180).Select(
				charCode => charCode == SPACE_CHAR_CODE ||
					(charCode >= TAB_CHAR_CODE && charCode <= RETURN_CHAR_CODE) ||
					(charCode == NO_BREAK_SPACE_CHAR_CODE)
			).ToArray();
			public static readonly bool[] LexemeTerminatorChars = Enumerable.Range(0, 180).Select(
				charCode => charCode == SPACE_CHAR_CODE ||
					(charCode >= TAB_CHAR_CODE && charCode <= RETURN_CHAR_CODE) ||
					charCode == NO_BREAK_SPACE_CHAR_CODE ||
					charCode == IDENTIFIER_SEPARATOR_CHAR_CODE ||
					charCode == VALUE_SEPARATOR_CHAR_CODE ||
					charCode == END_ARRAY_CHAR_CODE ||
					charCode == END_OBJECT_CHAR_CODE ||
					charCode == BEGIN_OBJECT_CHAR_CODE ||
					charCode == BEGIN_ARRAY_CHAR_CODE
			).ToArray();
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct CurrentStructureToken
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<CurrentStructureToken> structure;
		private readonly Dictionary<ulong, string> stringPool;
		private readonly bool useStringPooling;

		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private ReaderToken token;
		private string stringValue;
		private bool boolValue;
		private double numberValue;
		private long integerValue;
		private ArraySegment<byte> bytesValue;

		/// <inheritdoc />
		public override ReaderToken Token => this.token;
		public override ArraySegment<byte> ValueAsBytes => this.bytesValue;
		public override bool ValueAsBoolean => this.boolValue;
		public override double ValueAsNumber => this.numberValue;
		public override long ValueAsInteger => this.integerValue;
		public override string ValueAsString => this.stringValue;
		public override object Value => this.BoxAnyValue();

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE, bool useStringPooling = false)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
			{
				bufferSize = DEFAULT_BUFFER_SIZE;
			}

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.useStringPooling = useStringPooling;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.structure = new Stack<CurrentStructureToken>();
			this.stringPool = new Dictionary<ulong, string>();
			this.token = ReaderToken.None;
			this.boolValue = false;
			this.numberValue = 0;
			this.integerValue = 0;
			this.stringValue = string.Empty;
		}
		public override bool NextToken()
		{
			if (this.structure.Count > 0 && this.structure.Peek().Counter == 0)
			{
				var closingToken = this.structure.Pop();
				this.token = closingToken.Token;

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.token = ReaderToken.EndOfStream;
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.token = ReaderToken.BeginArray;
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var closingToken = this.structure.Count > 0 ? this.structure.Peek() : new CurrentStructureToken();
				if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
				{
					this.token = ReaderToken.Member;
				}
				else
				{
					this.token = ReaderToken.String;
				}

				var strBytesCount = formatValue - (byte)MessagePackType.FixStrStart;
				this.stringValue = this.ReadString(strBytesCount);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.token = ReaderToken.BeginObject;
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.token = ReaderToken.Integer;
				this.integerValue = unchecked((sbyte)formatValue);
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.token = ReaderToken.Integer;
				this.integerValue = formatValue;
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.token = ReaderToken.Null;
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0U;
						switch (formatValue)
						{
							case (int)MessagePackType.Array16:
								this.ReadToBuffer(2, throwOnEos: true);
								arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Array32:
								this.ReadToBuffer(4, throwOnEos: true);
								arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}
						this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.token = ReaderToken.BeginArray;
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0U;
						switch (formatValue)
						{
							case (int)MessagePackType.Map16:
								this.ReadToBuffer(2, throwOnEos: true);
								mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Map32:
								this.ReadToBuffer(4, throwOnEos: true);
								mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						this.structure.Push(new CurrentStructureToken { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.token = ReaderToken.BeginObject;
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.Str8:
								this.ReadToBuffer(1, throwOnEos: true);
								strBytesCount = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Str16:
								this.ReadToBuffer(2, throwOnEos: true);
								strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Str32:
								this.ReadToBuffer(4, throwOnEos: true);
								strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						var closingToken = this.structure.Count > 0 ? this.structure.Peek() : new CurrentStructureToken();
						if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						{
							this.token = ReaderToken.Member;
						}
						else
						{
							this.token = ReaderToken.String;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, strBytesCount, MAX_STRING_LENGTH);

						this.stringValue = this.ReadString(checked((int)strBytesCount));
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.Bin8:
								this.ReadToBuffer(1, throwOnEos: true);
								bytesCount = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Bin16:
								this.ReadToBuffer(2, throwOnEos: true);
								bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Bin32:
								this.ReadToBuffer(4, throwOnEos: true);
								bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, bytesCount, MAX_BINARY_LENGTH);

						this.token = ReaderToken.Bytes;
						this.bytesValue = this.ReadBytes(checked((int)bytesCount));
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0UL;
						switch (formatValue)
						{
							case (int)MessagePackType.FixExt1:
								extLength = 1;
								break;
							case (int)MessagePackType.FixExt2:
								extLength = 2;
								break;
							case (int)MessagePackType.FixExt4:
								extLength = 4;
								break;
							case (int)MessagePackType.FixExt8:
								extLength = 8;
								break;
							case (int)MessagePackType.FixExt16:
								extLength = 16;
								break;
							case (int)MessagePackType.Ext8:
								this.ReadToBuffer(1, throwOnEos: true);
								extLength = this.buffer[this.bufferOffset];
								break;
							case (int)MessagePackType.Ext16:
								this.ReadToBuffer(2, throwOnEos: true);
								extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
								break;
							case (int)MessagePackType.Ext32:
								this.ReadToBuffer(4, throwOnEos: true);
								extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
								break;
						}

						this.ReadToBuffer(1, throwOnEos: true);
						// var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, extLength, MAX_BINARY_LENGTH);

						this.token = ReaderToken.Bytes;
						this.bytesValue = this.ReadBytes(checked((int)extLength));
						break;
					case MessagePackType.False:
						this.token = ReaderToken.Boolean;
						this.boolValue = false;
						break;
					case MessagePackType.True:
						this.token = ReaderToken.Boolean;
						this.boolValue = true;
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Number;
						this.numberValue = this.bitConverter.ToSingle(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Number;
						this.numberValue = this.bitConverter.ToDouble(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = unchecked((sbyte)this.buffer[this.bufferOffset]);
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt16(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.buffer[this.bufferOffset];
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.token = ReaderToken.Integer;
						this.integerValue = unchecked((long)this.bitConverter.ToUInt64(this.buffer, this.bufferOffset));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(this, ((MessagePackType)formatValue).ToString());
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}


		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			// commit previous reads
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;
			//

			if (bytesRequired > this.buffer.Length)
			{
				throw new InvalidOperationException($"Requested buffer for string (size: {bytesRequired}) or binary data is larger than working buffer (size: {this.buffer.Length}).");
			}

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0 && this.bufferOffset != 0)
				{
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);
				}
				this.bufferOffset = 0;

				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;
					if (read == 0)
					{
						break;
					}
				}

				if (this.bufferAvailable < bytesRequired)
				{
					if (throwOnEos)
					{
						throw ReaderException.UnexpectedEndOfStream(this);
					}
					else
					{
						return false;
					}
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}

		private ArraySegment<byte> ReadBytes(int bytesRequired)
		{
			if (bytesRequired == 0)
			{
				return new ArraySegment<byte>(Array.Empty<byte>());
			}

			this.ReadToBuffer(bytesRequired, throwOnEos: true);
			var bufferSegment = new ArraySegment<byte>(this.buffer, this.bufferOffset, bytesRequired);
			return bufferSegment;
		}
		private string ReadString(int strBytesCount)
		{
			if (strBytesCount == 0)
			{
				return string.Empty;
			}

			this.ReadToBuffer(strBytesCount, throwOnEos: true);

			if (strBytesCount < 8 && this.useStringPooling)
			{
				var stringCacheKey = 0UL;
				for (var i = 0; i < strBytesCount; i++)
				{
					stringCacheKey = stringCacheKey << 8 | this.buffer[this.bufferOffset + i];
				}

				if (this.stringPool.TryGetValue(stringCacheKey, out var utf8String))
				{
					return utf8String;
				}
				else
				{
					return this.stringPool[stringCacheKey] = utf8String = Encoding.UTF8.GetString(this.buffer, this.bufferOffset, strBytesCount);
				}
			}
			else
			{
				return Encoding.UTF8.GetString(this.buffer, this.bufferOffset, strBytesCount);
			}
		}

		private object BoxAnyValue()
		{
			switch (this.token)
			{
				case ReaderToken.Member: return this.stringValue;
				case ReaderToken.Null: return null;
				case ReaderToken.Integer: return this.integerValue;
				case ReaderToken.Number: return this.numberValue;
				case ReaderToken.String: return this.stringValue;
				case ReaderToken.Boolean: return this.boolValue;
				case ReaderToken.Bytes: return this.bytesValue;
				case ReaderToken.EndOfStream:
				case ReaderToken.None:
				case ReaderToken.BeginArray:
				case ReaderToken.EndOfArray:
				case ReaderToken.BeginObject:
				case ReaderToken.EndOfObject:
				default: throw ReaderException.UnexpectedToken(this, this.token, new [] { ReaderToken.Null, ReaderToken.Number, ReaderToken.Integer, ReaderToken.Boolean, ReaderToken.String, ReaderToken.Bytes });
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void DecrementClosingTokenCounter()
		{
			if (this.structure.Count <= 0) return;

			var closingToken = this.structure.Pop();
			closingToken.Counter--;
			this.structure.Push(closingToken);
		}

		public override void Dispose()
		{
			this.token = ReaderToken.None;
			Array.Clear(this.buffer, 0, this.buffer.Length);
			this.structure.Clear();
			this.stringPool.Clear();
			this.stringValue = null;
			this.integerValue = 0;
			this.numberValue = 0;
			this.boolValue = false;
			this.bytesValue = new ArraySegment<byte>(Array.Empty<byte>());
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.totalBytesRead = 0;
			this.boolValue = false;

			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}

		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}
	}


	public class ReaderException : Exception
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, ILineInfo lineInfo)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (lineInfo == null) return;

			this.LineNumber = lineInfo.LineNumber;
			this.ColumnNumber = lineInfo.ColumnNumber;
		}

		public static Exception UnexpectedEndOfStream(ILineInfo lineInfo)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException("Unexpected end of stream.", lineInfo);
		}
		public static Exception UnexpectedToken(ILineInfo lineInfo, ReaderToken currentToken, params ReaderToken[] expectedTokens)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var expectedTokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				expectedTokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				expectedTokensStr = string.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{expectedTokensStr}' but found '{currentToken}'.",
				lineInfo);
		}
		public static Exception UnknownEscapeSequence(ILineInfo lineInfo, string escape)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown escape sequence '{escape}'.", lineInfo);
		}
		public static Exception UnterminatedStringLiteral(ILineInfo lineInfo)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException("An unterminated string literal.", lineInfo);
		}
		public static Exception UnknownNotation(ILineInfo lineInfo, string notation)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown notation '{notation}'.", lineInfo);
		}
		public static Exception StringLiteralIsTooLong(ILineInfo lineInfo, ulong size, int maxSize)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", lineInfo);
		}
		public static Exception BinaryDataIsTooLong(ILineInfo lineInfo, ulong size, int maxSize)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", lineInfo);
		}
		public static Exception ReadingBrokenDocument(ILineInfo lineInfo, string additionalInformation)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", lineInfo);
		}
		public static Exception UnknownMessagePackType(ILineInfo lineInfo, string type)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"An unknown Message Pack type '{type}'.", lineInfo);
		}
		public static Exception UnexpectedNullValue(ILineInfo lineInfo, string expected, string propertyName, string schemaName)
		{
			if (lineInfo == null) throw new ArgumentNullException(nameof(lineInfo));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				lineInfo);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Integer,
		Number,
		String,
		Boolean,
		Bytes,
		EndOfStream
	}

<#+ 
	}
#>
