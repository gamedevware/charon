<#+ 
	//------------------------------------------------------------------------------
	// <auto-generated>
	//	 This code was generated by a tool.
	//	 Changes to this file may cause incorrect behavior and will be lost if
	//	 the code is regenerated.
	// </auto-generated>
	//------------------------------------------------------------------------------

	// ReSharper disable All

	private void WriteFormulas()
	{
#> 

		private class ArrayTypeDescription : ReflectionTypeDescription, ITypeDescription
		{
			private readonly MemberGroup indexers;
			private readonly MemberGroup constructors;
	
			public ArrayTypeDescription(Type arrayType, FormulaOptions options) : base(arrayType, options)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
				if (!arrayType.IsArray) throw new ArgumentException("Array type is expected.", nameof(arrayType));
	
				this.constructors = CreateConstructors(arrayType);
				this.indexers = CreateIndexers(arrayType);
			}
	
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.constructors;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				if (rank == this.Type.GetArrayRank())
				{
					indexAccessor = this.indexers;
					return true;
				}
				else
				{
					indexAccessor = default;
					return false;
				}
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
	
			private static MemberGroup CreateConstructors(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var rank = arrayType.GetArrayRank();
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var rankConstructor = new MemberDescription((_, indexes) =>
				{
					switch (indexes.Length)
					{
						case 1: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32()));
						case 2: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(Array.CreateInstance(elementType, Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, arrayType, parameterDescriptors);
	
				return new MemberGroup(MemberGroupType.Constructor, new[] { rankConstructor });
			}
			private static MemberGroup CreateIndexers(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var rank = arrayType.GetArrayRank();
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var indexMethod = new MemberDescription((target, indexes) =>
				{
	
					var array = (Array)target.ToObject();
					switch (indexes.Length)
					{
						case 1: return new VariableValue(array.GetValue(indexes[0].ToInt32()));
						case 2: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(array.GetValue(Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, elementType, parameterDescriptors);
				return new MemberGroup(MemberGroupType.Method, new[] { indexMethod });
			}
		}
	

		private sealed class BinaryExpression : FormulaExpression
		{
			private readonly FormulaExpression left;
			private readonly FormulaExpression right;
			private readonly BinaryOperationType binaryOperationType;
			private readonly BinaryOperationType fallbackBinaryOperationType;
	
			public BinaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.left = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.LEFT_ATTRIBUTE);
				this.right = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.RIGHT_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.binaryOperationType = MapToBinaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.AddChecked: this.fallbackBinaryOperationType = BinaryOperationType.Add; break;
					case BinaryOperationType.SubtractChecked: this.fallbackBinaryOperationType = BinaryOperationType.Subtract; break;
					case BinaryOperationType.DivideChecked: this.fallbackBinaryOperationType = BinaryOperationType.Divide; break;
					case BinaryOperationType.MultiplyChecked: this.fallbackBinaryOperationType = BinaryOperationType.Multiply; break;
					default: this.fallbackBinaryOperationType = this.binaryOperationType; break;
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.binaryOperationType == BinaryOperationType.Coalesce)
				{
					return this.ExecuteCoalesce(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.AndAlso ||
						this.binaryOperationType == BinaryOperationType.OrElse)
				{
					return this.ExecuteJunction(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.Power)
				{
					return this.ExecutePower(context);
				}
	
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					if (leftValue.TypeCode == TypeCode.Boolean || rightValue.TypeCode == TypeCode.Boolean)
					{
						return this.ExecuteNullLiftedBoolean(leftValue, rightValue);
					}
					else
					{
						return this.ExecuteNullLifted(leftValue, rightValue);
					}
				}
	
				if (!TryPromoteOperands(ref leftValue, ref rightValue, this.binaryOperationType))
				{
					throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", leftValue },
					{ "1", rightValue },
				};
				var leftValueType = context.TypeResolver.GetTypeDescription(leftValue.Type);
				if (leftValueType.TryGetBinaryOperation(this.binaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackBinaryOperationType != this.binaryOperationType &&  // try to perform fallback binary operation
							leftValueType.TryGetBinaryOperation(this.fallbackBinaryOperationType, out binaryOperation) &&
							binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
			}
	
			private VariableValue ExecuteNullLiftedBoolean(VariableValue leftValue, VariableValue rightValue)
			{
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? VariableValue.Null : false;
						}
						else
						{
							return rightValue.ToBoolean() ? VariableValue.Null : false;
	
						}
					case BinaryOperationType.Or:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? true : VariableValue.Null;
						}
						else
						{
							return rightValue.ToBoolean() ? true : VariableValue.Null;
	
						}
					default: return this.ExecuteNullLifted(leftValue, rightValue);
				}
			}
			private VariableValue ExecuteNullLifted(VariableValue leftValue, VariableValue rightValue)
			{
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
					case BinaryOperationType.Or:
					case BinaryOperationType.ExclusiveOr:
					case BinaryOperationType.Multiply:
					case BinaryOperationType.MultiplyChecked:
					case BinaryOperationType.Divide:
					case BinaryOperationType.DivideChecked:
					case BinaryOperationType.Power:
					case BinaryOperationType.Modulo:
					case BinaryOperationType.Add:
					case BinaryOperationType.AddChecked:
					case BinaryOperationType.Subtract:
					case BinaryOperationType.SubtractChecked:
					case BinaryOperationType.LeftShift:
					case BinaryOperationType.RightShift:
						return VariableValue.Null;
					case BinaryOperationType.GreaterThan:
					case BinaryOperationType.GreaterThanOrEqual:
					case BinaryOperationType.LessThan:
					case BinaryOperationType.LessThanOrEqual:
						return false;
					case BinaryOperationType.Equal:
						return leftValue.IsNull == rightValue.IsNull;
					case BinaryOperationType.NotEqual:
						return leftValue.IsNull != rightValue.IsNull;
					case BinaryOperationType.AndAlso:
					case BinaryOperationType.OrElse:
					case BinaryOperationType.Coalesce:
					default: throw FormulaException.UnknownBinaryExpression(this.binaryOperationType.ToString());
				}
			}
			private VariableValue ExecutePower(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					return VariableValue.Null;
				}
				return Math.Pow(leftValue.ToDouble(), rightValue.ToDouble());
			}
			private VariableValue ExecuteJunction(FormulaExecutionContext context)
			{
				var junctionOperator = this.binaryOperationType == BinaryOperationType.AndAlso ? "&&" : "||";
				var leftValue = this.left.Execute(context);
				if (leftValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, new VariableValue(false));
				}
	
				if (this.binaryOperationType == BinaryOperationType.AndAlso && !leftValue.ToBoolean())
				{
					return new VariableValue(false); // shortcut
				}
				else if (this.binaryOperationType == BinaryOperationType.OrElse && leftValue.ToBoolean())
				{
					return new VariableValue(true); // shortcut
				}
	
				var rightValue = this.right.Execute(context);
				if (rightValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, rightValue);
				}
	
				return this.binaryOperationType == BinaryOperationType.AndAlso ? leftValue.ToBoolean() && rightValue.ToBoolean() : leftValue.ToBoolean() || rightValue.ToBoolean();
			}
			private VariableValue ExecuteCoalesce(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				if (!leftValue.IsNull)
				{
					return leftValue;
				}
				var rightValue = this.right.Execute(context);
				return leftValue.IsNull ? rightValue : leftValue;
			}
	
			private static bool TryPromoteOperands(ref VariableValue leftValue, ref VariableValue rightValue, BinaryOperationType operationType)
			{
				var leftIsEnum = leftValue.Type.IsEnum;
				var leftTypeCode = leftValue.TypeCode;
				var leftIsInteger = leftTypeCode >= TypeCode.SByte && leftTypeCode <= TypeCode.UInt64;
				var leftIsNumber = TypeCodes.IsNumberLike(leftTypeCode);
				var leftIsString = leftTypeCode == TypeCode.String;
				var rightIsEnum = rightValue.Type.IsEnum;
				var rightTypeCode = rightValue.TypeCode;
				var rightIsInteger = rightTypeCode >= TypeCode.SByte && rightTypeCode <= TypeCode.UInt64;
				var rightIString = rightTypeCode == TypeCode.String;
				var rightIsNumber = TypeCodes.IsNumberLike(rightTypeCode);
				var isNumberPromotableOperation = operationType != BinaryOperationType.RightShift && operationType != BinaryOperationType.LeftShift;
	
				if (leftIsEnum && rightIsEnum)
				{
					return leftTypeCode == rightTypeCode;
				}
				else if (leftIsEnum && rightIsInteger)
				{
					if (!rightValue.CanFitInto(leftTypeCode))
					{
						return false;
					}
					rightValue = VariableValue.FromEnum(leftValue.Type, rightValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsInteger && rightIsEnum)
				{
					if (!leftValue.CanFitInto(rightTypeCode))
					{
						return false;
					}
					leftValue = VariableValue.FromEnum(rightValue.Type, leftValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsNumber && rightIsNumber && isNumberPromotableOperation)
				{
					if (leftTypeCode == TypeCode.Decimal || rightTypeCode == TypeCode.Decimal)
					{
						if (leftTypeCode == TypeCode.Double || leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Single)
						{
							return false; // will throw exception
						}
	
						if (leftTypeCode == TypeCode.Decimal)
							rightValue = rightValue.ToDecimal();
						else
							leftValue = leftValue.ToDecimal();
					}
					else if (leftTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Double)
					{
						if (leftTypeCode == TypeCode.Double)
							rightValue = rightValue.ToDouble();
						else
							leftValue = leftValue.ToDouble();
					}
					else if (leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Single)
					{
						if (leftTypeCode == TypeCode.Single)
							rightValue = rightValue.ToSingle();
						else
							leftValue = leftValue.ToSingle();
					}
					else if (leftTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(rightTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						rightValue = rightValue.ToUInt64();
					}
					else if (rightTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(leftTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						leftValue = leftValue.ToUInt64();
					}
					else if (leftTypeCode == TypeCode.Int64 || rightTypeCode == TypeCode.Int64)
					{
						if (leftTypeCode == TypeCode.Int64)
							rightValue = rightValue.ToInt64();
						else
							leftValue = leftValue.ToInt64();
					}
					else if ((leftTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(rightTypeCode)) ||
						(rightTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(leftTypeCode)))
					{
						rightValue = rightValue.ToInt64();
						leftValue = leftValue.ToInt64();
					}
					else if (leftTypeCode == TypeCode.UInt32 || rightTypeCode == TypeCode.UInt32)
					{
						if (leftTypeCode == TypeCode.UInt32)
							rightValue = rightValue.ToUInt32();
						else
							leftValue = leftValue.ToUInt32();
					}
					else
					{
						rightValue = rightValue.ToInt32();
						leftValue = leftValue.ToInt32();
					}
				}
				else if ((leftIsString || rightIString) && (operationType == BinaryOperationType.Add || operationType == BinaryOperationType.AddChecked))
				{
					if (!leftIsString)
					{
						leftValue = leftValue.ToString();
					}
					if (!rightIString)
					{
						rightValue = rightValue.ToString();
					}
				}
	
				return true;
			}
	
			private static BinaryOperationType MapToBinaryOperationType(string expressionType)
			{
				BinaryOperationType binaryOperationType;
				switch (expressionType)
				{
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE_CHECKED: binaryOperationType = BinaryOperationType.DivideChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE: binaryOperationType = BinaryOperationType.Divide; break;
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED: binaryOperationType = BinaryOperationType.MultiplyChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY: binaryOperationType = BinaryOperationType.Multiply; break;
					case FormulaConstants.EXPRESSION_TYPE_MODULO: binaryOperationType = BinaryOperationType.Modulo; break;
					case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED: binaryOperationType = BinaryOperationType.AddChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_ADD: binaryOperationType = BinaryOperationType.Add; break;
					case FormulaConstants.EXPRESSION_TYPE_POWER: binaryOperationType = BinaryOperationType.Power; break;
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED: binaryOperationType = BinaryOperationType.SubtractChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: binaryOperationType = BinaryOperationType.Subtract; break;
					case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT: binaryOperationType = BinaryOperationType.LeftShift; break;
					case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: binaryOperationType = BinaryOperationType.RightShift; break;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: binaryOperationType = BinaryOperationType.GreaterThan; break;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.GreaterThanOrEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: binaryOperationType = BinaryOperationType.LessThan; break;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.LessThanOrEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_EQUAL: binaryOperationType = BinaryOperationType.Equal; break;
					case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: binaryOperationType = BinaryOperationType.NotEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_AND: binaryOperationType = BinaryOperationType.And; break;
					case FormulaConstants.EXPRESSION_TYPE_OR: binaryOperationType = BinaryOperationType.Or; break;
					case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: binaryOperationType = BinaryOperationType.ExclusiveOr; break;
					case FormulaConstants.EXPRESSION_TYPE_AND_ALSO: binaryOperationType = BinaryOperationType.AndAlso; break;
					case FormulaConstants.EXPRESSION_TYPE_OR_ELSE: binaryOperationType = BinaryOperationType.OrElse; break;
					case FormulaConstants.EXPRESSION_TYPE_COALESCE: binaryOperationType = BinaryOperationType.Coalesce; break;
					default: throw FormulaException.UnknownBinaryExpression(expressionType);
				}
				return binaryOperationType;
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.left.BuildDebugView(stringBuilder);
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
	
				stringBuilder.Append(" ");
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And: stringBuilder.Append("&"); break;
					case BinaryOperationType.Or: stringBuilder.Append("|"); break;
					case BinaryOperationType.ExclusiveOr: stringBuilder.Append("^"); break;
					case BinaryOperationType.Multiply: stringBuilder.Append("*"); break;
					case BinaryOperationType.MultiplyChecked: stringBuilder.Append("*"); break;
					case BinaryOperationType.Divide: stringBuilder.Append("/"); break;
					case BinaryOperationType.DivideChecked: stringBuilder.Append("/"); break;
					case BinaryOperationType.Power: stringBuilder.Append("**"); break;
					case BinaryOperationType.Modulo: stringBuilder.Append("%"); break;
					case BinaryOperationType.Add: stringBuilder.Append("+"); break;
					case BinaryOperationType.AddChecked: stringBuilder.Append("+"); break;
					case BinaryOperationType.Subtract: stringBuilder.Append("-"); break;
					case BinaryOperationType.SubtractChecked: stringBuilder.Append("-"); break;
					case BinaryOperationType.LeftShift: stringBuilder.Append("<<"); break;
					case BinaryOperationType.RightShift: stringBuilder.Append(">>"); break;
					case BinaryOperationType.GreaterThan: stringBuilder.Append(">"); break;
					case BinaryOperationType.GreaterThanOrEqual: stringBuilder.Append(">="); break;
					case BinaryOperationType.LessThan: stringBuilder.Append("<"); break;
					case BinaryOperationType.LessThanOrEqual: stringBuilder.Append("<="); break;
					case BinaryOperationType.Equal: stringBuilder.Append("=="); break;
					case BinaryOperationType.NotEqual: stringBuilder.Append("!="); break;
					case BinaryOperationType.AndAlso: stringBuilder.Append("&&"); break;
					case BinaryOperationType.OrElse: stringBuilder.Append("||"); break;
					case BinaryOperationType.Coalesce: stringBuilder.Append("??"); break;
					default: stringBuilder.Append(this.binaryOperationType); break;
				}
				stringBuilder.Append(" ");
	
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.right.BuildDebugView(stringBuilder);
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		public enum BinaryOperationType
		{
			And,
			Or,
			ExclusiveOr,
			Multiply,
			MultiplyChecked,
			Divide,
			DivideChecked,
			Power,
			Modulo,
			Add,
			AddChecked,
			Subtract,
			SubtractChecked,
			LeftShift,
			RightShift,
			GreaterThan,
			GreaterThanOrEqual,
			LessThan,
			LessThanOrEqual,
			Equal,
			NotEqual,
			AndAlso,
			OrElse,
			Coalesce
		}
	

		private sealed class BooleanTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
	
			static BooleanTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() & arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() | arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() ^ arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() == arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() != arguments[1].ToBoolean()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.Not] = CreateUnaryOperation<bool>((_, arguments) => (bool)unchecked(!arguments[0].ToBoolean()));
			}
			/// <inheritdoc />
			public BooleanTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true),
								new ParameterDescription("value2", typeof(Boolean), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true)
							})
					});
			}
	
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class CharTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static CharTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() & arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() | arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() ^ arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToChar(), arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() % arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() > arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() >= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() < arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() <= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() == arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() != arguments[1].ToChar()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToChar()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToChar())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToChar())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToChar())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToChar())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToChar())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToChar())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToChar())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToChar())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToChar())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToChar())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToChar())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToChar())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToChar(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public CharTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Char), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Char), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ConditionExpression : FormulaExpression
		{
			private readonly FormulaExpression test;
			private readonly FormulaExpression ifTrue;
			private readonly FormulaExpression ifFalse;
	
			public ConditionExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.test = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.TEST_ATTRIBUTE);
				this.ifTrue = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.IF_TRUE_ATTRIBUTE);
				this.ifFalse = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.IF_FALSE_ATTRIBUTE);
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var testValue = this.test.Execute(context);
				if (testValue.Type != typeof(bool))
				{
					throw FormulaException.InvalidConditionResultType(testValue);
				}
	
				return testValue.ToBoolean() ? this.ifTrue.Execute(context) : this.ifFalse.Execute(context);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				this.test.BuildDebugView(stringBuilder);
				stringBuilder.Append(")");
				stringBuilder.Append(" ? ");
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifTrue.BuildDebugView(stringBuilder);
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
				stringBuilder.Append(" : ");
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifFalse.BuildDebugView(stringBuilder);
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		private sealed class ConstantExpression : FormulaExpression
		{
			private readonly object value;
			private readonly FormulaTypeReference type;
	
			public ConstantExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.value = ExpressionBuildHelper.GetAnyValue(expressionObj, FormulaConstants.VALUE_ATTRIBUTE, optional: true);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.value == null)
				{
					return VariableValue.Null;
				}
	
				switch (this.type.ToString())
				{
					case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return (Convert.ToString(this.value, CultureInfo.InvariantCulture) ?? string.Empty).FirstOrDefault();
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE: return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE: return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16: return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16: return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32: return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64: return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE: return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return Convert.ToDateTime(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return VariableValue.ToTimeSpan(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TYPE:
						var typeReference = default(FormulaTypeReference);
						if (this.value is IReadOnlyDictionary<string, object> expression)
						{
							typeReference = new FormulaTypeReference(expression);
						}
						else
						{
							var typeName = new VariableValue(this.value).ToString();
							typeReference = new FormulaTypeReference(typeName, Array.Empty<FormulaTypeReference>(), null);
						}
						var type = context.TypeResolver.GetTypeDescription(typeReference).Type;
						return new VariableValue(type);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_STRING: return new VariableValue(new VariableValue(this.value).ToString());
					case FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT:
					default: return new VariableValue(this.value);
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.value == null)
				{
					stringBuilder.Append("null");
				}
				else if (this.value is string || this.value is DateTime || this.value is TimeSpan)
				{
					stringBuilder.Append("\"").Append(this.value).Append("\"");
				}
				else
				{
					stringBuilder.Append(this.value);
				}
			}
		}
	

		private sealed class ConvertExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
			private readonly FormulaExpression expression;
			private readonly string expressionType;
	
			public ConvertExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE, optional: false);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
			public ConvertExpression(FormulaExpression expression, Type type, bool checkedScope = true)
			{
				this.expressionType = checkedScope ? FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED : FormulaConstants.EXPRESSION_TYPE_CONVERT;
				this.expression = expression;
				this.type = new FormulaTypeReference(type);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var value = this.expression.Execute(context);
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(this.type);
	
				if (value.IsNull)
				{
					if (targetTypeDescriptor.CanBeNull)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CanConvertNullToType(value, targetTypeDescriptor);
					}
				}
	
				if (value.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(targetTypeDescriptor.Type))
				{
					return this.ExecuteLambdaBinding(targetTypeDescriptor, (UnboundLambda)value.ToObject());
				}
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					return ExecuteTypeAs(targetTypeDescriptor, value);
				}
				else
				{
					return this.ExecuteConvert(context, value, targetTypeDescriptor);
				}
	
			}
			private VariableValue ExecuteConvert(FormulaExecutionContext context, VariableValue value, ITypeDescription targetTypeDescription)
			{
				var valueTypeDescriptor = context.TypeResolver.GetTypeDescription(value.Type);
				var targetValueType = targetTypeDescription.Type;
	
				if (targetValueType.IsAssignableFrom(value.Type))
				{
					return value;
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", value }
				};
	
				// try checked conversion
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED &&
					(valueTypeDescriptor.TryGetCheckedConversionOperation(out var conversionOperation) ||
					targetTypeDescription.TryGetCheckedConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out var result))
				{
	
					return result;
				}
	
				// try fallback/checked conversion
				if ((valueTypeDescriptor.TryGetConversionOperation(out conversionOperation) ||
					targetTypeDescription.TryGetConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out result))
				{
					return result;
				}
	
				throw FormulaException.CanConvertToType(value, targetTypeDescription);
			}
			private VariableValue ExecuteLambdaBinding(ITypeDescription delegateTypeDescription, UnboundLambda unboundLambda)
			{
				if (delegateTypeDescription == null) throw new ArgumentNullException(nameof(delegateTypeDescription));
				if (unboundLambda == null) throw new ArgumentNullException(nameof(unboundLambda));
	
				if (!unboundLambda.IsSignatureMatching(delegateTypeDescription.Type))
				{
					throw FormulaException.CanConvertToType(new VariableValue(unboundLambda), delegateTypeDescription);
				}
	
				var boundLambda = unboundLambda.BindTo(delegateTypeDescription.Type);
				return new VariableValue(boundLambda);
			}
			private static VariableValue ExecuteTypeAs(ITypeDescription targetTypeDescription, VariableValue value)
			{
				if (targetTypeDescription.Type.IsAssignableFrom(value.Type))
				{
					return value;
				}
				else
				{
					return VariableValue.Null;
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					this.expression.BuildDebugView(stringBuilder);
					stringBuilder.Append(" as ");
					stringBuilder.Append(this.type);
				}
				else
				{
					stringBuilder.Append("(");
					stringBuilder.Append(this.type);
					stringBuilder.Append(") ");
					this.expression.BuildDebugView(stringBuilder);
				}
			}
		}
	

		private sealed class CSharpNameUtils
		{
			private static readonly Dictionary<Type, string> AliasByTypeName;
	
			static CSharpNameUtils()
			{
				var typeNameByAlias = new Dictionary<string, Type>
				{
					// ReSharper disable StringLiteralTypo
					{ "void", typeof(void) },
					{ "char", typeof(char) },
					{ "bool", typeof(bool) },
					{ "byte", typeof(byte) },
					{ "sbyte", typeof(sbyte) },
					{ "decimal", typeof(decimal) },
					{ "double", typeof(double) },
					{ "float", typeof(float) },
					{ "int", typeof(int) },
					{ "uint", typeof(uint) },
					{ "long", typeof(long) },
					{ "ulong", typeof(ulong) },
					{ "object", typeof(object) },
					{ "short", typeof(short) },
					{ "ushort", typeof(ushort) },
					{ "string", typeof(string) }
	
					// ReSharper restore StringLiteralTypo
				};
				AliasByTypeName = typeNameByAlias.ToDictionary(kv => kv.Value, kv => kv.Key);
			}
	
			[Flags]
			private enum TypeNameFormatOptions
			{
				None,
				// ReSharper disable once ShiftExpressionRealShiftCountIsZero
				IncludeDeclaringType = 0x1 << 0,
				IncludeNamespace = 0x1 << 1 | IncludeDeclaringType,
				IncludeGenericArguments = 0x1 << 2,
				IncludeGenericSuffix = 0x1 << 3,
			}
	
			public static KeyValuePair<string, string> GetTypeNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var name = type.Name;
				if (string.IsNullOrEmpty(name))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(name, name + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(
						GetCSharpName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else if (AliasByTypeName.TryGetValue(type, out var alias))
				{
					return new KeyValuePair<string, string>(alias, GetCSharpName(type).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpName(type).ToString(), null);
				}
			}
			public static KeyValuePair<string, string> GetTypeFullNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var fullName = type.FullName;
				if (string.IsNullOrEmpty(fullName))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(fullName, fullName + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpFullName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type).ToString(), null);
				}
			}
	
			public static string GetCSharpFullNameWithGenerics(Type type)
			{
				return GetCSharpFullName(type, new StringBuilder(), TypeNameFormatOptions.IncludeGenericArguments).ToString();
			}
	
			private static StringBuilder GetCSharpFullName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options | TypeNameFormatOptions.IncludeNamespace);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
			private static StringBuilder GetCSharpName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options & ~TypeNameFormatOptions.IncludeNamespace | TypeNameFormatOptions.IncludeDeclaringType);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					return RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
	
			private static StringBuilder RemoveGenericSuffix(StringBuilder builder, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return builder;
	
				var endIndex = startIndex + count;
				var markerIndex = IndexOf(builder, '`', startIndex, count);
				var cutStartIndex = markerIndex;
				while (markerIndex >= 0)
				{
					markerIndex++;
					while (markerIndex < endIndex && char.IsDigit(builder[markerIndex]))
						markerIndex++;
	
					var cutLength = markerIndex - cutStartIndex;
					builder.Remove(cutStartIndex, cutLength);
	
					endIndex -= cutLength;
					markerIndex = IndexOf(builder, '`', cutStartIndex, endIndex - cutStartIndex);
					cutStartIndex = markerIndex;
				}
	
				return builder;
			}
	
			private static void WriteName(Type type, StringBuilder builder, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				var arrayDepth = 0;
				while (type.IsArray)
				{
					type = type.GetElementType();
					arrayDepth++;
				}
	
				var writeGenericArguments = (options & TypeNameFormatOptions.IncludeGenericArguments) == TypeNameFormatOptions.IncludeGenericArguments;
				var namespaceWritten = (options & TypeNameFormatOptions.IncludeNamespace) != TypeNameFormatOptions.IncludeNamespace;
				var writeDeclaringType = (options & TypeNameFormatOptions.IncludeDeclaringType) == TypeNameFormatOptions.IncludeDeclaringType;
	
				var genericArguments = type.IsGenericType && writeGenericArguments ? type.GetGenericArguments() : Type.EmptyTypes;
				var genericArgumentOffset = 0;
				foreach (var declaringTypeInfo in new TypeNestingEnumerator(type))
				{
					if (!namespaceWritten)
					{
						var typeNamespace = declaringTypeInfo.Namespace;
						builder.Append(typeNamespace);
						if (!string.IsNullOrEmpty(typeNamespace))
							builder.Append('.');
						namespaceWritten = true;
					}
	
					var genericArgumentsCount = (declaringTypeInfo.IsGenericType && writeGenericArguments ? declaringTypeInfo.GetGenericArguments().Length : 0) - genericArgumentOffset;
					var partialGenerics = new ArraySegment<Type>(genericArguments, genericArgumentOffset, genericArgumentsCount);
	
					if (writeDeclaringType || declaringTypeInfo == type)
					{
						WriteNamePart(declaringTypeInfo, builder, partialGenerics, options);
	
						if (declaringTypeInfo == type == false)
							builder.Append('.');
					}
	
					genericArgumentOffset += genericArgumentsCount;
				}
	
				for (var d = 0; d < arrayDepth; d++)
				{
					builder.Append("[]");
				}
			}
			private static void WriteNamePart(Type type, StringBuilder builder, ArraySegment<Type> genericArguments, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				builder.Append(type.Name);
	
				if (genericArguments.Count > 0)
				{
					builder.Append("<");
					for (var i = genericArguments.Offset; i < genericArguments.Offset + genericArguments.Count; i++)
					{
						// ReSharper disable once PossibleNullReferenceException
						if (genericArguments.Array[i].IsGenericParameter == false)
						{
							WriteName(genericArguments.Array[i], builder, options);
						}
						builder.Append(',');
					}
					builder.Length--;
					builder.Append(">");
				}
			}
			private static int IndexOf(StringBuilder builder, char character, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return -1;
	
				for (int i = startIndex, len = startIndex + count; i < len; i++)
				{
					if (builder[i] == character)
						return i;
				}
				return -1;
			}
	
			public struct TypeNestingEnumerator : IEnumerator<Type>, IEnumerable<Type>
			{
				private readonly Type typeInfo;
	
				public TypeNestingEnumerator(Type typeInfo)
				{
					this.typeInfo = typeInfo;
					this.Current = null;
				}
	
				public bool MoveNext()
				{
					if (this.Current == null)
					{
						this.Reset();
						return true;
					}
					else if (this.Current == this.typeInfo)
					{
						return false;
					}
	
					var typeAboveCurrent = this.typeInfo;
					while (typeAboveCurrent != null && this.Current == GetDeclaringType(typeAboveCurrent) == false)
						typeAboveCurrent = GetDeclaringType(typeAboveCurrent);
	
					this.Current = typeAboveCurrent;
					return typeAboveCurrent != null;
				}
				public void Reset()
				{
					this.Current = this.typeInfo;
					while (GetDeclaringType(this.Current) != null) this.Current = GetDeclaringType(this.Current);
				}
	
				private static Type GetDeclaringType(Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					var declaringType = type.DeclaringType;
					// ReSharper disable once ConditionIsAlwaysTrueOrFalse
					if (declaringType == null)
					{
						return null;
					}
					return declaringType;
				}
	
				public Type Current { get; private set; }
				object IEnumerator.Current => this.Current;
	
				public TypeNestingEnumerator GetEnumerator()
				{
					return this;
				}
				IEnumerator<Type> IEnumerable<Type>.GetEnumerator()
				{
					return this;
				}
				IEnumerator IEnumerable.GetEnumerator()
				{
					return this;
				}
	
				public void Dispose()
				{
	
				}
			}
		}
	

		private class DefaultExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
	
			public DefaultExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				switch (this.type.ToString())
				{
					case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return default(char);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return default(bool);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE: return default(byte);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE: return default(sbyte);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16: return default(short);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16: return default(ushort);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32: return default(int);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return default(uint);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64: return default(long);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return default(ulong);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return default(double);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE: return default(float);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return default(decimal);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return default(DateTime);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return default(TimeSpan);
					default:
						var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
						return typeDescription.DefaultValue;
	
				}
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("default(").Append(this.type).Append(")");
			}
		}
	

		private sealed class EnumTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private readonly Lazy<MemberGroup> lazyCheckedConversions;
			private readonly Lazy<MemberGroup> lazyUncheckedConversions;
			private readonly Lazy<MemberGroup[]> lazyBinaryOperations;
			private readonly Lazy<MemberGroup[]> lazyUnaryOperations;
	
			/// <inheritdoc />
			public EnumTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
				if (!type.IsEnum) throw new ArgumentException($"Type '{type}' should be enum type.");
	
				this.lazyCheckedConversions = new Lazy<MemberGroup>(() => CreateCheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUncheckedConversions = new Lazy<MemberGroup>(() => CreateUncheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyBinaryOperations = new Lazy<MemberGroup[]>(() => CreateBinaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUnaryOperations = new Lazy<MemberGroup[]>(() => CreateUnaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				var binaryOperations = this.lazyBinaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < binaryOperations.Length)
				{
					binaryOperation = binaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				var unaryOperations = this.lazyUnaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < unaryOperations.Length)
				{
					unaryOperation = unaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyCheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyUncheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", enumType, isRequired: true)
					});
			}
			private static MemberDescription CreateConvertFrom<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: enumType,
					parameters: new[] {
						new ParameterDescription("value", typeof(T), isRequired: true)
					});
			}
			private static MemberGroup CreateCheckedConversions(Type enumType)
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToUInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToUInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToUInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToUInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToUInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToUInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToUInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToUInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToUInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToUInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToUInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
			}
			private static MemberGroup CreateUncheckedConversions(Type enumType)
			{
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
			}
			private static MemberGroup[] CreateBinaryOperations(Type enumType)
			{
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				var binaryOperations = new MemberGroup[lastBinaryOperation + 1];
				binaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() & arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() | arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() ^ arguments[1].ToInt64()));
	
				binaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() % arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() << arguments[1].ToInt32()));
				binaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() >> arguments[1].ToInt32()));
	
				binaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
				return binaryOperations;
			}
			private static MemberGroup[] CreateUnaryOperations(Type enumType)
			{
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				var unaryOperations = new MemberGroup[lastUnaryOperation + 1];
				unaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(+arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, checked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked((Int64)~arguments[0].ToUInt64())));
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
				return unaryOperations;
			}
	
			private static bool IsSigned(Type enumType)
			{
				var underlyingType = Enum.GetUnderlyingType(enumType);
				return underlyingType == typeof(sbyte) || underlyingType == typeof(short) || underlyingType == typeof(int) || underlyingType == typeof(long);
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ExpressionBuildHelper
		{
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
			private static readonly IReadOnlyDictionary<string, FormulaExpression> EmptyArguments = new Dictionary<string, FormulaExpression>();
	
			public static FormulaExpression GetExpression(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					return FormulaExpression.Create(propertyValueExpressionObj);
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static string GetString(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is string propertyValueString)
				{
					return propertyValueString;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static object GetAnyValue(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					return propertyValue;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static bool? GetBoolean(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is bool propertyValueBool)
				{
					return propertyValueBool;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static FormulaTypeReference GetTypeRef(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					if (propertyValue is string plainName)
					{
						return new FormulaTypeReference(plainName);
					}
					else if (TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
					{
						return new FormulaTypeReference(propertyValueExpressionObj);
					}
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static IReadOnlyList<FormulaTypeReference> GetTypeRefArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new List<FormulaTypeReference>(propertyValueExpressionObj.Count);
					for (var i = 0; i < propertyValueExpressionObj.Count; i++)
					{
						var argumentIndex = GetIndexAsString(i);
						arguments.Add(GetTypeRef(propertyValueExpressionObj, argumentIndex, optional: false));
					}
					return arguments;
				}
	
				return Array.Empty<FormulaTypeReference>();
			}
			public static IReadOnlyDictionary<string, FormulaExpression> GetArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new Dictionary<string, FormulaExpression>(propertyValueExpressionObj.Count);
					foreach (var kv in propertyValueExpressionObj)
					{
						arguments[kv.Key] = GetExpression(propertyValueExpressionObj, kv.Key, optional: false);
					}
					return arguments;
				}
	
				return EmptyArguments;
			}
	
			private static bool TryGetExpressionDictionary(object value, out IReadOnlyDictionary<string, object> expressionObj)
			{
				if (value is IReadOnlyDictionary<string, object> readOnlyDictionary)
				{
					expressionObj = readOnlyDictionary;
					return true;
				}
				else if (value is IDictionary<string, object> dictionary)
				{
					expressionObj = new Dictionary<string, object>(dictionary);
					return true;
				}
	
				expressionObj = null;
				return false;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
		}
	

		private sealed class Float32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<float>((_, arguments) => (double)Math.Pow(arguments[0].ToSingle(), arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<float>((_, arguments) => (float)(arguments[0].ToSingle() % arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() > arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() >= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() < arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() <= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() == arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() != arguments[1].ToSingle()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(+arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(-arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<float>((_, arguments) => (float)checked(-arguments[0].ToSingle()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSingle())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSingle())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Single), isRequired: true),
								new ParameterDescription("value2", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Single), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Float64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<double>((_, arguments) => (double)Math.Pow(arguments[0].ToDouble(), arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<double>((_, arguments) => (double)(arguments[0].ToDouble() % arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() > arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() >= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() < arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() <= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() == arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() != arguments[1].ToDouble()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(+arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(-arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<double>((_, arguments) => (double)checked(-arguments[0].ToDouble()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToDouble())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToDouble())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true),
								new ParameterDescription("value2", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(Double), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class FormulaConstants
		{
			public const string EXPRESSION_TYPE_ATTRIBUTE = "expressionType";
			public const string EXPRESSION_ATTRIBUTE = "expression";
			public const string ARGUMENTS_ATTRIBUTE = "arguments";
			public const string LEFT_ATTRIBUTE = "left";
			public const string RIGHT_ATTRIBUTE = "right";
			public const string TEST_ATTRIBUTE = "test";
			public const string IF_TRUE_ATTRIBUTE = "ifTrue";
			public const string IF_FALSE_ATTRIBUTE = "ifFalse";
			public const string TYPE_ATTRIBUTE = "type";
			public const string VALUE_ATTRIBUTE = "value";
			public const string PROPERTY_OR_FIELD_NAME_ATTRIBUTE = "propertyOrFieldName";
			public const string NAME_ATTRIBUTE = "name";
			public const string USE_NULL_PROPAGATION_ATTRIBUTE = "useNullPropagation";
			// expression types
			public const string EXPRESSION_TYPE_PROPERTY_OR_FIELD = "PropertyOrField";
			public const string EXPRESSION_TYPE_MEMBER_RESOLVE = "MemberResolve";
			public const string EXPRESSION_TYPE_CONSTANT = "Constant";
			public const string EXPRESSION_TYPE_CONVERT = "Convert";
			public const string EXPRESSION_TYPE_CONVERT_CHECKED = "ConvertChecked";
			public const string EXPRESSION_TYPE_GROUP = "Group";
			public const string EXPRESSION_TYPE_INVOKE = "Invoke";
			public const string EXPRESSION_TYPE_LAMBDA = "Lambda";
			public const string EXPRESSION_TYPE_INDEX = "Index";
			public const string EXPRESSION_TYPE_UNCHECKED_SCOPE = "UncheckedScope";
			public const string EXPRESSION_TYPE_CHECKED_SCOPE = "CheckedScope";
			public const string EXPRESSION_TYPE_TYPE_OF = "TypeOf";
			public const string EXPRESSION_TYPE_DEFAULT = "Default";
			public const string EXPRESSION_TYPE_NEW = "New";
			public const string EXPRESSION_TYPE_NEW_ARRAY_BOUNDS = "NewArrayBounds";
			public const string EXPRESSION_TYPE_ADD = "Add";
			public const string EXPRESSION_TYPE_ADD_CHECKED = "AddChecked";
			public const string EXPRESSION_TYPE_SUBTRACT = "Subtract";
			public const string EXPRESSION_TYPE_SUBTRACT_CHECKED = "SubtractChecked";
			public const string EXPRESSION_TYPE_LEFT_SHIFT = "LeftShift";
			public const string EXPRESSION_TYPE_RIGHT_SHIFT = "RightShift";
			public const string EXPRESSION_TYPE_GREATER_THAN = "GreaterThan";
			public const string EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL = "GreaterThanOrEqual";
			public const string EXPRESSION_TYPE_LESS_THAN = "LessThan";
			public const string EXPRESSION_TYPE_LESS_THAN_OR_EQUAL = "LessThanOrEqual";
			public const string EXPRESSION_TYPE_NEGATE = "Negate";
			public const string EXPRESSION_TYPE_NEGATE_CHECKED = "NegateChecked";
			public const string EXPRESSION_TYPE_POWER = "Power";
			public const string EXPRESSION_TYPE_COMPLEMENT = "Complement";
			public const string EXPRESSION_TYPE_DIVIDE = "Divide";
			public const string EXPRESSION_TYPE_DIVIDE_CHECKED = "DivideChecked";
			public const string EXPRESSION_TYPE_MULTIPLY = "Multiply";
			public const string EXPRESSION_TYPE_MULTIPLY_CHECKED = "MultiplyChecked";
			public const string EXPRESSION_TYPE_MODULO = "Modulo";
			public const string EXPRESSION_TYPE_TYPE_IS = "TypeIs";
			public const string EXPRESSION_TYPE_TYPE_AS = "TypeAs";
			public const string EXPRESSION_TYPE_NOT = "Not";
			public const string EXPRESSION_TYPE_EQUAL = "Equal";
			public const string EXPRESSION_TYPE_NOT_EQUAL = "NotEqual";
			public const string EXPRESSION_TYPE_AND = "And";
			public const string EXPRESSION_TYPE_OR = "Or";
			public const string EXPRESSION_TYPE_EXCLUSIVE_OR = "ExclusiveOr";
			public const string EXPRESSION_TYPE_AND_ALSO = "AndAlso";
			public const string EXPRESSION_TYPE_OR_ELSE = "OrElse";
			public const string EXPRESSION_TYPE_COALESCE = "Coalesce";
			public const string EXPRESSION_TYPE_CONDITION = "Condition";
			public const string EXPRESSION_TYPE_UNARY_PLUS = "UnaryPlus";
			// known types
			public const string KNOWN_TYPE_ARRAY = "Array";
			public const string KNOWN_TYPE_SYSTEM_VOID = "System.Void";
			public const string KNOWN_TYPE_SYSTEM_CHAR = "System.Char";
			public const string KNOWN_TYPE_SYSTEM_BOOL = "System.Boolean";
			public const string KNOWN_TYPE_SYSTEM_BYTE = "System.Byte";
			public const string KNOWN_TYPE_SYSTEM_SBYTE = "System.SByte";
			public const string KNOWN_TYPE_SYSTEM_DECIMAL = "System.Decimal";
			public const string KNOWN_TYPE_SYSTEM_DATE_TIME = "System.DateTime";
			public const string KNOWN_TYPE_SYSTEM_TIME_SPAN = "System.TimeSpan";
			public const string KNOWN_TYPE_SYSTEM_DOUBLE = "System.Double";
			public const string KNOWN_TYPE_SYSTEM_SINGLE = "System.Single";
			public const string KNOWN_TYPE_SYSTEM_INT32 = "System.Int32";
			public const string KNOWN_TYPE_SYSTEM_UINT32 = "System.UInt32";
			public const string KNOWN_TYPE_SYSTEM_INT64 = "System.Int64";
			public const string KNOWN_TYPE_SYSTEM_UINT64 = "System.UInt64";
			public const string KNOWN_TYPE_SYSTEM_OBJECT = "System.Object";
			public const string KNOWN_TYPE_SYSTEM_INT16 = "System.Int16";
			public const string KNOWN_TYPE_SYSTEM_UINT16 = "System.UInt16";
			public const string KNOWN_TYPE_SYSTEM_STRING = "System.String";
			public const string KNOWN_TYPE_SYSTEM_TYPE = "System.Type";
			public const string KNOWN_TYPE_SYSTEM_ARRAY = "System.Array";
			// notations
			public const string NOTATION_TRUE_STRING = "true";
			public const string NOTATION_FALSE_STRING = "false";
			public const string NOTATION_NULL_STRING = "null";
			//
	
			public static readonly Dictionary<string, string> TypeAliases = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "void", KNOWN_TYPE_SYSTEM_VOID },
				{ "char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "bool", KNOWN_TYPE_SYSTEM_BOOL },
				{ "byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "sbyte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "float", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "int", KNOWN_TYPE_SYSTEM_INT32 },
				{ "uint", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "long", KNOWN_TYPE_SYSTEM_INT64 },
				{ "ulong", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "short", KNOWN_TYPE_SYSTEM_INT16 },
				{ "ushort", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "string", KNOWN_TYPE_SYSTEM_STRING },
			};
	
			public static readonly Dictionary<string, string> SystemTypes = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "Void", KNOWN_TYPE_SYSTEM_VOID },
				{ "Char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "Boolean", KNOWN_TYPE_SYSTEM_BOOL },
				{ "Byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "SByte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "Decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "Double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "Single", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "Int32", KNOWN_TYPE_SYSTEM_INT32 },
				{ "UInt32", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "Int64", KNOWN_TYPE_SYSTEM_INT64 },
				{ "UInt64", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "Object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "Int16", KNOWN_TYPE_SYSTEM_INT16 },
				{ "UInt16", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "String", KNOWN_TYPE_SYSTEM_STRING },
				{ "Type", KNOWN_TYPE_SYSTEM_TYPE },
				{ "Array", KNOWN_TYPE_SYSTEM_ARRAY },
				{ "DateTime", KNOWN_TYPE_SYSTEM_DATE_TIME },
				{ "TimeSpan", KNOWN_TYPE_SYSTEM_TIME_SPAN },
			};
		}
	

		public class FormulaException : Exception
		{
			public FormulaException(string message) : base(message)
			{
	
			}
			public FormulaException(string message, Exception innerException) : base(message, innerException)
			{
	
			}
	
			public static Exception MissingBinaryOperation(BinaryOperationType binaryOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"Missing binary operation '{binaryOperation}' between types '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}'.");
			}
			public static Exception MissingUnaryOperation(UnaryOperationType unaryOperation, VariableValue target)
			{
				throw new FormulaException($"Missing unary operation '{unaryOperation}' on type '{CSharpName(target.Type)}'.");
			}
			public static Exception UnknownUnaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown unary expression type '{expressionType}'.");
			}
			public static Exception UnknownBinaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown binary expression type '{expressionType}'.");
			}
			public static Exception UnknownExpressionType(string expressionType)
			{
				throw new FormulaException($"Unknown expression type '{expressionType}'.");
			}
			public static Exception CantAccessMemberOnNull(string name)
			{
				throw new FormulaException($"Can't access member with name '{name}' on null value.");
			}
			public static Exception CantFindMember(ITypeDescription targetType, string name, IEnumerable<string> availableNames)
			{
				throw new FormulaException($"Can't find member with name '{name}' on type '{targetType}'. List of available members: {string.Join(", ", availableNames)}." );
			}
			public static Exception UnableToResolveGlobalName(string name, IEnumerable<string> availableNames)
			{
				throw new FormulaException($"Unable to find parameter with name '{name}' or type starting from this name or member on global object. List of available parameters and global variables: {string.Join(", ", availableNames)}.");
			}
			public static Exception CanConvertNullToType(VariableValue value, ITypeDescription targetType)
			{
				throw new FormulaException($"Can't convert null value to type '{targetType}'.");
			}
			public static VariableValue WrongJunctionOperands(string junctionOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"There is no '{junctionOperation}' between '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}' types.");
			}
			public static Exception CantFindIndexer(ITypeDescription targetType, Dictionary<string, VariableValue> indexArguments)
			{
				throw new FormulaException($"Can't find indexer on type '{targetType}' accepting {indexArguments.Count} arguments.");
			}
			public static Exception CantIndexOnNull()
			{
				throw new FormulaException("Can't apply indexing to null value.");
			}
			public static Exception CantCallOnNull()
			{
				throw new FormulaException("Can't invoke on null value.");
			}
			public static Exception UnableToInvokeNonMethodOrDelegate(VariableValue variableValue)
			{
				throw new FormulaException($"Can invoke on non-method member or non-delegate value of type '{CSharpName(variableValue.Type)}'.");
			}
			public static Exception InvalidConditionResultType(VariableValue testValue)
			{
				throw new FormulaException($"Can't use value of type '{CSharpName(testValue.Type)}' for condition result. A boolean value is expected.");
			}
			public static Exception CanConvertToType(VariableValue value, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"There is no explicit/implicit conversion exists from '{CSharpName(value.Type)}' type to '{targetTypeDescription}' type.");
			}
			public static Exception UnableToBindMethodToParameters(string name, ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting {callArguments.Count} arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception UnableToBindConstructorToParameters(ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception CanAccessMethodOrConstructorGroup(string name, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"Can't access method group with name '{name}' on type '{targetTypeDescription}' in this context.");
			}
			public static Exception UnableToResolveType(FormulaTypeReference typeReference)
			{
				throw new FormulaException($"Can't find type with name '{typeReference}'. Add this type to list of known types before using it.");
			}
			public static Exception InvalidLambdaArgument(FormulaExpression lambdaArgument)
			{
				throw new FormulaException($"Invalid lambda argument expression '{lambdaArgument}'({lambdaArgument.GetType().Name}) while plain argument name is expected.");
			}
			public static Exception MissingRequiredAttributeInExpression(string propertyName)
			{
				throw new FormulaException($"Missing required attribute '{propertyName}' on expression object.");
			}
	
			private static string CSharpName(Type type)
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(type);
			}
		}
	

		public class FormulaExecutionContext
		{
			public bool AutoNullPropagation { get; }
			public VariableValue Global { get; }
			public IReadOnlyDictionary<string, VariableValue> Arguments { get; }
			public IFormulaTypeResolver TypeResolver { get; }
	
			public FormulaExecutionContext
			(
				IReadOnlyDictionary<string, VariableValue> arguments,
				VariableValue global = default,
				bool autoNullPropagation = false,
				IFormulaTypeResolver typeResolver = null)
			{
				this.Arguments = arguments;
				this.Global = global;
				this.AutoNullPropagation = autoNullPropagation;
				this.TypeResolver = typeResolver ?? KnownFormulaTypeResolver.Default;
			}
		}
	

		public abstract class FormulaExpression
		{
			public static FormulaExpression Create(IReadOnlyDictionary<string, object> expressionObj, Type expectedType = null)
			{
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				FormulaExpression expression;
				switch (expressionType)
				{
	
					case FormulaConstants.EXPRESSION_TYPE_PROPERTY_OR_FIELD:
					case FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE: expression = new MemberExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_INVOKE: expression = new InvokeExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_LAMBDA: expression = new LambdaExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_INDEX: expression = new IndexExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_TYPE_OF: expression = new TypeOfExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONSTANT: expression = new ConstantExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_DEFAULT: expression = new DefaultExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEW: expression = new NewExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS: expression = new NewArrayBoundExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_ADD:
					case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT:
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT:
					case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT:
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN:
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN:
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_POWER:
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE:
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY:
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_MODULO:
					case FormulaConstants.EXPRESSION_TYPE_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_AND:
					case FormulaConstants.EXPRESSION_TYPE_OR:
					case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR:
					case FormulaConstants.EXPRESSION_TYPE_AND_ALSO:
					case FormulaConstants.EXPRESSION_TYPE_OR_ELSE:
					case FormulaConstants.EXPRESSION_TYPE_COALESCE: expression = new BinaryExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE:
					case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_NOT:
					case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: expression = new UnaryExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_TYPE_IS: expression = new TypeIsExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONVERT:
					case FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_TYPE_AS: expression = new ConvertExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONDITION: expression = new ConditionExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_GROUP:
					case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE:
					case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE:
					case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: expression = new UnaryExpression(expressionObj); break;
					default: throw FormulaException.UnknownExpressionType(expressionType);
				}
	
				if (expectedType != null)
				{
					expression = new ConvertExpression(expression, expectedType, checkedScope: false);
				}
	
				return expression;
			}
	
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, ResultT>(default, default, default); } }
			public static void RegisterFunc<ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<ResultT>(default, default, default); } }
	
			public static void RegisterAction<Arg1T, Arg2T, Arg3T, Arg4T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T, Arg4T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T, Arg3T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T>(default, default, default); } }
			public static void RegisterAction<Arg1T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T>(default, default, default); } }
	
			public abstract VariableValue Execute(FormulaExecutionContext context);
	
			public abstract void BuildDebugView(StringBuilder stringBuilder);
	
			/// <inheritdoc />
			public sealed override string ToString()
			{
				var debugViewBuilder = new StringBuilder();
				this.BuildDebugView(debugViewBuilder);
				return debugViewBuilder.ToString();
			}
		}
	

		[Flags]
		public enum FormulaOptions
		{
			None = 0,
			UseDynamicMethods = 0x1 << 0,
			AllowReflectionApi = 0x1 << 1,
		}
	

		public sealed class FormulaTypeReference
		{
			public static readonly FormulaTypeReference Empty = new FormulaTypeReference(string.Empty, null, null);
			private static readonly IReadOnlyList<FormulaTypeReference> EmptyTypeReferences = Array.Empty<FormulaTypeReference>();
	
			private readonly FormulaTypeReference expression;
			private readonly IReadOnlyList<FormulaTypeReference> typeArguments;
			private string fullName;
			private string displayName;
	
			public string Name { get; }
			public string FullName => this.fullName ?? (this.fullName = this.GetFullName());
			public IReadOnlyList<FormulaTypeReference> TypeArguments => this.typeArguments;
			public bool IsEmpty => string.IsNullOrEmpty(this.Name) && this.expression == null && this.typeArguments.Count == 0;
	
			public FormulaTypeReference(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.Name = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.NAME_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.typeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
	
				this.displayName = string.Empty;
			}
			public FormulaTypeReference(string name, IReadOnlyList<FormulaTypeReference> typeArguments = null, FormulaTypeReference baseTypeReference = null)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
	
				this.Name = name;
				this.typeArguments = typeArguments ?? EmptyTypeReferences;
				this.expression = baseTypeReference;
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
			}
			public FormulaTypeReference(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type.IsArray)
				{
					this.Name = nameof(Array);
					this.expression = new FormulaTypeReference(typeof(Array).Namespace);
					this.typeArguments = new[] {
						new FormulaTypeReference(type.GetElementType() ?? typeof(object))
					};
				}
				else
				{
					this.Name = type.Name;
					this.typeArguments = EmptyTypeReferences;
	
					if (type.DeclaringType != null)
					{
						this.expression = new FormulaTypeReference(type.DeclaringType);
					}
					else if (!string.IsNullOrEmpty(type.Namespace))
					{
						this.expression = new FormulaTypeReference(type.Namespace);
					}
	
					if (type.IsGenericType)
					{
						var genericArguments = type.GetGenericArguments();
						if (type.IsGenericTypeDefinition)
						{
							this.typeArguments = Array.ConvertAll(genericArguments, _ => Empty);
						}
						else
						{
							this.typeArguments = Array.ConvertAll(genericArguments, genericArgument => new FormulaTypeReference(genericArgument));
						}
					}
				}
			}
	
			private StringBuilder BuildFullName(StringBuilder nameBuilder, bool writeGenerics)
			{
				if (nameBuilder == null) throw new ArgumentNullException(nameof(nameBuilder));
	
				if (this.expression != null)
				{
					this.expression.BuildFullName(nameBuilder, writeGenerics);
					nameBuilder.Append(".");
				}
	
				nameBuilder.Append(this.Name);
				if (this.typeArguments.Count > 0 && writeGenerics)
				{
					nameBuilder.Append("<");
					foreach (var genericArgument in this.typeArguments)
					{
						genericArgument.BuildFullName(nameBuilder, writeGenerics = true);
						nameBuilder.Append(", ");
					}
					nameBuilder.Length -= 2;
					nameBuilder.Append(">");
				}
				return nameBuilder;
			}
	
			private string GetFullName()
			{
				return this.BuildFullName(new StringBuilder(), writeGenerics: false).ToString();
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				if (this.typeArguments.Count == 0 &&
					this.expression == null)
				{
					if (FormulaConstants.SystemTypes.TryGetValue(this.Name, out var systemTypeName) ||
						FormulaConstants.TypeAliases.TryGetValue(this.Name, out systemTypeName))
					{
						return systemTypeName;
					}
	
					return this.Name;
				}
				else if (!string.IsNullOrEmpty(this.displayName))
				{
					return this.displayName;
				}
				else if (this.expression == null && this.Name == FormulaConstants.KNOWN_TYPE_ARRAY && this.typeArguments.Count == 1)
				{
					return this.displayName = this.typeArguments[0] + "[]";
				}
				else
				{
					var nameBuilder = this.BuildFullName(new StringBuilder(), writeGenerics: true);
					return this.displayName = nameBuilder.ToString();
				}
			}
		}
	

		public sealed class GenericConstraint
		{
			private readonly Type[] requiredTypes;
			private readonly GenericParameterAttributes otherConstraints;
	
			public GenericConstraint(Type genericArgument)
			{
				if (genericArgument == null) throw new ArgumentNullException(nameof(genericArgument));
				if (!genericArgument.IsGenericParameter) throw new ArgumentException("Type should be generic parameter.", nameof(genericArgument));
	
				this.requiredTypes = genericArgument.GetGenericParameterConstraints();
				this.otherConstraints = genericArgument.GenericParameterAttributes;
			}
	
			public bool IsMatching(Type type)
			{
				// check required types
				if (this.requiredTypes != null && this.requiredTypes.Length > 0)
				{
					foreach (var requiredType in this.requiredTypes)
					{
						if (!requiredType.IsAssignableFrom(type))
						{
							return false;
						}
					}
				}
	
				// check other
				if ((this.otherConstraints & GenericParameterAttributes.ReferenceTypeConstraint) != 0 && type.IsValueType)
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0 &&
					(Nullable.GetUnderlyingType(type) != null || !type.IsValueType))
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.DefaultConstructorConstraint) != 0 &&
					type.GetConstructor(BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null) == null)
				{
					return false;
				}
	
				return true;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Constraint, Types: {string.Join(", ", this.requiredTypes.Select(CSharpNameUtils.GetCSharpFullNameWithGenerics))}, Other: {this.otherConstraints}";
			}
		}
	

		public interface IFormulaTypeResolver
		{
			ITypeDescription GetTypeDescription(Type type);
			ITypeDescription GetTypeDescription(FormulaTypeReference typeReference);
	
			bool TryGetTypeDescription(FormulaTypeReference typeReference, out ITypeDescription typeDescription);
		}
	

		private class IndexExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
			private readonly bool useNullPropagation;
	
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
	
			public IndexExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantIndexOnNull();
					}
				}
	
				var indexArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					indexArguments[index.Key] = index.Value.Execute(context);
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetIndexer(indexArguments.Count, out var indexAccessor))
				{
					throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
				}
	
				if (indexAccessor.TryInvoke(target, indexArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				if (this.useNullPropagation)
				{
					stringBuilder.Append("?");
				}
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append("]");
			}
		}
	

		private sealed class Int16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() & arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() | arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() ^ arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt16(), arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() % arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() > arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() >= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() < arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() <= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() == arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() != arguments[1].ToInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Int16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() & arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() | arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() ^ arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt32(), arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() % arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() << arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() >> arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() > arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() >= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() < arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() <= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() == arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() != arguments[1].ToInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int32), isRequired: true),
								new ParameterDescription("value2", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() & arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() | arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() ^ arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<long>((_, arguments) => (double)Math.Pow(arguments[0].ToInt64(), arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() % arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(+arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(~arguments[0].ToInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() & arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() | arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() ^ arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToSByte(), arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() % arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() > arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() >= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() < arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() <= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() == arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() != arguments[1].ToSByte()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToSByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSByte(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(SByte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(SByte), isRequired: true)
					});
			}
		}
	

		private interface INullPropagationExpression
		{
			bool IsNullPropagationEnabled { get; }
		}
	

		private class InvokeExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled => (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
	
			public InvokeExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				string memberName;
				if (!(this.expression is MemberExpression targetMemberExpression))
				{
					// ex. (a + b)(param1, param2)
					return this.ExecutePlainInvoke(context);
				}
				else if (targetMemberExpression.TryGetTypeReferenceAndMemberName(out var typeReference, out memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					// ex. System.Math.Add()
					return this.ExecuteStaticMethod(typeDescriptor, memberName, context);
				}
				if (targetMemberExpression.TryGetExpressionAndMemberName(out var memberExpression, out memberName))
				{
					// ex. my.hello();
					return this.ExecuteInstanceMethod(memberExpression, memberName, context);
				}
				else if (!context.Global.IsNull)
				{
					// ex. hello()
					var globalTypeDescriptor = context.TypeResolver.GetTypeDescription(context.Global.Type);
					if (globalTypeDescriptor.TryGetMember(targetMemberExpression.MemberName, out var memberAccessor))
					{
						return this.ExecuteAnyMethod(context.Global, globalTypeDescriptor, memberAccessor, context);
					}
					else if (globalTypeDescriptor.TryGetStaticMember(targetMemberExpression.MemberName, out memberAccessor))
					{
						return this.ExecuteAnyMethod(VariableValue.Null, globalTypeDescriptor, memberAccessor, context);
					}
				}
	
				return this.ExecutePlainInvoke(context);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
	
			private VariableValue ExecutePlainInvoke(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = this.expression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				return this.InvokeDelegate(new VariableValue(target), targetTypeDescriptor, context);
			}
			private VariableValue ExecuteStaticMethod(ITypeDescription targetTypeDescription, string memberName, FormulaExecutionContext context)
			{
				if (!targetTypeDescription.TryGetStaticMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescription, memberName, targetTypeDescription.StaticMethodNames);
				}
	
				return this.ExecuteAnyMethod(VariableValue.Null, targetTypeDescription, memberAccessor, context);
			}
			private VariableValue ExecuteInstanceMethod(FormulaExpression memberExpression, string memberName, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = memberExpression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescriptor, memberName, targetTypeDescriptor.MethodNames);
				}
	
				return this.ExecuteAnyMethod(target, targetTypeDescriptor, memberAccessor, context);
			}
			private VariableValue ExecuteAnyMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberAccessor, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				if (memberAccessor.GroupType == MemberGroupType.Method)
				{
					return this.InvokeMethod(target, targetTypeDescription, memberAccessor, context, isDelegated: false);
				}
				else
				{
					memberAccessor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null,out var delegateValue);
	
					if (delegateValue.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
						else
						{
							throw FormulaException.CantCallOnNull();
						}
					}
					return this.InvokeDelegate(delegateValue, targetTypeDescription, context);
				}
			}
	
			private VariableValue InvokeDelegate(VariableValue delegateValue, ITypeDescription targetTypeDescription, FormulaExecutionContext context)
			{
				const string DELEGATE_INVOKE_METHOD = "Invoke";
	
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (delegateValue.IsNull) throw new ArgumentNullException(nameof(delegateValue));
	
				var delegateToCall = delegateValue.ToObject() as Delegate;
				if (delegateToCall == null)
				{
					throw FormulaException.UnableToInvokeNonMethodOrDelegate(delegateValue);
				}
	
				var delegateTypeDescriptor = context.TypeResolver.GetTypeDescription(delegateToCall.GetType());
				if (!delegateTypeDescriptor.TryGetMember(DELEGATE_INVOKE_METHOD, out var invokeMethodGroup))
				{
					throw FormulaException.CantFindMember(delegateTypeDescriptor, DELEGATE_INVOKE_METHOD, delegateTypeDescriptor.MethodNames);
				}
	
				return this.InvokeMethod(delegateValue, targetTypeDescription ?? delegateTypeDescriptor, invokeMethodGroup, context, isDelegated: true);
			}
			private VariableValue InvokeMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberGroup, FormulaExecutionContext context, bool isDelegated)
			{
				if (memberGroup == null) throw new ArgumentNullException(nameof(memberGroup));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				var callArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					callArguments[index.Key] = index.Value.Execute(context);
				}
	
				var typeArguments = isDelegated ? Type.EmptyTypes : this.GetTypeArguments(context);
	
				if (memberGroup.TryInvoke(target, callArguments, expectedType: null, typeArguments, out var result))
				{
					return result;
				}
	
				var name = this.expression is MemberExpression targetMemberExpression ? targetMemberExpression.MemberName : "<unknown>";
				throw FormulaException.UnableToBindMethodToParameters(name, targetTypeDescription, callArguments);
			}
	
			private Type[] GetTypeArguments(FormulaExecutionContext context)
			{
				if (this.expression is MemberExpression targetMemberExpression &&
					targetMemberExpression.TypeArguments.Count > 0)
				{
					var resolvedTypeArguments = new Type[targetMemberExpression.TypeArguments.Count];
					for (var index = 0; index < targetMemberExpression.TypeArguments.Count; index++)
					{
						var typeArgument = targetMemberExpression.TypeArguments[index];
						resolvedTypeArguments[index] = context.TypeResolver.GetTypeDescription(typeArgument).Type;
					}
					return resolvedTypeArguments;
				}
	
				return Type.EmptyTypes;
			}
		}
	

		public interface ITypeDescription
		{
			bool CanBeNull { get; }
			Type Type { get; }
			VariableValue DefaultValue { get; }
	
			IReadOnlyCollection<string> PropertyNames  { get; }
			IReadOnlyCollection<string> FieldNames  { get; }
			IReadOnlyCollection<string> MethodNames { get; }
	
			IReadOnlyCollection<string> StaticPropertyNames  { get; }
			IReadOnlyCollection<string> StaticFieldNames  { get; }
			IReadOnlyCollection<string> StaticMethodNames { get; }
	
			bool TryGetConstructors(out MemberGroup constructors);
			bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation);
			bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation);
			bool TryGetMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetIndexer(int rank, out MemberGroup indexAccessor);
			bool TryGetConversionOperation(out MemberGroup convertOperation);
			bool TryGetCheckedConversionOperation(out MemberGroup convertOperation);
		}
	

		public class KnownFormulaTypeResolver : IFormulaTypeResolver
		{
			public static readonly IFormulaTypeResolver Default;
			private static readonly HashSet<Type> BuildInTypes;
	
			private readonly FormulaOptions options;
			private readonly Dictionary<Type, ITypeDescription> typeDescriptions;
			private readonly Dictionary<string, List<Type>> knownTypesByFullName;
			private readonly Dictionary<string, List<Type>> knownTypesByName;
			private readonly HashSet<Type> knownTypes;
			private readonly IFormulaTypeResolver otherTypeResolver;
	
			static KnownFormulaTypeResolver()
			{
				BuildInTypes = new HashSet<Type>
				{
					typeof (object),
					typeof (bool),
					typeof (char),
					typeof (sbyte),
					typeof (byte),
					typeof (short),
					typeof (ushort),
					typeof (int),
					typeof (uint),
					typeof (long),
					typeof (ulong),
					typeof (float),
					typeof (double),
					typeof (decimal),
					typeof (DateTime),
					typeof (TimeSpan),
					typeof (string),
					typeof (Math),
					typeof (Array),
					typeof (Nullable<>),
					typeof (Func<>),
					typeof (Func<,>),
					typeof (Func<,,>),
					typeof (Func<,,,>),
					typeof (Func<,,,,>),
	#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WII || UNITY_IOS || UNITY_IPHONE || UNITY_ANDROID || UNITY_LUMIN || UNITY_TIZEN || UNITY_TVOS || UNITY_WSA || UNITY_WSA_10_0 || UNITY_WEBGL || UNITY_FACEBOOK
					typeof(UnityEngine.Mathf),
					typeof(UnityEngine.Quaternion),
					typeof(UnityEngine.Vector4),
					typeof(UnityEngine.Vector3),
					typeof(UnityEngine.Vector2),
					typeof(UnityEngine.Color),
					typeof(UnityEngine.Color32),
					typeof(UnityEngine.Matrix4x4),
					typeof(UnityEngine.Plane),
	#endif
				};
				Default = new KnownFormulaTypeResolver(Type.EmptyTypes, FormulaOptions.None);
			}
			public KnownFormulaTypeResolver(IEnumerable<Type> knownTypes, FormulaOptions options, IFormulaTypeResolver otherTypeResolver = null)
			{
				this.knownTypesByFullName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
				this.knownTypesByName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
	
				this.otherTypeResolver = otherTypeResolver;
				this.options = options;
				this.typeDescriptions = new Dictionary<Type, ITypeDescription>();
	
				this.knownTypes = new HashSet<Type>(knownTypes ?? Type.EmptyTypes);
				foreach (var buildInType in BuildInTypes)
				{
					this.knownTypes.Add(buildInType);
				}
				foreach (var type in this.knownTypes)
				{
					this.AddKnownType(type);
				}
			}
	
			private void AddKnownType(Type type)
			{
				var typeNames = CSharpNameUtils.GetTypeNames(type);
				if (!string.IsNullOrEmpty(typeNames.Key))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Key, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(typeNames.Value))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Value, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				var fullTypeNames = CSharpNameUtils.GetTypeFullNames(type);
				if (!string.IsNullOrEmpty(fullTypeNames.Key))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Key, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(fullTypeNames.Value))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Value, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
			}
	
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				lock (this.typeDescriptions)
				{
					if (this.typeDescriptions.TryGetValue(type, out var typeDescriptor))
					{
						return typeDescriptor;
					}
	
					this.typeDescriptions[type] = typeDescriptor = this.CreateTypeDescription(type, this.options);
					return typeDescriptor;
				}
			}
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(FormulaTypeReference typeReference)
			{
				if (this.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					return typeDescriptor;
				}
	
				throw FormulaException.UnableToResolveType(typeReference);
			}
			/// <inheritdoc />
			public bool TryGetTypeDescription(FormulaTypeReference typeReference, out ITypeDescription typeDescription)
			{
				if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));
	
				if (this.TryGetType(typeReference, out var type))
				{
					typeDescription = this.GetTypeDescription(type);
					return true;
				}
	
				if (this.otherTypeResolver != null)
				{
					return this.otherTypeResolver.TryGetTypeDescription(typeReference, out typeDescription);
				}
	
				typeDescription = default;
				return false;
			}
	
			private bool TryGetType(FormulaTypeReference typeReference, out Type foundType)
			{
				foundType = default;
	
				var matches = 0;
				var genericTypeRequired = typeReference.TypeArguments.Count > 0;
	
				// search in full names
				if (this.knownTypesByFullName.TryGetValue(typeReference.FullName, out var typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type)  // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// search in short names
				if (this.knownTypesByName.TryGetValue(typeReference.FullName, out typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type) // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// special case for System.Array because it's not generic but TypeReference for Arrays are
				if (foundType == null && (string.Equals(typeReference.FullName, FormulaConstants.KNOWN_TYPE_SYSTEM_ARRAY, StringComparison.Ordinal) ||
						string.Equals(typeReference.Name, FormulaConstants.KNOWN_TYPE_ARRAY, StringComparison.Ordinal)))
				{
					foundType = typeof(Array);
					matches = 1;
				}
	
				if (matches != 1)
				{
					foundType = null;
					return false;
				}
	
				if (foundType == typeof(Array) &&
					this.TryMakeArrayType(typeReference, ref foundType))
				{
					return true;
				}
				else if (foundType != null && typeReference.TypeArguments.Count > 0 &&
						this.TryMakeGenericType(typeReference, ref foundType))
				{
					return true;
				}
				return foundType != null;
			}
	
			private bool TryMakeGenericType(FormulaTypeReference typeReference, ref Type foundType)
			{
				var genericParameters = default(Type[]);
				var foundTypeInfo = foundType.GetTypeInfo();
				if (foundTypeInfo.IsGenericType &&
					(genericParameters = foundTypeInfo.GetGenericArguments()).Length == typeReference.TypeArguments.Count)
				{
					var typeArguments = new Type[genericParameters.Length];
					var allArgumentBound = true;
					var isOpenType = true;
					for (var i = 0; i < typeArguments.Length; i++)
					{
						var genericArgumentTypeReference = typeReference.TypeArguments[i];
						if (genericArgumentTypeReference.IsEmpty)
						{
							typeArguments[i] = genericParameters[i];
						}
						else if (this.TryGetType(genericArgumentTypeReference, out typeArguments[i]))
						{
							isOpenType = false;
						}
						else
						{
							allArgumentBound = false;
						}
					}
	
					if (!foundTypeInfo.IsGenericTypeDefinition)
					{
						foundType = foundType.GetGenericTypeDefinition() ?? foundType;
					}
	
					if (allArgumentBound)
					{
						foundType = isOpenType ? foundType : foundType.MakeGenericType(typeArguments);
						return true;
					}
				}
	
				foundType = null;
				return false;
			}
			private bool TryMakeArrayType(FormulaTypeReference typeReference, ref Type foundType)
			{
				if (typeReference.TypeArguments.Count == 1)
				{
					if (this.TryGetType(typeReference.TypeArguments[0], out var elementType) == false)
					{
						return false;
					}
	
					foundType = elementType.MakeArrayType();
					return true;
				}
				else if (typeReference.TypeArguments.Count == 0)
				{
					return true;
				}
				foundType = null;
				return true;
			}
	
			protected virtual ITypeDescription CreateTypeDescription(Type type, FormulaOptions options)
			{
				if (type.IsArray)
				{
					return new ArrayTypeDescription(type, options);
				}
				else if (type.IsEnum)
				{
					return new EnumTypeDescription(type, options);
				}
				else if (type == typeof(char))
				{
					return new CharTypeDescription(type, options);
				}
				else if (type == typeof(byte))
				{
					return new UInt8TypeDescription(type, options);
				}
				else if (type == typeof(sbyte))
				{
					return new Int8TypeDescription(type, options);
				}
				else if (type == typeof(short))
				{
					return new Int16TypeDescription(type, options);
				}
				else if (type == typeof(ushort))
				{
					return new UInt16TypeDescription(type, options);
				}
				else if (type == typeof(int))
				{
					return new Int32TypeDescription(type, options);
				}
				else if (type == typeof(uint))
				{
					return new UInt32TypeDescription(type, options);
				}
				else if (type == typeof(long))
				{
					return new Int64TypeDescription(type, options);
				}
				else if (type == typeof(ulong))
				{
					return new UInt64TypeDescription(type, options);
				}
				else if (type == typeof(float))
				{
					return new Float32TypeDescription(type, options);
				}
				else if (type == typeof(double))
				{
					return new Float64TypeDescription(type, options);
				}
				else if (type == typeof(bool))
				{
					return new BooleanTypeDescription(type, options);
				}
				else if (type == typeof(object))
				{
					return new ObjectTypeDescription(type, options);
				}
				else if (type == typeof(string))
				{
					return new StringTypeDescription(type, options);
				}
				else if ((typeof(Type).IsAssignableFrom(type) || type.Namespace == typeof(MemberInfo).Namespace) &&
						(options & FormulaOptions.AllowReflectionApi) == 0)
				{
					return new RestrictedReflectionTypeDescription(type, options);
				}
				return new ReflectionTypeDescription(type, options);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"KnownTypeResolver, Type Count: {this.knownTypes.Count}";
			}
		}
	

		private class LambdaExpression : FormulaExpression
		{
			private readonly FormulaExpression body;
			private readonly KeyValuePair<string, FormulaTypeReference>[] arguments;
	
			public LambdaExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.body = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
	
				var arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.arguments = new KeyValuePair<string, FormulaTypeReference>[arguments.Count];
				var argumentIndex = 0;
				foreach (var argumentByIndex in arguments)
				{
					if (argumentByIndex.Value is MemberExpression argumentMember)
					{
						this.arguments[argumentIndex++] = new KeyValuePair<string, FormulaTypeReference>(argumentMember.MemberName, null);
						continue;
					}
					throw FormulaException.InvalidLambdaArgument(argumentByIndex.Value);
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var parameters = Array.Empty<KeyValuePair<string, Type>>();
				if (this.arguments.Length > 0)
				{
					parameters = new KeyValuePair<string, Type>[this.arguments.Length];
					for (var index = 0; index < this.arguments.Length; index++)
					{
						var argument = this.arguments[index];
						var parameterType = argument.Value == null ? null : context.TypeResolver.GetTypeDescription(argument.Value).Type;
						parameters[index] = new KeyValuePair<string, Type>(argument.Key, parameterType);
					}
				}
				return new VariableValue(new UnboundLambda(this.body, parameters, context));
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (argument.Value != null)
					{
						stringBuilder.Append(argument.Value);
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(argument.Key);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Length > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append(") => ");
				this.body.BuildDebugView(stringBuilder);
			}
		}
	

		private sealed class LambdaFunctions
		{
			public static Func<ResultT> Func<ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, ResultT> Func<Arg1T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, ResultT> Func<Arg1T, Arg2T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, ResultT> Func<Arg1T, Arg2T, Arg3T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT> Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
	
			public static Action Action(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T> Action<Arg1T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T> Action<Arg1T, Arg2T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T> Action<Arg1T, Arg2T, Arg3T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T, Arg4T> Action<Arg1T, Arg2T, Arg3T, Arg4T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
	
			private static Dictionary<string, VariableValue> CopyArguments(KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				var arguments = new Dictionary<string, VariableValue>(context.Arguments.Count + parameters.Length);
				foreach (var contextArgument in context.Arguments)
				{
					arguments[contextArgument.Key] = contextArgument.Value;
				}
	
				return arguments;
			}
		}
	

		public sealed class MemberDescription
		{
			private static readonly ParameterDescription[] EmptyParameters = Array.Empty<ParameterDescription>();
			private static readonly GenericConstraint[] EmptyTypeParameters = Array.Empty<GenericConstraint>();
	
			private readonly Func<VariableValue, VariableValue[], VariableValue> invokeFunc;
			private readonly Lazy<Func<VariableValue, VariableValue[], VariableValue>> lazyInvokeFunc;
			private readonly MemberInfo originalMember;
			private readonly FormulaOptions options;
			private readonly Dictionary<TypeTuple, MemberDescription> methodInstantiations; // null for non-MethodInfo members
	
			public IReadOnlyList<GenericConstraint> TypeParameters { get; }
			public IReadOnlyList<ParameterDescription> Parameters { get; }
			public Type ResultType { get; }
			public int RequiredParameterCount { get; }
	
			public MemberDescription
			(
				Func<VariableValue, VariableValue[], VariableValue> invokeFunc,
				Type resultType,
				IReadOnlyList<ParameterDescription> parameters
			)
			{
				if (invokeFunc == null) throw new ArgumentNullException(nameof(invokeFunc));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (parameters.Count > 64) throw new ArgumentOutOfRangeException(nameof(parameters));
	
	
				this.invokeFunc = invokeFunc;
				this.ResultType = resultType;
				this.Parameters = parameters;
				this.RequiredParameterCount = parameters.Count(parameter => parameter.IsRequired);
				this.TypeParameters = EmptyTypeParameters;
			}
			public MemberDescription(MethodBase methodBase, FormulaOptions options)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (methodBase.DeclaringType == null) throw new ArgumentException("Method should have declaring type.", nameof(methodBase));
	
				this.originalMember = methodBase;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.TypeParameters = EmptyTypeParameters;
	
				var parameters = methodBase.GetParameters();
				if (parameters.Length > 0)
				{
					var parameterDescriptors = new ParameterDescription[parameters.Length];
					for (var parameterIndex = 0; parameterIndex < parameters.Length; parameterIndex++)
					{
						var parameter = parameters[parameterIndex];
						var defaultValue = VariableValue.Null;
						if (parameter.IsOptional)
						{
							if (parameter.HasDefaultValue)
							{
								defaultValue = new VariableValue(parameter.DefaultValue);
							}
							else if (parameter.ParameterType.IsValueType)
							{
								defaultValue = new VariableValue(Activator.CreateInstance(parameter.ParameterType));
							}
							else
							{
								defaultValue = VariableValue.Null;
							}
						}
						parameterDescriptors[parameterIndex] = new ParameterDescription(parameter.Name, parameter.ParameterType, !parameter.IsOptional, defaultValue);
					}
					this.Parameters = parameterDescriptors;
				}
	
				this.ResultType = methodBase is ConstructorInfo constructorInfo ? constructorInfo.DeclaringType : ((MethodInfo)methodBase).ReturnType;
				this.RequiredParameterCount = this.Parameters.Count(parameter => parameter.IsRequired);
	
				if (methodBase is MethodInfo methodInfo && methodInfo.IsGenericMethod && methodInfo.IsGenericMethodDefinition)
				{
					var genericArguments = methodInfo.GetGenericArguments();
					var genericConstraints = new GenericConstraint[genericArguments.Length];
					for (var index = 0; index < genericArguments.Length; index++)
					{
						var genericArgument = genericArguments[index];
						genericConstraints[index] = new GenericConstraint(genericArgument);
					}
	
					this.methodInstantiations = new Dictionary<TypeTuple, MemberDescription>();
					this.TypeParameters = genericConstraints;
					this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters); // will throw exception on invoke
				}
				else
				{
					if ((options & FormulaOptions.UseDynamicMethods) != 0)
					{
						this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionMethodInvoke(methodBase, parameters), LazyThreadSafetyMode.ExecutionAndPublication);
					}
					else
					{
						this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters);
					}
				}
	
			}
			public MemberDescription(FieldInfo fieldInfo, FormulaOptions options)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
				if (fieldInfo.DeclaringType == null) throw new ArgumentException("Field should have declaring type.", nameof(fieldInfo));
	
				this.originalMember = fieldInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionFieldGet(fieldInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionFieldGet(fieldInfo);
				}
			}
			public MemberDescription(PropertyInfo propertyInfo, FormulaOptions options)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
				if (propertyInfo.DeclaringType == null) throw new ArgumentException("Property should have declaring type.", nameof(propertyInfo));
	
				this.originalMember = propertyInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionPropertyGet(propertyInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionPropertyGet(propertyInfo);
				}
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = fieldInfo.IsStatic || target.IsNull ? null : target.ToType(fieldInfo.DeclaringType);
						var result = fieldInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Field(
							VariableValue.FromVariableValueExpression(target, fieldInfo.DeclaringType),
							fieldInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(fieldInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = (propertyInfo.GetMethod?.IsStatic).GetValueOrDefault() || target.IsNull ? null : target.ToType(propertyInfo.DeclaringType);
						var result = propertyInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Property(
							VariableValue.FromVariableValueExpression(target, propertyInfo.DeclaringType),
							propertyInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(propertyInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isStatic = methodBase is MethodInfo methodInfo && methodInfo.IsStatic;
				return (target, arguments) =>
				{
					try
					{
						var argumentList = new object[arguments.Length];
						for (var i = 0; i < arguments.Length; i++)
						{
							argumentList[i] = arguments[i].ToType(parameters[i].ParameterType);
						}
	
						if (methodBase is ConstructorInfo constructorInfo)
						{
							var result = constructorInfo.Invoke(argumentList);
							return new VariableValue(result);
						}
						else
						{
							var targetObj = isStatic || target.IsNull ? null : target.ToType(methodBase.DeclaringType);
							var result = methodBase.Invoke(targetObj, argumentList);
							return new VariableValue(result);
						}
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue[]), "arguments");
	
				var argumentExpressions = new Expression[parameters.Length];
				for (var argumentIndex = 0; argumentIndex < argumentExpressions.Length; argumentIndex++)
				{
					argumentExpressions[argumentIndex] = VariableValue.FromVariableValueExpression(
						Expression.ArrayIndex(arguments, Expression.Constant(argumentIndex)),
						parameters[argumentIndex].ParameterType
					);
				}
	
				if (methodBase is ConstructorInfo constructorInfo)
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.New(
								constructorInfo,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + constructorInfo.Name + "WithVariableValuesCall"
					).Compile();
				}
				else
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.Call(
								VariableValue.FromVariableValueExpression(target, parameters[0].ParameterType),
								(MethodInfo)methodBase,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + GetMemberName(methodBase) + "WithVariableValuesCall"
					).Compile();
				}
			}
	
			private static string GetMemberName(MemberInfo member)
			{
				if (member == null) throw new ArgumentNullException(nameof(member));
	
				return (member.DeclaringType?.FullName + "." + member.Name).Replace(".", "_");
			}
	
			public VariableValue Invoke(VariableValue target, VariableValue[] arguments)
			{
				if (this.invokeFunc != null)
				{
					return this.invokeFunc(target, arguments);
				}
				else
				{
					return this.lazyInvokeFunc.Value(target, arguments);
				}
			}
	
			public MemberDescription MakeGenericMethod(Type[] typeArguments)
			{
				if (typeArguments == null) throw new ArgumentNullException(nameof(typeArguments));
				if (!(this.originalMember is MethodInfo info)) throw new InvalidOperationException($"Can't instantiate not method '{this.originalMember}'.");
				if (this.TypeParameters.Count <= 0) throw new InvalidOperationException($"Can't instantiate non-generic method '{this.originalMember}'.");
	
				var key = new TypeTuple(typeArguments);
				var instantiatedMethodDescription = default(MemberDescription);
				lock (this.methodInstantiations)
				{
					if (this.methodInstantiations.TryGetValue(key, out instantiatedMethodDescription))
						return instantiatedMethodDescription;
	
					var instantiatedMethod = info.MakeGenericMethod(typeArguments);
					instantiatedMethodDescription = new MemberDescription(instantiatedMethod, this.options);
					this.methodInstantiations[key] = instantiatedMethodDescription;
				}
				return instantiatedMethodDescription;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var memberRef = this.originalMember != null ? GetMemberName(this.originalMember) : this.invokeFunc.Method.ToString();
				var parameters = string.Join(", ", this.Parameters.Select(p => p.ParameterType.Name));
	
				return $"({parameters}) -> {this.ResultType.Name}, Member: {memberRef}";
			}
	
		}
	

		private class MemberExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly bool useNullPropagation;
			private readonly FormulaExpression expression;
			private FormulaTypeReference skipSelfTypeReference;
			private FormulaTypeReference typeReference;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
			public string RawMemberName { get; }
			public string MemberName { get; }
			public IReadOnlyList<FormulaTypeReference> TypeArguments { get; }
	
			public MemberExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.RawMemberName = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE, optional: true) ??
					ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.NAME_ATTRIBUTE, optional: false);
				this.MemberName = this.RawMemberName.Length > 0 && this.RawMemberName[0] == '@' ? this.RawMemberName.Substring(1) : this.RawMemberName;
	
				this.TypeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (this.TryGetTypeReferenceAndMemberName(out var typeReference, out var memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor) &&
					typeDescriptor.TryGetStaticMember(memberName, out var memberAccessor))
				{
					memberAccessor.TryInvoke(VariableValue.Null, callArguments: null, expectedType: null, typeArguments: null, out var result);
					return result;
				}
				else if (this.expression != null)
				{
					var target = this.expression.Execute(context);
					if (target.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
	
						throw FormulaException.CantAccessMemberOnNull(this.MemberName);
					}
	
					var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
					if (this.TryGetMemberValue(targetTypeDescriptor, target, out var memberValue))
					{
						return memberValue;
					}
					throw FormulaException.CantFindMember(targetTypeDescriptor, this.MemberName, targetTypeDescriptor.FieldNames.Concat(targetTypeDescriptor.PropertyNames).ToList());
				}
				else if (this.RawMemberName == FormulaConstants.NOTATION_TRUE_STRING)
				{
					return true;
				}
				else if (this.RawMemberName == FormulaConstants.NOTATION_FALSE_STRING)
				{
					return false;
				}
				else if (this.RawMemberName == FormulaConstants.NOTATION_NULL_STRING)
				{
					return VariableValue.Null;
				}
				else if (context.Arguments.TryGetValue(this.MemberName, out var argumentValue) ||
						context.Arguments.TryGetValue(this.RawMemberName, out argumentValue))
				{
					return argumentValue;
				}
				else if (this.TryGetGlobalMemberValue(out var globalMemberValue, context))
				{
					return globalMemberValue;
				}
				else
				{
					var availableNames = GetAvailableParameterAndGlobalMemberNames(context);
					throw FormulaException.UnableToResolveGlobalName(this.MemberName, availableNames);
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expression != null)
				{
					this.expression.BuildDebugView(stringBuilder);
					if (this.useNullPropagation)
					{
						stringBuilder.Append("?");
					}
					stringBuilder.Append(".");
				}
				stringBuilder.Append(this.MemberName);
				if (this.TypeArguments != null && this.TypeArguments.Count > 0)
				{
					stringBuilder.Append("<");
					foreach (var typeArgument in this.TypeArguments)
					{
						stringBuilder.Append(typeArgument);
						stringBuilder.Append(", ");
					}
					stringBuilder.Length -= 2;
					stringBuilder.Append(">");
				}
			}
	
			public bool TryGetExpressionAndMemberName(out FormulaExpression expression, out string memberName)
			{
				if (this.expression != null)
				{
					memberName = this.MemberName;
					expression = this.expression;
					return true;
				}
				else
				{
					expression = null;
					memberName = null;
					return false;
				}
			}
	
			public bool TryGetTypeReferenceAndMemberName(out FormulaTypeReference typeReference, out string memberName)
			{
				if (this.TryGetTypeReference(out typeReference, skipSelf: true))
				{
					memberName = this.MemberName;
					return true;
				}
	
				memberName = null;
				return false;
			}
			private bool TryGetTypeReference(out FormulaTypeReference typeReference, bool skipSelf = false)
			{
				if (skipSelf && this.skipSelfTypeReference != null)
				{
					typeReference = this.skipSelfTypeReference;
					return true;
				}
				else if (!skipSelf && this.typeReference != null)
				{
					typeReference = this.typeReference;
					return true;
				}
	
				if (this.useNullPropagation)
				{
					typeReference = null;
					return false; // null propagation ?. is not type reference
				}
	
				var baseTypeReference = default(FormulaTypeReference);
				if (this.expression != null && !(this.expression is MemberExpression))
				{
					typeReference = null;
					return false; // base expression is not member expression
				}
	
				if (this.expression != null && ((MemberExpression)this.expression).TryGetTypeReference(out baseTypeReference, skipSelf: false) == false)
				{
					typeReference = null;
					return false; // base expression is not a type reference
				}
	
				if (skipSelf)
				{
					this.skipSelfTypeReference = typeReference = baseTypeReference;
				}
				else
				{
					this.typeReference = typeReference = new FormulaTypeReference(this.MemberName, this.TypeArguments, baseTypeReference);
				}
				return typeReference != null;
			}
	
			private bool TryGetGlobalMemberValue(out VariableValue globalMemberValue, FormulaExecutionContext context)
			{
				if (context.Global.IsNull)
				{
					globalMemberValue = default;
					return false;
				}
				var globalType = context.TypeResolver.GetTypeDescription(context.Global.Type);
				return this.TryGetMemberValue(globalType, context.Global, out globalMemberValue);
			}
			private bool TryGetMemberValue(ITypeDescription targetTypeDescription, VariableValue target, out VariableValue memberValue)
			{
				if (targetTypeDescription == null) throw new ArgumentNullException(nameof(targetTypeDescription));
	
				if (!targetTypeDescription.TryGetMember(this.MemberName, out var memberDescriptor))
				{
					memberValue = default;
					return false;
				}
	
				if (memberDescriptor.GroupType == MemberGroupType.Method ||
					memberDescriptor.GroupType == MemberGroupType.Constructor)
				{
					throw FormulaException.CanAccessMethodOrConstructorGroup(this.MemberName, targetTypeDescription);
				}
	
				// TODO wrap errors for better message
				return memberDescriptor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null, out memberValue);
			}
			private static HashSet<string> GetAvailableParameterAndGlobalMemberNames(FormulaExecutionContext context)
			{
				var availableNames = new HashSet<string>(context.Arguments.Keys, StringComparer.Ordinal);
				var globalType = context.Global.IsNull ? null : context.TypeResolver.GetTypeDescription(context.Global.Type);
				if (globalType != null)
				{
					foreach (var globalMemberName in globalType.PropertyNames)
					{
						availableNames.Add(globalMemberName);
					}
					foreach (var globalMemberName in globalType.FieldNames)
					{
						availableNames.Add(globalMemberName);
					}
				}
	
				return availableNames;
			}
		}
	

		public sealed class MemberGroup
		{
			private enum ParameterMatchQuality { None, Coerced, Cast, Exact }
			private static readonly Dictionary<string, VariableValue> EmptyArguments = new Dictionary<string, VariableValue>();
	
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
	
			private readonly IReadOnlyList<MemberDescription> members;
	
			public MemberGroupType GroupType { get; }
	
			public MemberGroup(MemberGroupType groupType, IReadOnlyList<MemberDescription> members)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				this.members = members;
				this.GroupType = groupType;
			}
	
			public bool TryInvoke(VariableValue target, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out VariableValue result)
			{
				callArguments = callArguments ?? EmptyArguments;
				typeArguments = typeArguments ?? Type.EmptyTypes;
	
				var bestMatchMethod = MatchMember(this.members, callArguments, expectedType, typeArguments, out var argumentOrder);
				if (bestMatchMethod == null || !TryPrepareArguments(bestMatchMethod, callArguments, argumentOrder, out var arguments))
				{
					result = default;
					return false;
				}
	
				result = bestMatchMethod.Invoke(target, arguments);
				return true;
			}
	
			private static MemberDescription MatchMember(IReadOnlyList<MemberDescription> members, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out string[] argumentOrder)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
				if (callArguments == null) throw new ArgumentNullException(nameof(callArguments));
	
				argumentOrder = PositionNumbers;
	
				var bestMatchMethod = default(MemberDescription);
				var bestMatchParametersQuality = ParameterMatchQuality.Coerced;
				var bestMatchResultQuality = ParameterMatchQuality.Coerced;
	
				for (var index = 0; index < members.Count; index++)
				{
					var method = members[index];
					if (method.RequiredParameterCount > callArguments.Count)
					{
						continue;
					}
	
					if (method.TypeParameters.Count != typeArguments.Length ||
						!AreMatching(method.TypeParameters, typeArguments))
					{
						continue;
					}
	
					if (method.TypeParameters.Count > 0)
					{
						method = method.MakeGenericMethod(typeArguments);
					}
	
					if (!TryBindParameters(method, callArguments, out var argumentsOrder, out var parametersQuality))
					{
						continue;
					}
	
					var resultQuality = ParameterMatchQuality.Exact;
					if (expectedType != null && !TryMatchResultType(method.ResultType, expectedType, out resultQuality))
					{
						continue;
					}
	
					if (resultQuality < bestMatchResultQuality || parametersQuality < bestMatchParametersQuality)
					{
						continue;
					}
	
					bestMatchMethod = method;
					argumentOrder = argumentsOrder;
					bestMatchParametersQuality = parametersQuality;
					bestMatchResultQuality = resultQuality;
				}
	
				return bestMatchMethod;
			}
	
			private static bool TryBindParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] argumentOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				if (parameterCount == 0 && callArguments.Count == 0)
				{
					argumentOrder = PositionNumbers;
					quality = ParameterMatchQuality.Exact;
					return true;
				}
	
				for (var parameterIndex = 0; parameterIndex < callArguments.Count; parameterIndex++)
				{
					var parameterName = GetIndexAsString(parameterIndex);
					if (!callArguments.ContainsKey(parameterName))
					{
						return TryBindMixedParameters(member, callArguments, out argumentOrder, out quality);
					}
				}
				return TryBindPositionalParameters(member, callArguments, out argumentOrder, out quality);
			}
			private static bool TryBindPositionalParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
	
				parameterOrder = PositionNumbers;
				quality = ParameterMatchQuality.Exact;
	
				// bind positional parameters
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					var parameterName = GetIndexAsString(parameterIndex);
	
					if (!callArguments.TryGetValue(parameterName, out var parameterValue) &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						quality = ParameterMatchQuality.None;
						return false; // unable to find parameter
					}
	
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryBindMixedParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				var boundArguments = 0UL;
				var parameterValue = default(VariableValue);
	
				parameterOrder = new string[parameterCount];
				quality = ParameterMatchQuality.Exact;
	
				// bind named arguments
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterName = parameter.Name;
					if (callArguments.TryGetValue(parameterName, out parameterValue))
					{
						boundArguments |= 1UL << parameterIndex;
						parameterOrder[parameterIndex] = parameterName;
					}
					else
					{
						continue;
					}
	
					var parameterType = parameter.ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				// bind positional parameters
				var lastPositionIndex = 0;
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
	
					if ((boundArguments & 1UL << parameterIndex) != 0)
					{
						continue; // already bound
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0) // try to bind by position
					{
						while (lastPositionIndex < parameterCount)
						{
							var parameterName = GetIndexAsString(lastPositionIndex++);
							if (callArguments.TryGetValue(parameterName, out parameterValue))
							{
								boundArguments |= 1UL << parameterIndex;
								parameterOrder[parameterIndex] = parameterName;
								break;
							}
						}
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0 &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						return false; // required and not bound by position and not bound by name
					}
	
	
					var parameterType = member.Parameters[parameterIndex].ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryPrepareArguments(MemberDescription member, Dictionary<string, VariableValue> callArguments, string[] parameterOrder, out VariableValue[] arguments)
			{
				var parameterCount = member.Parameters.Count;
				arguments = new VariableValue[parameterCount];
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameterName = parameterIndex < parameterOrder.Length ? parameterOrder[parameterIndex] : string.Empty;
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					if (!(callArguments.TryGetValue(parameterName, out var parameterValue) || TryGetDefaultValue(parameter, ref parameterValue)) ||
							!TryCastValue(parameterValue, parameterType) &&
							!TryCoercePrimitive(ref parameterValue, parameterType) &&
							!TryBindLambda(ref parameterValue, parameterType))
					{
						return false;
					}
	
					arguments[parameterIndex] = parameterValue;
				}
	
				return true;
			}
			private static bool TryGetDefaultValue(ParameterDescription parameter, ref VariableValue parameterValue)
			{
				if (parameter.IsRequired)
				{
					return false;
				}
	
				parameterValue = parameter.DefaultValue;
				return true;
			}
	
			private static bool TryBindLambda(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.Type != typeof(UnboundLambda) ||
					!typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return false;
				}
	
				var unboundLambdaExpression = (UnboundLambda)parameterValue.ToObject();
				parameterValue = new VariableValue(unboundLambdaExpression.BindTo(parameterType));
				return true;
			}
			private static bool TryCoercePrimitive(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.IsNull)
				{
					return false;
				}
	
				var expectedTypeCode = TypeCodes.GetTypeCode(parameterType);
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (!parameterValue.CanFitInto(expectedTypeCode))
				{
					return false;
				}
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (expectedTypeCode)
				{
					case TypeCode.Boolean: parameterValue = parameterValue.ToBoolean(); return true;
					case TypeCode.Char: parameterValue = parameterValue.ToChar(); return true;
					case TypeCode.SByte: parameterValue = parameterValue.ToSByte(); return true;
					case TypeCode.Byte: parameterValue = parameterValue.ToByte(); return true;
					case TypeCode.Int16: parameterValue = parameterValue.ToInt16(); return true;
					case TypeCode.UInt16: parameterValue = parameterValue.ToUInt16(); return true;
					case TypeCode.Int32: parameterValue = parameterValue.ToInt32(); return true;
					case TypeCode.UInt32: parameterValue = parameterValue.ToUInt32(); return true;
					case TypeCode.Int64: parameterValue = parameterValue.ToInt64(); return true;
					case TypeCode.UInt64: parameterValue = parameterValue.ToUInt64(); return true;
					case TypeCode.Single: parameterValue = parameterValue.ToSingle(); return true;
					case TypeCode.Double: parameterValue = parameterValue.ToDouble(); return true;
					case TypeCode.Decimal: parameterValue = parameterValue.ToDecimal(); return true;
					default: return false;
				}
			}
			private static bool TryCastValue(VariableValue parameterValue, Type parameterType)
			{
				if (parameterType == typeof(object))
				{
					return true;
				}
				if (parameterValue.IsNull && (!parameterType.IsValueType || IsNullableType(parameterType)))
				{
					return true;
				}
	
				if (parameterValue.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return ((UnboundLambda)parameterValue.ToObject()).IsSignatureMatching(parameterType);
				}
	
				return parameterType.IsAssignableFrom(parameterValue.Type);
			}
			private static bool TryMatchResultType(Type resultType, Type expectedResultType, out ParameterMatchQuality quality)
			{
				if (resultType == expectedResultType)
				{
					quality = ParameterMatchQuality.Exact;
					return true;
				}
				else if (expectedResultType.IsAssignableFrom(resultType))
				{
					quality = ParameterMatchQuality.Cast;
					return true;
				}
	
				var resultTypeCode = TypeCodes.GetTypeCode(resultType);
				var expectedResultTypeCode = TypeCodes.GetTypeCode(expectedResultType);
				if (TypeCodes.CanCoerceNumberLike(expectedResultTypeCode, resultTypeCode))
				{
					quality = ParameterMatchQuality.Coerced;
					return true;
				}
	
				quality = default;
				return false;
			}
			private static bool IsNullableType(Type parameterType)
			{
				return Nullable.GetUnderlyingType(parameterType) != null;
			}
			private static bool AreMatching(IReadOnlyList<GenericConstraint> typeParameters, Type[] typeArguments)
			{
				if (typeParameters == null) throw new ArgumentNullException(nameof(typeParameters));
				if (typeParameters.Count != typeArguments.Length) throw new ArgumentOutOfRangeException(nameof(typeArguments));
	
				for (var index = 0; index < typeParameters.Count; index++)
				{
					if (typeParameters[index].IsMatching(typeArguments[index]) == false)
					{
						return false;
					}
				}
	
				return true;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
	
			private static ParameterMatchQuality MinQuality(ParameterMatchQuality value1, ParameterMatchQuality value2)
			{
				return value1 < value2 ? value1 : value2;
			}
			/// <inheritdoc />
			public override string ToString()
			{
				return "MemberGroup, Members: " + string.Join("\r\n\t", this.members.Select(member => member.ToString()).ToArray());
			}
		}
	

		public enum MemberGroupType
		{
			Field,
			Property,
			Constructor,
			Method
		}
	

		private class NewArrayBoundExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaTypeReference type;
	
			public NewArrayBoundExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				var arrayTypeDescription = context.TypeResolver.GetTypeDescription(typeDescription.Type.MakeArrayType(this.arguments.Count));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (arrayTypeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append(this.type);
				stringBuilder.Length -= 2;
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append("]");
			}
		}
	

		private class NewExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaTypeReference type;
	
			public NewExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
	
				if (this.arguments.Count == 1 &&
					this.arguments.Values.First() is LambdaExpression lambdaExpression &&
					typeof(Delegate).IsAssignableFrom(typeDescription.Type))
				{
					return this.ExecuteLambdaConstructor(context, typeDescription, lambdaExpression);
				}
				else
				{
					return this.ExecuteConstructor(context, typeDescription);
				}
			}
	
			private VariableValue ExecuteLambdaConstructor(FormulaExecutionContext context, ITypeDescription typeDescription, LambdaExpression lambdaExpression)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
				if (lambdaExpression == null) throw new ArgumentNullException(nameof(lambdaExpression));
	
				var unboundLambdaValue = lambdaExpression.Execute(context);
				var unboundLambda = (UnboundLambda)unboundLambdaValue.ToObject();
				var boundLambda = unboundLambda.BindTo(typeDescription.Type);
				return new VariableValue(boundLambda);
			}
	
			private VariableValue ExecuteConstructor(FormulaExecutionContext context, ITypeDescription typeDescription)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (typeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("new ").Append(this.type).Append("(");
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
		}
	

		private sealed class ObjectTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
	
			static ObjectTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() == arguments[1].ToObject()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() != arguments[1].ToObject()));
			}
			/// <inheritdoc />
			public ObjectTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Object), isRequired: true),
								new ParameterDescription("value2", typeof(Object), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		public sealed class ParameterDescription
		{
			public Type ParameterType { get; }
			public string Name { get; }
			public bool IsRequired { get; }
			public VariableValue DefaultValue { get; }
	
			public ParameterDescription(string name, Type parameterType, bool isRequired, VariableValue defaultValue = default)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
				if (parameterType == null) throw new ArgumentNullException(nameof(parameterType));
				if (string.IsNullOrEmpty(name)) throw new ArgumentException("Value cannot be null or empty.", nameof(name));
	
				this.ParameterType = parameterType;
				this.IsRequired = isRequired;
				this.DefaultValue = defaultValue;
				this.Name = name;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Parameter, Name: {this.Name}, Type: {this.ParameterType}, Required: {this.IsRequired}, Default Value: {this.DefaultValue}";
			}
		}
	

		private class ReflectionTypeDescription : ITypeDescription
		{
			private readonly Lazy<MemberGroup> lazyConstructors;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllMembers;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllStaticMembers;
			private readonly Lazy<Dictionary<bool, Lazy<MemberGroup>>> lazyConvertMethods;
	
			/// <inheritdoc />
			public bool CanBeNull { get; }
			/// <inheritdoc />
			public Type Type { get; }
			/// <inheritdoc />
			public VariableValue DefaultValue { get; }
			/// <inheritdoc />
			public IReadOnlyCollection<string> PropertyNames => this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Property, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
			/// <inheritdoc />
			public IReadOnlyCollection<string> FieldNames => this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Field, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
			/// <inheritdoc />
			public IReadOnlyCollection<string> MethodNames => this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
			/// <inheritdoc />
			public IReadOnlyCollection<string> StaticPropertyNames => this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Property, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
			/// <inheritdoc />
			public IReadOnlyCollection<string> StaticFieldNames => this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Field, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
			/// <inheritdoc />
			public IReadOnlyCollection<string> StaticMethodNames => this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var names) ? names.Keys : (IReadOnlyCollection<string>)Array.Empty<string>();
	
			public ReflectionTypeDescription(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				this.CanBeNull = !type.IsValueType || Nullable.GetUnderlyingType(type) != null;
				this.Type = type;
				this.DefaultValue = type.IsValueType ? new VariableValue(Activator.CreateInstance(type)) : VariableValue.Null;
	
				this.lazyAllMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Instance | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyAllStaticMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Static | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConstructors = new Lazy<MemberGroup>(
					() => GetConstructors(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConvertMethods = new Lazy<Dictionary<bool, Lazy<MemberGroup>>>(
					() => GetConvertMethods(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
			}
	
			/// <inheritdoc />
			public virtual bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.lazyConstructors.Value;
				return constructors != null;
			}
			/// <inheritdoc />
			public virtual bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case BinaryOperationType.And: methodName = "op_BitwiseAnd"; break;
					case BinaryOperationType.Or: methodName = "op_BitwiseOr"; break;
					case BinaryOperationType.ExclusiveOr: methodName = "op_ExclusiveOr"; break;
					case BinaryOperationType.Multiply: methodName = "op_Multiply"; break;
					case BinaryOperationType.MultiplyChecked: methodName = "op_CheckedMultiply"; break;
					case BinaryOperationType.Divide: methodName = "op_Division"; break;
					case BinaryOperationType.DivideChecked: methodName = "op_CheckedDivision"; break;
					case BinaryOperationType.Power: methodName = ""; break;
					case BinaryOperationType.Modulo: methodName = "op_Modulus"; break;
					case BinaryOperationType.Add: methodName = "op_Addition"; break;
					case BinaryOperationType.AddChecked: methodName = "op_CheckedAddition"; break;
					case BinaryOperationType.Subtract: methodName = "op_Subtraction"; break;
					case BinaryOperationType.SubtractChecked: methodName = "op_CheckedSubtraction"; break;
					case BinaryOperationType.LeftShift: methodName = "op_Multiply"; break;
					case BinaryOperationType.RightShift: methodName = "op_RightShift"; break;
					case BinaryOperationType.GreaterThan: methodName = "op_GreaterThan"; break;
					case BinaryOperationType.GreaterThanOrEqual: methodName = "op_GreaterThanOrEqual"; break;
					case BinaryOperationType.LessThan: methodName = "op_LessThan"; break;
					case BinaryOperationType.LessThanOrEqual: methodName = "op_LessThanOrEqual"; break;
					case BinaryOperationType.Equal: methodName = "op_Equality"; break;
					case BinaryOperationType.NotEqual: methodName = "op_Inequality"; break;
					case BinaryOperationType.AndAlso: methodName = ""; break;
					case BinaryOperationType.OrElse: methodName = ""; break;
					case BinaryOperationType.Coalesce: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					binaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case UnaryOperationType.UnaryPlus: methodName = "op_UnaryPlus"; break;
					case UnaryOperationType.Negate: methodName = "op_UnaryNegation"; break;
					case UnaryOperationType.NegateChecked: methodName = "op_CheckedUnaryNegation"; break;
					case UnaryOperationType.Not: methodName = "op_LogicalNot"; break;
					case UnaryOperationType.Complement: methodName = "op_OnesComplement"; break;
					case UnaryOperationType.UncheckedScope: methodName = ""; break;
					case UnaryOperationType.CheckedScope: methodName = ""; break;
					case UnaryOperationType.Group: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					unaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				unaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				var methodName = "get_Item";
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					indexAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ false, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ true, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == null) throw new ArgumentNullException(nameof(memberName));
	
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
	
			private static Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>> GetAllMembers(Type type, BindingFlags bindingFlags, FormulaOptions options)
			{
				return type
					.GetMembers(bindingFlags)
					.Where(memberInfo => !HasByRefLikeAttribute(memberInfo) && HasGetter(memberInfo))
					.ToLookup(MapToGroupType)
					.Where(group => group.Key != null)
					.ToDictionary(
						group => group.Key.GetValueOrDefault(),
						group => group
							.ToLookup(member => member.Name)
							.ToDictionary(
								members => members.Key,
								members => new Lazy<MemberGroup>(() => GroupMembers(members.ToList(), options), LazyThreadSafetyMode.ExecutionAndPublication)));
			}
	
			private static MemberGroup GroupMembers(List<MemberInfo> members, FormulaOptions options)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				var memberDescriptors = new List<MemberDescription>(members.Count);
				var groupType = default(MemberGroupType?);
				foreach (var memberInfo in members)
				{
					groupType = MapToGroupType(memberInfo);
					if (memberInfo is ConstructorInfo constructorInfo)
					{
						memberDescriptors.Add(new MemberDescription(constructorInfo, options));
					}
					else if (memberInfo is MethodBase methodBase)
					{
						memberDescriptors.Add(new MemberDescription(methodBase, options));
					}
					else if (memberInfo is PropertyInfo propertyInfo)
					{
						memberDescriptors.Add(new MemberDescription(propertyInfo, options));
					}
					else if (memberInfo is FieldInfo fieldInfo)
					{
						memberDescriptors.Add(new MemberDescription(fieldInfo, options));
					}
				}
				if (groupType == null)
				{
					throw new InvalidOperationException("Member group doesn't contains any members.");
				}
				return new MemberGroup(groupType.Value, memberDescriptors);
			}
			private static MemberGroup GetConstructors(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public)
					.Where(constructorInfo => !HasByRefLikeAttribute(constructorInfo))
					.Select(member => (MemberInfo)member)
					.ToList();
				if (constructors.Count == 0)
				{
					return null;
				}
				return GroupMembers(constructors, options);
			}
			private static Dictionary<bool, Lazy<MemberGroup>> GetConvertMethods(Type type, FormulaOptions options)
			{
				var allMethods = type
					.GetMethods(BindingFlags.Public | BindingFlags.Static)
					.Where(methodInfo => !HasByRefLikeAttribute(methodInfo));
	
				var checkedConvertMethods = new List<MemberInfo>(10);
				var uncheckedConvertMethods = new List<MemberInfo>(10);
	
				foreach (var method in allMethods)
				{
					if (method.Name == "op_CheckedImplicit" || method.Name == "op_CheckedExplicit")
					{
						checkedConvertMethods.Add(method);
					}
					else if (method.Name == "op_Implicit" || method.Name == "op_Explicit")
					{
						checkedConvertMethods.Add(method);
						uncheckedConvertMethods.Add(method);
					}
				}
	
				var convertOperations = new Dictionary<bool, Lazy<MemberGroup>>();
				if (checkedConvertMethods.Count > 0)
				{
					convertOperations[true] = new Lazy<MemberGroup>(() => GroupMembers(checkedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				if (uncheckedConvertMethods.Count > 0)
				{
					convertOperations[false] = new Lazy<MemberGroup>(() => GroupMembers(uncheckedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				return convertOperations;
			}
	
			private static MemberGroupType? MapToGroupType(MemberInfo memberInfo)
			{
				if (memberInfo is ConstructorInfo)
				{
					return MemberGroupType.Constructor;
				}
				else if (memberInfo is MethodBase)
				{
					return MemberGroupType.Method;
				}
				else if (memberInfo is PropertyInfo)
				{
					return MemberGroupType.Property;
				}
				else if (memberInfo is FieldInfo)
				{
					return MemberGroupType.Field;
				}
				else
				{
					return null;
				}
			}
	
			private static bool HasByRefLikeAttribute(MethodBase methodBase)
			{
				if (methodBase is MethodInfo methodInfo)
				{
					return HasByRefLikeAttribute(methodInfo.ReturnParameter?.ParameterType) ||
						methodInfo.GetParameters().Any(HasByRefLikeAttribute);
				}
				else
				{
					return methodBase.GetParameters().Any(HasByRefLikeAttribute);
				}
			}
			private static bool HasByRefLikeAttribute(ParameterInfo parameterInfo)
			{
				if (parameterInfo.Member.Name == "ToString" && parameterInfo.Position == -1 /* return value */)
				{
					return false; // fix for https://github.com/mono/mono/issues/17192
				}
				return HasByRefLikeAttribute(parameterInfo.ParameterType);
			}
			private static bool HasByRefLikeAttribute(Type type)
			{
				if (type == null) return false;
				return type.GetTypeInfo().GetCustomAttributes(inherit: true).Any(attribute => IsByRefLikeAttributeType(attribute.GetType()));
			}
			private static bool HasByRefLikeAttribute(MemberInfo memberInfo)
			{
				if (memberInfo is MethodBase methodBase)
				{
					return HasByRefLikeAttribute(methodBase);
				}
				else if (memberInfo is PropertyInfo propertyInfo)
				{
					return HasByRefLikeAttribute(propertyInfo.PropertyType);
				}
				else if (memberInfo is FieldInfo fieldInfo)
				{
					return HasByRefLikeAttribute(fieldInfo.FieldType);
				}
				return false;
			}
			private static bool IsByRefLikeAttributeType(Type attributeType)
			{
				return string.Equals(attributeType.Namespace, "System.Runtime.CompilerServices", StringComparison.Ordinal) &&
					string.Equals(attributeType.Name, "IsByRefLikeAttribute", StringComparison.Ordinal);
			}
			private static bool HasGetter(MemberInfo memberInfo)
			{
				return !(memberInfo is PropertyInfo propertyInfo) || propertyInfo.GetMethod != null;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(this.Type);
			}
		}
	

		private sealed class RestrictedReflectionTypeDescription : ReflectionTypeDescription
		{
			public RestrictedReflectionTypeDescription(Type type, FormulaOptions options)
				: base(type, options)
			{
	
			}
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				if (operationType == BinaryOperationType.Equal || operationType == BinaryOperationType.NotEqual)
				{
					return base.TryGetBinaryOperation(operationType, out binaryOperation);
				}
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == nameof(this.Type.Name) ||
					memberName == nameof(this.Type.Namespace) ||
					memberName == nameof(this.Type.FullName))
				{
					return base.TryGetMember(memberName, out memberAccessor);
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
		}
	

		private sealed class StringTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup IndexAccessor;
	
			static StringTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull == arguments[1].IsNull && string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull != arguments[1].IsNull || !string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
	
				IndexAccessor = new MemberGroup(MemberGroupType.Method, new[] {
					new MemberDescription(
						invokeFunc: (stringValue, indexes) => ((string)stringValue.ToObject())[indexes[0].ToInt32()],
						resultType: typeof(char),
						new []{ new ParameterDescription("index", typeof(int), isRequired: true, defaultValue: VariableValue.Null) }
					)
				});
			}
			/// <inheritdoc />
			public StringTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = IndexAccessor;
				return true;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(String), isRequired: true),
								new ParameterDescription("value2", typeof(String), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class TypeCodes
		{
			public const TypeCode TIME_SPAN_CODE = (TypeCode)20;
	
			public static TypeCode GetTypeCode(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type == typeof(TimeSpan))
				{
					return TIME_SPAN_CODE;
				}
				else if (type.IsEnum)
				{
					// there is a b_u_g in some Mono implementation then GetTypeCode(enumType) gives TypeCode.Object instead of type code of underlying type
					return Type.GetTypeCode(Enum.GetUnderlyingType(type));
				}
				else
				{
					return Type.GetTypeCode(type);
				}
			}
	
			public static bool CanCoerceNumberLike(TypeCode toTypeCode, TypeCode fromTypeCode)
			{
				const int DOUBLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Double;
				const int DECIMAL_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Decimal;
				const int SINGLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double;
				const int BYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Byte | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int CHAR_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Char | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int SBYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.SByte | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
	
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (fromTypeCode)
				{
					case TypeCode.Char: return (CHAR_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.SByte: return (SBYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Byte: return (BYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int16: return (INT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt16: return (UINT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int32: return (INT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt32: return (UINT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int64: return (INT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt64: return (UINT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Single: return (SINGLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Double: return (DOUBLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Decimal: return (DECIMAL_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					default: return false;
				}
			}
	
			public static bool IsInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte ||
					typeCode == TypeCode.SByte ||
					typeCode == TypeCode.Int16 ||
					typeCode == TypeCode.UInt16 ||
					typeCode == TypeCode.Int32 ||
					typeCode == TypeCode.UInt32 ||
					typeCode == TypeCode.Int64 ||
					typeCode == TypeCode.UInt64;
			}
			public static bool IsNumberLike(TypeCode typeCode)
			{
				return IsFloat(typeCode) || IsInteger(typeCode) || typeCode == TypeCode.Decimal || typeCode == TypeCode.Char;
			}
			public static bool IsFloat(TypeCode typeCode)
			{
				return typeCode == TypeCode.Single || typeCode == TypeCode.Double;
			}
			public static bool IsSignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.SByte || typeCode == TypeCode.Int16 || typeCode == TypeCode.Int32 || typeCode == TypeCode.Int64;
			}
			public static bool IsUnsignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte || typeCode == TypeCode.UInt16 || typeCode == TypeCode.UInt32 || typeCode == TypeCode.UInt64;
			}
			public static TypeCode MakeUnsigned(TypeCode typeCode)
			{
				switch (typeCode)
				{
					case TypeCode.UInt64: return TypeCode.UInt64;
					case TypeCode.UInt32: return TypeCode.UInt32;
					case TypeCode.UInt16: return TypeCode.UInt16;
					case TypeCode.Int64: return TypeCode.UInt64;
					case TypeCode.Int32: return TypeCode.UInt32;
					case TypeCode.Int16: return TypeCode.UInt16;
					case TypeCode.Byte: return TypeCode.Byte;
					case TypeCode.SByte: return TypeCode.Byte;
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.DateTime:
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Double:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.Single:
					case TypeCode.String:
					default: throw new ArgumentOutOfRangeException(nameof(typeCode), typeCode, null);
				}
			}
		}
	

		private sealed class TypeIsExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
			private readonly FormulaExpression expression;
	
			public TypeIsExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return typeDescription.Type.IsAssignableFrom(target.Type);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append(" is ").Append(this.type);
			}
		}
	

		private sealed class TypeOfExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
	
			public TypeOfExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return new VariableValue(typeDescription.Type);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("typeof(").Append(this.type).Append(")");
			}
		}
	

		private readonly struct TypeTuple : IEquatable<TypeTuple>
		{
			private readonly int hashCode;
	
			public readonly Type[] Types;
	
			public TypeTuple(params Type[] types)
			{
				if (types == null) throw new ArgumentNullException(nameof(types));
	
				this.Types = types;
	
				unchecked
				{
					this.hashCode = 17;
					foreach (var type in types)
					{
						if (type == null) throw new ArgumentException("One of array's element is null.", nameof(types));
	
						this.hashCode = this.hashCode * 23 + type.GetHashCode();
					}
				}
			}
	
			public bool Equals(TypeTuple other)
			{
				if (this.Types == other.Types) return true;
				if (this.Types == null || other.Types == null) return false;
				if (this.Types.Length != other.Types.Length) return false;
	
				for (var i = 0; i < this.Types.Length; i++)
					if (this.Types[i] != other.Types[i])
						return false;
				return true;
			}
			public override int GetHashCode()
			{
				return this.hashCode;
			}
			public override bool Equals(object obj)
			{
				if (obj is TypeTuple tuple)
				{
					return this.Equals(tuple);
				}
				return false;
			}
	
			public override string ToString()
			{
				if (this.Types != null)
				{
					var sb = new System.Text.StringBuilder();
					foreach (var type in this.Types)
						sb.Append(type.Name).Append(", ");
					if (sb.Length > 2)
						sb.Length -= 2;
					return sb.ToString();
				}
				else
					return "empty";
			}
		}
	

		private sealed class UInt16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() & arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() | arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() ^ arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt16(), arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() % arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() > arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() >= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() < arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() <= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() == arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() != arguments[1].ToUInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToUInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(UInt16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() & arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() | arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() ^ arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<uint>((_, arguments) => (int)checked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<uint>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt32(), arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() % arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() > arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() >= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() < arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() <= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() == arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() != arguments[1].ToUInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(+arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(~arguments[0].ToUInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt32), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() & arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() | arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() ^ arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<ulong>((_, arguments) => (int)checked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<ulong>((_, arguments) => (uint)checked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<ulong>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt64(), arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() % arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() > arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() >= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() < arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() <= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() == arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() != arguments[1].ToUInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<ulong>((_, arguments) => (ulong)unchecked(+arguments[0].ToUInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (ulong)unchecked(~arguments[0].ToUInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() & arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() | arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() ^ arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToByte(), arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() % arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() > arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() >= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() < arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() <= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() == arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() != arguments[1].ToByte()));
				// ReSharper enable RedundantOverflowCheckingContext
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToByte(uncheckedConversion: true))),
				});
			}
			/// <inheritdoc />
			public UInt8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Byte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Byte), isRequired: true)
					});
			}
		}
	

		private class UnaryExpression : FormulaExpression
		{
			private readonly FormulaExpression expression;
			private readonly UnaryOperationType unaryOperationType;
			private readonly UnaryOperationType fallbackUnaryOperationType;
	
			public UnaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.unaryOperationType = MapUnaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.NegateChecked: this.fallbackUnaryOperationType = UnaryOperationType.Negate; break;
					default: this.fallbackUnaryOperationType = this.unaryOperationType; break;
				}
			}
	
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var operand = this.expression.Execute(context);
				if (operand.IsNull)
				{
					return VariableValue.Null;
				}
	
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.Group:
					case UnaryOperationType.UncheckedScope:
					case UnaryOperationType.CheckedScope: return operand;
					case UnaryOperationType.UnaryPlus:
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked:
					case UnaryOperationType.Not:
					case UnaryOperationType.Complement: break;
					default: throw FormulaException.UnknownUnaryExpression(this.unaryOperationType.ToString());
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", operand }
				};
	
				var leftValueType = context.TypeResolver.GetTypeDescription(operand.Type);
				if (leftValueType.TryGetUnaryOperation(this.unaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackUnaryOperationType != this.unaryOperationType && // try fallback unary operation
						leftValueType.TryGetUnaryOperation(this.fallbackUnaryOperationType, out binaryOperation) &&
						binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingUnaryOperation(this.unaryOperationType, operand);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				var enclose = !(this.expression is ConstantExpression);
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.UnaryPlus: stringBuilder.Append("+"); break;
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked: stringBuilder.Append("-"); break;
					case UnaryOperationType.Not: stringBuilder.Append("!"); break;
					case UnaryOperationType.Complement: stringBuilder.Append("~"); break;
					case UnaryOperationType.UncheckedScope:
						enclose = true;
						stringBuilder.Append("unchecked");
						break;
					case UnaryOperationType.CheckedScope:
						enclose = true;
						stringBuilder.Append("checked");
						break;
					case UnaryOperationType.Group:
						enclose = true;
						break;
					default: stringBuilder.Append(this.unaryOperationType); break;
				}
				if (enclose)
				{
					stringBuilder.Append("(");
				}
				this.expression.BuildDebugView(stringBuilder);
				if (enclose)
				{
					stringBuilder.Append(")");
				}
			}
	
			private static UnaryOperationType MapUnaryOperationType(string expressionType)
			{
				UnaryOperationType unaryOperationType;
				switch (expressionType)
				{
					case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE: unaryOperationType = UnaryOperationType.UncheckedScope; break;
					case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE: unaryOperationType = UnaryOperationType.CheckedScope; break;
					case FormulaConstants.EXPRESSION_TYPE_GROUP: unaryOperationType = UnaryOperationType.Group; break;
					case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: unaryOperationType = UnaryOperationType.UnaryPlus; break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE: unaryOperationType = UnaryOperationType.Negate; break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED: unaryOperationType = UnaryOperationType.NegateChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_NOT: unaryOperationType = UnaryOperationType.Not; break;
					case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: unaryOperationType = UnaryOperationType.Complement; break;
					default: throw FormulaException.UnknownUnaryExpression(expressionType);
				}
				return unaryOperationType;
			}
		}
	

		public enum UnaryOperationType
		{
			UnaryPlus,
			Negate,
			NegateChecked,
			Not,
			Complement,
			UncheckedScope,
			CheckedScope,
			Group,
		}
	

		private sealed class UnboundLambda
		{
			private readonly KeyValuePair<string, Type>[] parameters;
			private readonly FormulaExpression body;
			private readonly FormulaExecutionContext context;
	
			public UnboundLambda(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				this.parameters = parameters;
				this.body = body;
				this.context = context;
			}
	
			public bool IsSignatureMatching(Type delegateType)
			{
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null)
				{
					return false;
				}
				var parameters = invokeMethod.GetParameters();
				if (parameters.Length != this.parameters.Length)
				{
					return false;
				}
	
				for (var index = 0; index < parameters.Length; index++)
				{
					var parameter = parameters[index];
					var argument = this.parameters[index];
					if (argument.Value == null)
					{
						continue;
					}
	
					if (!parameter.ParameterType.IsAssignableFrom(argument.Value))
					{
						return false;
					}
				}
	
				return true;
			}
	
			public Delegate BindTo(Type delegateType)
			{
				if (delegateType == null) throw new ArgumentNullException(nameof(delegateType));
	
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{delegateType}' delegate type.");
	
				var isVoidResult = invokeMethod.ReturnType == typeof(void);
				var parameters = invokeMethod.GetParameters();
				var signature = GetFuncSignature(invokeMethod, parameters);
	
				var boundLambdaFuncType = isVoidResult ? Expression.GetActionType(signature) : Expression.GetFuncType(signature);
	
				var boundLambdaFuncInvokeMethod = boundLambdaFuncType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (boundLambdaFuncInvokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{boundLambdaFuncType}' delegate type.");
	
				var prepareMethodDefinition = typeof(LambdaFunctions)
					.GetMethods(BindingFlags.Static | BindingFlags.Public)
					.FirstOrDefault(m =>
						m.Name == (isVoidResult ? nameof(LambdaFunctions.Action) : nameof(LambdaFunctions.Func)) &&
						m.GetGenericArguments().Length == signature.Length);
	
				if (prepareMethodDefinition == null) throw new ArgumentException($"Missing '{nameof(LambdaFunctions.Action)}' or '{nameof(LambdaFunctions.Func)}' on '{typeof(LambdaFunctions)}' type with {signature.Length} generic arguments.");
				var prepareMethod = prepareMethodDefinition.MakeGenericMethod(signature);
				var boundLambdaFunc = prepareMethod.Invoke(null, new object[] { this.body, this.parameters, this.context });
	
				return Delegate.CreateDelegate(delegateType, boundLambdaFunc, boundLambdaFuncInvokeMethod, throwOnBindFailure: true);
			}
	
			private static Type[] GetFuncSignature(MethodInfo methodInfo, ParameterInfo[] parameters)
			{
				if (methodInfo == null) throw new ArgumentNullException(nameof(methodInfo));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isVoidResult = methodInfo.ReturnType == typeof(void);
				var signature = new Type[parameters.Length + (isVoidResult ? 0 : 1)];
				for (var i = 0; i < parameters.Length; i++)
				{
					signature[i] = parameters[i].ParameterType;
				}
	
				if (!isVoidResult)
				{
					signature[signature.Length - 1] = methodInfo.ReturnType;
				}
	
				return signature;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var parameters = string.Join(", ", this.parameters.Select(p => p.Key));
				return $"({parameters}) -> any";
	
			}
		}
	

		public readonly struct VariableValue
		{
			private class TypeCodeRef
			{
				public static readonly TypeCodeRef Boolean = new TypeCodeRef(TypeCode.Boolean, typeof(bool));
				public static readonly TypeCodeRef Char = new TypeCodeRef(TypeCode.Char, typeof(char));
				public static readonly TypeCodeRef SByte = new TypeCodeRef(TypeCode.SByte, typeof(sbyte));
				public static readonly TypeCodeRef Byte = new TypeCodeRef(TypeCode.Byte, typeof(byte));
				public static readonly TypeCodeRef Int16 = new TypeCodeRef(TypeCode.Int16, typeof(short));
				public static readonly TypeCodeRef UInt16 = new TypeCodeRef(TypeCode.UInt16, typeof(ushort));
				public static readonly TypeCodeRef Int32 = new TypeCodeRef(TypeCode.Int32, typeof(int));
				public static readonly TypeCodeRef UInt32 = new TypeCodeRef(TypeCode.UInt32, typeof(uint));
				public static readonly TypeCodeRef Int64 = new TypeCodeRef(TypeCode.Int64, typeof(long));
				public static readonly TypeCodeRef UInt64 = new TypeCodeRef(TypeCode.UInt64, typeof(ulong));
				public static readonly TypeCodeRef Single = new TypeCodeRef(TypeCode.Single, typeof(float));
				public static readonly TypeCodeRef Double = new TypeCodeRef(TypeCode.Double, typeof(double));
				public static readonly TypeCodeRef DateTime = new TypeCodeRef(TypeCode.DateTime, typeof(DateTime));
				public static readonly TypeCodeRef TimeSpan = new TypeCodeRef(TypeCodes.TIME_SPAN_CODE, typeof(TimeSpan));
	
				private static readonly Dictionary<Type, TypeCodeRef> EnumTypeCodes = new Dictionary<Type, TypeCodeRef>();
	
				public readonly TypeCode TypeCode;
				public readonly Type Type;
	
				private TypeCodeRef(TypeCode typeCode, Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					this.TypeCode = typeCode;
					this.Type = type;
				}
	
				public static TypeCodeRef GetOrCreateEnumTypeCodeRef(Type enumType)
				{
					lock (EnumTypeCodes)
					{
						if (EnumTypeCodes.TryGetValue(enumType, out var enumTypeCodeRef))
						{
							return enumTypeCodeRef;
						}
	
						EnumTypeCodes[enumType] = enumTypeCodeRef = new TypeCodeRef(TypeCodes.GetTypeCode(enumType), enumType);
						return enumTypeCodeRef;
					}
				}
			}
	
			public static readonly VariableValue Null = new VariableValue(null);
	
			private readonly long binaryValue;
			private readonly object refValue;
	
			public bool IsNull => this.binaryValue == 0 && this.refValue == null;
			public Type Type => this.GetValueType();
			public TypeCode TypeCode => this.GetValueTypeCode();
	
			private VariableValue(TypeCodeRef typeCodeRef, long binaryValue)
			{
				this.refValue = typeCodeRef;
				this.binaryValue = binaryValue;
			}
			public VariableValue(object value)
			{
				if (value is VariableValue variableValue)
				{
					this.binaryValue = variableValue.binaryValue;
					this.refValue = variableValue.refValue;
					return;
				}
				else if (value == null)
				{
					this.binaryValue = default;
					this.refValue = null;
					return;
				}
	
				var valueType = value.GetType();
				var valueTypeCode = TypeCodes.GetTypeCode(valueType);
				if (valueType.IsEnum)
				{
					this.refValue = TypeCodeRef.GetOrCreateEnumTypeCodeRef(valueType);
					if (Enum.GetUnderlyingType(valueType) == typeof(ulong))
					{
						this.binaryValue = unchecked((long)Convert.ToUInt64(value, CultureInfo.InvariantCulture));
					}
					else
					{
						this.binaryValue = Convert.ToInt64(value, CultureInfo.InvariantCulture);
					}
					return;
				}
	
				switch (valueTypeCode)
				{
					case TypeCode.Boolean:
						this.binaryValue = (bool)value ? 1 : 0;
						this.refValue = TypeCodeRef.Boolean;
						break;
					case TypeCode.Byte:
						this.binaryValue = (byte)value;
						this.refValue = TypeCodeRef.Byte;
						break;
					case TypeCode.SByte:
						this.binaryValue = (sbyte)value;
						this.refValue = TypeCodeRef.SByte;
						break;
					case TypeCode.Char:
						this.binaryValue = (char)value;
						this.refValue = TypeCodeRef.Char;
						break;
					case TypeCode.Double:
						this.binaryValue = BitConverter.DoubleToInt64Bits((double)value);
						this.refValue = TypeCodeRef.Double;
						break;
					case TypeCode.Int16:
						this.binaryValue = (short)value;
						this.refValue = TypeCodeRef.Int16;
						break;
					case TypeCode.Int32:
						this.binaryValue = (int)value;
						this.refValue = TypeCodeRef.Int32;
						break;
					case TypeCode.Int64:
						this.binaryValue = (long)value;
						this.refValue = TypeCodeRef.Int64;
						break;
					case TypeCode.Single:
						this.binaryValue = BitConverter.DoubleToInt64Bits((float)value);
						this.refValue = TypeCodeRef.Single;
						break;
					case TypeCode.UInt16:
						this.binaryValue = (ushort)value;
						this.refValue = TypeCodeRef.UInt16;
						break;
					case TypeCode.UInt32:
						this.binaryValue = (uint)value;
						this.refValue = TypeCodeRef.UInt32;
						break;
					case TypeCode.UInt64:
						this.binaryValue = unchecked((long)(ulong)value);
						this.refValue = TypeCodeRef.UInt64;
						break;
					case TypeCodes.TIME_SPAN_CODE:
						this.binaryValue = ((TimeSpan)value).Ticks;
						this.refValue = TypeCodeRef.TimeSpan;
						break;
					case TypeCode.DateTime:
						this.binaryValue = ((DateTime)value).ToBinary();
						this.refValue = TypeCodeRef.DateTime;
						break;
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.String:
					default:
						this.binaryValue = 0;
						this.refValue = value;
						break;
				}
			}
			public VariableValue(char value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Char;
			}
			public VariableValue(bool value)
			{
				this.binaryValue = value ? 1 : 0;
				this.refValue = TypeCodeRef.Boolean;
			}
			public VariableValue(byte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Byte;
			}
			public VariableValue(sbyte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.SByte;
			}
			public VariableValue(short value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int16;
			}
			public VariableValue(ushort value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt16;
			}
			public VariableValue(int value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int32;
			}
			public VariableValue(uint value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt32;
			}
			public VariableValue(long value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int64;
			}
			public VariableValue(ulong value)
			{
				this.binaryValue = unchecked((long)value);
				this.refValue = TypeCodeRef.UInt64;
			}
			public VariableValue(float value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Single;
			}
			public VariableValue(double value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Double;
			}
			public VariableValue(DateTime value)
			{
				this.binaryValue = value.ToBinary();
				this.refValue = TypeCodeRef.DateTime;
			}
			public VariableValue(TimeSpan value)
			{
				this.binaryValue = value.Ticks;
				this.refValue = TypeCodeRef.TimeSpan;
			}
	
			private Type GetValueType()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.Type;
				}
				else
				{
					return this.refValue?.GetType() ?? typeof(object);
				}
			}
			private TypeCode GetValueTypeCode()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.TypeCode;
				}
				else
				{
					return TypeCodes.GetTypeCode(this.refValue?.GetType() ?? typeof(object));
				}
			}
			public object ToObject()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					var valueTypeCode = typeCodeRef.TypeCode;
					var result = default(object);
					switch (valueTypeCode)
					{
						case TypeCode.Boolean: result = this.binaryValue > 0; break;
						case TypeCode.Char: result = unchecked((char)this.binaryValue); break;
						case TypeCode.SByte: result = unchecked((sbyte)this.binaryValue); break;
						case TypeCode.Byte: result = unchecked((byte)this.binaryValue); break;
						case TypeCode.Int16: result = unchecked((short)this.binaryValue); break;
						case TypeCode.UInt16: result = unchecked((ushort)this.binaryValue); break;
						case TypeCode.Int32: result = unchecked((int)this.binaryValue); break;
						case TypeCode.UInt32: result = unchecked((uint)this.binaryValue); break;
						case TypeCode.Int64: result = this.binaryValue; break;
						case TypeCode.UInt64: result = unchecked((ulong)this.binaryValue); break;
						case TypeCode.Single: result = (float)BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.Double: result = BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.DateTime: result = DateTime.FromBinary(this.binaryValue); break;
						case TypeCodes.TIME_SPAN_CODE: result = TimeSpan.FromTicks(this.binaryValue); break;
						case TypeCode.String:
						case TypeCode.Empty:
						case TypeCode.Object:
						case TypeCode.Decimal:
						case TypeCode.DBNull:
						default: throw new ArgumentOutOfRangeException($"Unexpected type of TypeCodeRef '{valueTypeCode}' while one of blittable types are expected.");
					}
					if (typeCodeRef.Type.IsEnum)
					{
						result = Enum.ToObject(typeCodeRef.Type, result);
					}
					return result;
				}
				else
				{
					return this.refValue;
				}
			}
			public object ToType(Type toType)
			{
				if (toType == null) throw new ArgumentNullException(nameof(toType));
	
				var isNullable = toType.IsGenericType && Nullable.GetUnderlyingType(toType) != toType;
				if (isNullable && this.IsNull)
				{
					return null;
				}
	
				if (toType == typeof(object))
				{
					return this.ToObject();
				}
				else if (toType == typeof(string))
				{
					return this.ToString();
				}
				else if (toType == typeof(char))
				{
					return this.ToChar();
				}
				else if (toType == typeof(bool))
				{
					return this.ToBoolean();
				}
				else if (toType == typeof(byte))
				{
					return this.ToByte();
				}
				else if (toType == typeof(sbyte))
				{
					return this.ToSByte();
				}
				else if (toType == typeof(short))
				{
					return this.ToInt16();
				}
				else if (toType == typeof(ushort))
				{
					return this.ToUInt16();
				}
				else if (toType == typeof(int))
				{
					return this.ToInt32();
				}
				else if (toType == typeof(uint))
				{
					return this.ToUInt32();
				}
				else if (toType == typeof(long))
				{
					return this.ToInt64();
				}
				else if (toType == typeof(ulong))
				{
					return this.ToUInt64();
				}
				else if (toType == typeof(float))
				{
					return this.ToSingle();
				}
				else if (toType == typeof(double))
				{
					return this.ToDouble();
				}
				else if (toType == typeof(DateTime))
				{
					return this.ToDateTime();
				}
				else if (toType == typeof(TimeSpan))
				{
					return this.ToTimeSpan();
				}
				else if (toType == typeof(decimal))
				{
					return this.ToDecimal();
				}
				else if (toType.IsEnum)
				{
					var underlyingType = Enum.GetUnderlyingType(toType);
					return Enum.ToObject(toType, this.ToType(underlyingType));
				}
				else
				{
					var value = this.ToObject();
					if (toType.IsInstanceOfType(value))
					{
						return value;
					}
					else
					{
						throw new InvalidCastException($"Unable to cast value of type '{value?.GetType().FullName ?? "<null>"}' to type '{toType.FullName}'.");
					}
				}
			}
			public bool CanFitInto(TypeCode targetTypeCode)
			{
				var currentTypeCode = this.TypeCode;
				if (currentTypeCode == targetTypeCode)
				{
					return true;
				}
	
				// try compact integer type
				if (TypeCodes.IsInteger(currentTypeCode))
				{
					// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
					switch (currentTypeCode)
					{
						case TypeCode.UInt64:
							currentTypeCode = TypeCode.UInt64;
							var uint64Value = unchecked((ulong)this.binaryValue);
							if (uint64Value <= long.MaxValue)
							{
								goto case TypeCode.Int64;
							}
							break;
						case TypeCode.Int64:
							currentTypeCode = TypeCode.Int64;
							if (this.binaryValue >= int.MinValue && this.binaryValue <= int.MaxValue) goto case TypeCode.Int32;
							else if (this.binaryValue >= uint.MinValue && this.binaryValue <= uint.MaxValue) goto case TypeCode.UInt32;
							break;
						case TypeCode.UInt32:
							currentTypeCode = TypeCode.UInt32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int32:
							currentTypeCode = TypeCode.Int32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int16:
							currentTypeCode = TypeCode.Int16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.UInt16:
							currentTypeCode = TypeCode.UInt16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.SByte:
							currentTypeCode = TypeCode.SByte;
							break;
						case TypeCode.Byte:
							currentTypeCode = TypeCode.Byte;
							break;
					}
				}
	
	
				if (TypeCodes.CanCoerceNumberLike(targetTypeCode, currentTypeCode))
				{
					return true;
				}
	
				if (TypeCodes.IsUnsignedInteger(targetTypeCode) &&
					TypeCodes.IsSignedInteger(currentTypeCode) && this.binaryValue >= 0 &&
					TypeCodes.CanCoerceNumberLike(targetTypeCode, TypeCodes.MakeUnsigned(currentTypeCode)))
				{
					return true;
				}
	
				if (targetTypeCode == TypeCode.Byte && currentTypeCode == TypeCode.SByte)
				{
					return this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue;
				}
				else if (targetTypeCode == TypeCode.SByte && currentTypeCode == TypeCode.Byte)
				{
					return this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue;
				}
	
				else if (targetTypeCode == TypeCode.Int64 && currentTypeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue) <= long.MaxValue;
				}
				return false;
			}
	
			public long ToInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64 && uncheckedConversion == false)
				{
					var uint64Value = unchecked((ulong)this.binaryValue);
					return checked((long)uint64Value);
				}
				else if (TypeCodes.IsInteger(typeCode))
				{
					return this.binaryValue;
				}
				else
				{
					return Convert.ToInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ulong ToUInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue);
				}
				else if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ulong)this.binaryValue) : checked((ulong)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public int ToInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((int)this.binaryValue) : checked((int)this.binaryValue);
				}
				else
				{
					return Convert.ToInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public uint ToUInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((uint)this.binaryValue) : checked((uint)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public short ToInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((short)this.binaryValue) : checked((short)this.binaryValue);
				}
				else
				{
					return Convert.ToInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ushort ToUInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ushort)this.binaryValue) : checked((ushort)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public sbyte ToSByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((sbyte)this.binaryValue) : checked((sbyte)this.binaryValue);
				}
				else
				{
					return Convert.ToSByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public byte ToByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((byte)this.binaryValue) : checked((byte)this.binaryValue);
				}
				else
				{
					return Convert.ToByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public char ToChar(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((char)this.binaryValue) : checked((char)this.binaryValue);
				}
				else
				{
					return Convert.ToChar(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public double ToDouble()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (double)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDouble(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public float ToSingle()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (float)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (float)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToSingle(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public decimal ToDecimal()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (decimal)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (decimal)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDecimal(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public DateTime ToDateTime()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.DateTime)
				{
					return DateTime.FromBinary(this.binaryValue);
				}
				else
				{
					return Convert.ToDateTime(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public TimeSpan ToTimeSpan()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCodes.TIME_SPAN_CODE)
				{
					return TimeSpan.FromTicks(this.binaryValue);
				}
				else
				{
					return ToTimeSpan(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public bool ToBoolean()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.Boolean)
				{
					return this.binaryValue > 0;
				}
				else
				{
					return Convert.ToBoolean(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public T To<T>()
			{
				if (typeof(T) == typeof(long)) return (T)(object)this.ToInt64();
				else if (typeof(T) == typeof(ulong)) return (T)(object)this.ToUInt64();
				else if (typeof(T) == typeof(int)) return (T)(object)this.ToInt32();
				else if (typeof(T) == typeof(uint)) return (T)(object)this.ToUInt32();
				else if (typeof(T) == typeof(short)) return (T)(object)this.ToInt16();
				else if (typeof(T) == typeof(ushort)) return (T)(object)this.ToUInt16();
				else if (typeof(T) == typeof(sbyte)) return (T)(object)this.ToSByte();
				else if (typeof(T) == typeof(byte)) return (T)(object)this.ToByte();
				else if (typeof(T) == typeof(char)) return (T)(object)this.ToChar();
				else if (typeof(T) == typeof(double)) return (T)(object)this.ToDouble();
				else if (typeof(T) == typeof(float)) return (T)(object)this.ToSingle();
				else if (typeof(T) == typeof(decimal)) return (T)(object)this.ToDecimal();
				else if (typeof(T) == typeof(DateTime)) return (T)(object)this.ToDateTime();
				else if (typeof(T) == typeof(TimeSpan)) return (T)(object)this.ToTimeSpan();
				else if (typeof(T) == typeof(bool)) return (T)(object)this.ToBoolean();
				else
				{
					var objValue = this.ToObject();
					if (objValue is T typeValue)
					{
						return typeValue;
					}
					else if (typeof(T).IsEnum && objValue is string enumValueString)
					{
						return (T)Enum.Parse(typeof(T), enumValueString, ignoreCase: true);
					}
					else if (typeof(T).IsEnum)
					{
						return (T)Enum.ToObject(typeof(T), objValue);
					}
					else
					{
						return (T)Convert.ChangeType(this.ToObject(), typeof(T), CultureInfo.InvariantCulture);
					}
				}
			}
	
			public static implicit operator VariableValue(char value) { return new VariableValue(value); }
			public static implicit operator VariableValue(bool value) { return new VariableValue(value); }
			public static implicit operator VariableValue(byte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(sbyte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(short value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ushort value) { return new VariableValue(value); }
			public static implicit operator VariableValue(int value) { return new VariableValue(value); }
			public static implicit operator VariableValue(uint value) { return new VariableValue(value); }
			public static implicit operator VariableValue(long value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ulong value) { return new VariableValue(value); }
			public static implicit operator VariableValue(float value) { return new VariableValue(value); }
			public static implicit operator VariableValue(double value) { return new VariableValue(value); }
			public static implicit operator VariableValue(DateTime value) { return new VariableValue(value); }
			public static implicit operator VariableValue(TimeSpan value) { return new VariableValue(value); }
			public static implicit operator VariableValue(decimal value) { return new VariableValue(value); }
			public static implicit operator VariableValue(string value) { return new VariableValue(value); }
	
			public static VariableValue FromEnum(Type enumType, long value)
			{
				if (!enumType.IsEnum) throw new ArgumentException($"Type '{enumType}' should be enum type.");
	
				var typeCodeRef = TypeCodeRef.GetOrCreateEnumTypeCodeRef(enumType);
				return new VariableValue(typeCodeRef, value);
			}
	
			public static TimeSpan ToTimeSpan(object value, IFormatProvider formatProvider)
			{
				if (value == null) throw new ArgumentNullException(nameof(value));
	
				if (value is TimeSpan span)
				{
					return span;
				}
				if (value is byte byteValue)
				{
					return TimeSpan.FromTicks(byteValue);
				}
				else if (value is sbyte sByteValue)
				{
					return TimeSpan.FromTicks(sByteValue);
				}
				else if (value is short shortValue)
				{
					return TimeSpan.FromTicks(shortValue);
				}
				else if (value is ushort ushortValue)
				{
					return TimeSpan.FromTicks(ushortValue);
				}
				else if (value is int intValue)
				{
					return TimeSpan.FromTicks(intValue);
				}
				else if (value is uint uintValue)
				{
					return TimeSpan.FromTicks(uintValue);
				}
				else if (value is long longValue)
				{
					return TimeSpan.FromTicks(longValue);
				}
				else if (value is ulong ulongValue)
				{
					return TimeSpan.FromTicks((long)ulongValue);
				}
				else if (value is float floatValue)
				{
					return TimeSpan.FromTicks(checked((long)floatValue));
				}
				else if (value is double doubleValue)
				{
					return TimeSpan.FromTicks(checked((long)doubleValue));
				}
				else if (value is decimal decimalValue)
				{
					return TimeSpan.FromTicks((long)decimalValue);
				}
				else
				{
					var stringValue = Convert.ToString(value, formatProvider) ?? value.ToString();
					if (stringValue.All(char.IsDigit))
					{
						return TimeSpan.FromTicks(long.Parse(stringValue));
					}
					else
					{
						return TimeSpan.Parse(stringValue, formatProvider);
					}
				}
			}
	
			public static Expression ToVariableValueExpression(Expression valueExpression)
			{
				if (valueExpression == null) throw new ArgumentNullException(nameof(valueExpression));
	
				var expressionType = valueExpression.Type;
				var constructor = typeof(VariableValue).GetConstructor(new[] { expressionType });
				if (constructor != null)
				{
					return Expression.New(constructor, valueExpression);
				}
	
				constructor = typeof(VariableValue).GetConstructor(new[] { typeof(object) });
				if (constructor == null)
				{
					throw new InvalidOperationException($"There is no .ctr(object value) constructor on '{typeof(VariableValue)}' type. Make sure it is not removed by IL Linker.");
				}
				return Expression.New(constructor, Expression.Convert(valueExpression, typeof(object)));
			}
			public static Expression FromVariableValueExpression(Expression variableValueExpression, Type expectedType)
			{
				if (variableValueExpression == null) throw new ArgumentNullException(nameof(variableValueExpression));
				if (expectedType == null) throw new ArgumentNullException(nameof(expectedType));
	
				var convertMethod = typeof(VariableValue).GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public, null, new[] { expectedType }, null);
				if (convertMethod != null)
				{
					return Expression.Call(convertMethod, variableValueExpression);
				}
	
				convertMethod = typeof(VariableValue)
					.GetMethods(BindingFlags.Instance | BindingFlags.Public)
					.FirstOrDefault(method => method.Name.StartsWith("To") && method.ReturnType == expectedType);
				if (convertMethod != null)
				{
					var parameterExpressions = Array.ConvertAll(convertMethod.GetParameters(), parameter => parameter.HasDefaultValue ?
						Expression.Constant(parameter.DefaultValue) :
						(Expression)Expression.Default(parameter.ParameterType)
					);
	
					return Expression.Call(variableValueExpression, convertMethod, parameterExpressions);
				}
	
				var toObjectCall = Expression.Call(variableValueExpression, nameof(ToObject), Type.EmptyTypes);
				return Expression.Convert(toObjectCall, expectedType);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var value = this.ToObject();
				return Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
			}
		}
	
<#+ 
	}
#>
