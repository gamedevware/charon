

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

namespace Assets.Scripts
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
		using System.Xml;
			using GameDevWare.Dynamic.Expressions;
		[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class ProjectSettings : Document, IEquatable<ProjectSettings>, IComparable, IComparable<ProjectSettings>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly string _name;
		private readonly string _primaryLanguage;
		private readonly string _languages;
		private readonly string _copyright;

		public string Id { get { return this._id; } }
		public string Name { get { return this._name; } }
		public string PrimaryLanguage { get { return this._primaryLanguage; } }
		public string Languages { get { return this._languages; } }
		public string Copyright { get { return this._copyright; } }

		public ProjectSettings(string id, string name, string primaryLanguage, string languages, string copyright)
		{
			this._id = id;
			this._name = name;
			this._primaryLanguage = primaryLanguage;
			this._languages = languages;
			this._copyright = copyright;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(ProjectSettings other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is ProjectSettings == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (ProjectSettings)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._primaryLanguage, other._primaryLanguage)
				&& AreEquals(this._languages, other._languages)
				&& AreEquals(this._copyright, other._copyright)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ProjectSettings);
		}

		public int CompareTo(ProjectSettings other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(ProjectSettings value1, ProjectSettings value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(ProjectSettings value1, ProjectSettings value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._primaryLanguage)
				+ GetHashCodeFor(this._languages)
				+ GetHashCodeFor(this._copyright)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Project Name: ").Append(this._name).Append(", ");
				sb.Append("Primary Language: ").Append(this._primaryLanguage).Append(", ");
				sb.Append("Languages: ").Append(this._languages).Append(", ");
				sb.Append("Copyright: ").Append(this._copyright).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Parameter : Document, IEquatable<Parameter>, IComparable, IComparable<Parameter>
	{
		private readonly int hashCode;
		private readonly ParameterId _id;
		private readonly Nullable<float> _minValue;
		private readonly Nullable<float> _maxValue;
		private readonly DocumentReference<Parameter> _minValueParameter;
		private readonly DocumentReference<Parameter> _maxValueParameter;
		private readonly ParameterValueKind _valueKind;

		public ParameterId Id { get { return this._id; } }
		/// <summary>
		/// Maximal value for this attribute.
		/// </summary>
		public Nullable<float> MinValue { get { return this._minValue; } }
		/// <summary>
		/// Maximal value for this attribute.
		/// </summary>
		public Nullable<float> MaxValue { get { return this._maxValue; } }
		public Parameter MinValueParameter { get { return this._minValueParameter != null ? this._minValueParameter.Value : null; } }
		public Parameter MaxValueParameter { get { return this._maxValueParameter != null ? this._maxValueParameter.Value : null; } }
		public ParameterValueKind ValueKind { get { return this._valueKind; } }

		public Parameter(ParameterId id, Nullable<float> minValue, Nullable<float> maxValue, DocumentReference<Parameter> minValueParameter, DocumentReference<Parameter> maxValueParameter, ParameterValueKind valueKind)
		{
			this._id = id;
			this._minValue = minValue;
			this._maxValue = maxValue;
			this._minValueParameter = minValueParameter;
			this._maxValueParameter = maxValueParameter;
			this._valueKind = valueKind;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._minValueParameter != null) { this._minValueParameter.Resolve(gameData.FindDocument); }
			if (this._maxValueParameter != null) { this._maxValueParameter.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Parameter other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Parameter == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Parameter)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._minValue, other._minValue)
				&& AreEquals(this._maxValue, other._maxValue)
				&& AreEquals(this._minValueParameter, other._minValueParameter)
				&& AreEquals(this._maxValueParameter, other._maxValueParameter)
				&& AreEquals(this._valueKind, other._valueKind)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Parameter);
		}

		public int CompareTo(Parameter other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(Parameter value1, Parameter value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Parameter value1, Parameter value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._minValue)
				+ GetHashCodeFor(this._maxValue)
				+ GetHashCodeFor(this._minValueParameter)
				+ GetHashCodeFor(this._maxValueParameter)
				+ GetHashCodeFor(this._valueKind)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Min Value: ").Append(this._minValue).Append(", ");
				sb.Append("Max Value: ").Append(this._maxValue).Append(", ");
				sb.Append("Min Value Parameter: ").Append(this._minValueParameter).Append(", ");
				sb.Append("Max Value Parameter: ").Append(this._maxValueParameter).Append(", ");
				sb.Append("Value Kind: ").Append(this._valueKind).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class ParameterValue : Document, IEquatable<ParameterValue>, IComparable, IComparable<ParameterValue>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly DocumentReference<Parameter> _parameter;
		private readonly float _value;
		private readonly DocumentReference<Conditions> _condition;

		public int Id { get { return this._id; } }
		public Parameter Parameter { get { return this._parameter != null ? this._parameter.Value : null; } }
		public float Value { get { return this._value; } }
		public Conditions Condition { get { return this._condition != null ? this._condition.Value : null; } }

		public ParameterValue(int id, DocumentReference<Parameter> parameter, float @value, DocumentReference<Conditions> condition)
		{
			this._id = id;
			this._parameter = parameter;
			this._value = @value;
			this._condition = condition;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._parameter != null) { this._parameter.Resolve(gameData.FindDocument); }
			if (this._condition != null) { this._condition.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(ParameterValue other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is ParameterValue == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (ParameterValue)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._parameter, other._parameter)
				&& AreEquals(this._value, other._value)
				&& AreEquals(this._condition, other._condition)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ParameterValue);
		}

		public int CompareTo(ParameterValue other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(ParameterValue value1, ParameterValue value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(ParameterValue value1, ParameterValue value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._parameter)
				+ GetHashCodeFor(this._value)
				+ GetHashCodeFor(this._condition)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Parameter: ").Append(this._parameter).Append(", ");
				sb.Append("Value: ").Append(this._value).Append(", ");
				sb.Append("Condition: ").Append(this._condition).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Provision : Document, IEquatable<Provision>, IComparable, IComparable<Provision>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly int _cost;
		private readonly Item _item;

		public string Id { get { return this._id; } }
		/// <summary>
		/// Cost of provision in gold.
		/// </summary>
		public int Cost { get { return this._cost; } }
		public Item Item { get { return this._item; } }

		public Provision(string id, int cost, Item item)
		{
			this._id = id;
			this._cost = cost;
			this._item = item;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			if (this._item != null)
			{
				this._item.Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Provision other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Provision == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Provision)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._cost, other._cost)
				&& AreEquals(this._item, other._item)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Provision);
		}

		public int CompareTo(Provision other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Provision value1, Provision value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Provision value1, Provision value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._cost)
				+ GetHashCodeFor(this._item)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Cost: ").Append(this._cost).Append(", ");
				sb.Append("Item: ").Append(this._item).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Hero : Document, IEquatable<Hero>, IComparable, IComparable<Hero>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly LocalizedString _bio;
		private readonly bool _religious;
		private readonly ReadOnlyList<DocumentReference<Hero>> _dislikeHeroes;
		private ReadOnlyList<Hero> _dislikeHeroes_Dereferenced;
		private readonly DocumentReference<Provision> _provisions;
		private readonly int _provisionsCount;
		private readonly int _movementForward;
		private readonly int _movementBackward;
		private readonly int _protection;
		private readonly int _accuracyModifier;
		private readonly float _stunResistance;
		private readonly float _blightResistance;
		private readonly float _diseaseResistance;
		private readonly float _deathBlowResistance;
		private readonly float _moveResistance;
		private readonly float _bleedResistance;
		private readonly float _debuffResistance;
		private readonly float _trapResistance;
		private readonly ReadOnlyList<Armor> _armors;
		private readonly ReadOnlyList<Weapon> _weapons;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public string Bio {	get { return this._bio != null ? this._bio.Value : null; } }
		public bool Religious { get { return this._religious; } }
		/// <summary>
		/// List of heroes which dislikes current hero.
		/// </summary>
		public ReadOnlyList<Hero> DislikeHeroes { get { return DereferenceCollection(this._dislikeHeroes, ref this._dislikeHeroes_Dereferenced); } }
		public Provision Provisions { get { return this._provisions != null ? this._provisions.Value : null; } }
		public int ProvisionsCount { get { return this._provisionsCount; } }
		/// <summary>
		/// Maximum possible change in the position of the hero. Direction - forward.
		/// </summary>
		public int MovementForward { get { return this._movementForward; } }
		/// <summary>
		/// Maximum possible change in the position of the hero. Direction - backward.
		/// </summary>
		public int MovementBackward { get { return this._movementBackward; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public int Protection { get { return this._protection; } }
		public int AccuracyModifier { get { return this._accuracyModifier; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float StunResistance { get { return this._stunResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float BlightResistance { get { return this._blightResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DiseaseResistance { get { return this._diseaseResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DeathBlowResistance { get { return this._deathBlowResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float MoveResistance { get { return this._moveResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float BleedResistance { get { return this._bleedResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float DebuffResistance { get { return this._debuffResistance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float TrapResistance { get { return this._trapResistance; } }
		public ReadOnlyList<Armor> Armors { get { return this._armors; } }
		public ReadOnlyList<Weapon> Weapons { get { return this._weapons; } }

		public Hero(string id, LocalizedString name, LocalizedString bio, bool religious, ReadOnlyList<DocumentReference<Hero>> dislikeHeroes, DocumentReference<Provision> provisions, int provisionsCount, int movementForward, int movementBackward, int protection, int accuracyModifier, float stunResistance, float blightResistance, float diseaseResistance, float deathBlowResistance, float moveResistance, float bleedResistance, float debuffResistance, float trapResistance, ReadOnlyList<Armor> armors, ReadOnlyList<Weapon> weapons)
		{
			this._id = id;
			this._name = name;
			this._bio = bio;
			this._religious = religious;
			this._dislikeHeroes = dislikeHeroes;
			EmptyIfNull(ref this._dislikeHeroes);
			this._provisions = provisions;
			this._provisionsCount = provisionsCount;
			this._movementForward = movementForward;
			this._movementBackward = movementBackward;
			this._protection = protection;
			this._accuracyModifier = accuracyModifier;
			this._stunResistance = stunResistance;
			this._blightResistance = blightResistance;
			this._diseaseResistance = diseaseResistance;
			this._deathBlowResistance = deathBlowResistance;
			this._moveResistance = moveResistance;
			this._bleedResistance = bleedResistance;
			this._debuffResistance = debuffResistance;
			this._trapResistance = trapResistance;
			this._armors = armors;
			EmptyIfNull(ref this._armors);
			this._weapons = weapons;
			EmptyIfNull(ref this._weapons);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			foreach (var reference in this._dislikeHeroes) { reference.Resolve(gameData.FindDocument); }
			if (this._provisions != null) { this._provisions.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			if (this._bio != null)
				this._bio.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._armors.Count; i++)
			{
				this._armors[i].Apply(visitor);
			}
			for(var i = 0; i < this._weapons.Count; i++)
			{
				this._weapons[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Hero other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Hero == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Hero)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._bio, other._bio)
				&& AreEquals(this._religious, other._religious)
				&& AreEquals(this._dislikeHeroes, other._dislikeHeroes)
				&& AreEquals(this._provisions, other._provisions)
				&& AreEquals(this._provisionsCount, other._provisionsCount)
				&& AreEquals(this._movementForward, other._movementForward)
				&& AreEquals(this._movementBackward, other._movementBackward)
				&& AreEquals(this._protection, other._protection)
				&& AreEquals(this._accuracyModifier, other._accuracyModifier)
				&& AreEquals(this._stunResistance, other._stunResistance)
				&& AreEquals(this._blightResistance, other._blightResistance)
				&& AreEquals(this._diseaseResistance, other._diseaseResistance)
				&& AreEquals(this._deathBlowResistance, other._deathBlowResistance)
				&& AreEquals(this._moveResistance, other._moveResistance)
				&& AreEquals(this._bleedResistance, other._bleedResistance)
				&& AreEquals(this._debuffResistance, other._debuffResistance)
				&& AreEquals(this._trapResistance, other._trapResistance)
				&& AreEquals(this._armors, other._armors)
				&& AreEquals(this._weapons, other._weapons)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Hero);
		}

		public int CompareTo(Hero other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Hero value1, Hero value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Hero value1, Hero value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._bio)
				+ GetHashCodeFor(this._religious)
				+ GetHashCodeFor(this._dislikeHeroes)
				+ GetHashCodeFor(this._provisions)
				+ GetHashCodeFor(this._provisionsCount)
				+ GetHashCodeFor(this._movementForward)
				+ GetHashCodeFor(this._movementBackward)
				+ GetHashCodeFor(this._protection)
				+ GetHashCodeFor(this._accuracyModifier)
				+ GetHashCodeFor(this._stunResistance)
				+ GetHashCodeFor(this._blightResistance)
				+ GetHashCodeFor(this._diseaseResistance)
				+ GetHashCodeFor(this._deathBlowResistance)
				+ GetHashCodeFor(this._moveResistance)
				+ GetHashCodeFor(this._bleedResistance)
				+ GetHashCodeFor(this._debuffResistance)
				+ GetHashCodeFor(this._trapResistance)
				+ GetHashCodeFor(this._armors)
				+ GetHashCodeFor(this._weapons)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Bio: ").Append(this._bio).Append(", ");
				sb.Append("Religious: ").Append(this._religious).Append(", ");
				sb.Append("Dislike Heroes: ").Append(this._dislikeHeroes).Append(", ");
				sb.Append("Provisions: ").Append(this._provisions).Append(", ");
				sb.Append("Provisions Count: ").Append(this._provisionsCount).Append(", ");
				sb.Append("Movement Forward: ").Append(this._movementForward).Append(", ");
				sb.Append("Movement Backward: ").Append(this._movementBackward).Append(", ");
				sb.Append("Protection: ").Append(this._protection).Append(", ");
				sb.Append("Accuracy Modifier: ").Append(this._accuracyModifier).Append(", ");
				sb.Append("Stun Resistance: ").Append(this._stunResistance).Append(", ");
				sb.Append("Blight Resistance: ").Append(this._blightResistance).Append(", ");
				sb.Append("Disease Resistance: ").Append(this._diseaseResistance).Append(", ");
				sb.Append("Death Blow Resistance: ").Append(this._deathBlowResistance).Append(", ");
				sb.Append("Move Resistance: ").Append(this._moveResistance).Append(", ");
				sb.Append("Bleed Resistance: ").Append(this._bleedResistance).Append(", ");
				sb.Append("Debuff Resistance: ").Append(this._debuffResistance).Append(", ");
				sb.Append("Trap Resistance: ").Append(this._trapResistance).Append(", ");
				sb.Append("Armors: ").Append(this._armors).Append(", ");
				sb.Append("Weapons: ").Append(this._weapons).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Item : Document, IEquatable<Item>, IComparable, IComparable<Item>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly LocalizedString _description;
		private readonly int _stackSize;
		private readonly int _goldValue;
		private readonly ReadOnlyList<ParameterValue> _activationEffects;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public string Description {	get { return this._description != null ? this._description.Value : null; } }
		/// <summary>
		/// Zero and one mean - non stackable.
		/// </summary>
		public int StackSize { get { return this._stackSize; } }
		/// <summary>
		/// Gold value of treasure. Rewared upon completion of mission.
		/// </summary>
		public int GoldValue { get { return this._goldValue; } }
		public ReadOnlyList<ParameterValue> ActivationEffects { get { return this._activationEffects; } }

		public Item(string id, LocalizedString name, LocalizedString description, int stackSize, int goldValue, ReadOnlyList<ParameterValue> activationEffects)
		{
			this._id = id;
			this._name = name;
			this._description = description;
			this._stackSize = stackSize;
			this._goldValue = goldValue;
			this._activationEffects = activationEffects;
			EmptyIfNull(ref this._activationEffects);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			if (this._description != null)
				this._description.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._activationEffects.Count; i++)
			{
				this._activationEffects[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Item other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Item == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Item)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._description, other._description)
				&& AreEquals(this._stackSize, other._stackSize)
				&& AreEquals(this._goldValue, other._goldValue)
				&& AreEquals(this._activationEffects, other._activationEffects)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Item);
		}

		public int CompareTo(Item other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Item value1, Item value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Item value1, Item value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._description)
				+ GetHashCodeFor(this._stackSize)
				+ GetHashCodeFor(this._goldValue)
				+ GetHashCodeFor(this._activationEffects)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Description: ").Append(this._description).Append(", ");
				sb.Append("Stack Size: ").Append(this._stackSize).Append(", ");
				sb.Append("Gold Value: ").Append(this._goldValue).Append(", ");
				sb.Append("Activation Effects: ").Append(this._activationEffects).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Location : Document, IEquatable<Location>, IComparable, IComparable<Location>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly Nullable<LocationFlags> _flags;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public Nullable<LocationFlags> Flags { get { return this._flags; } }

		public Location(string id, LocalizedString name, Nullable<LocationFlags> flags)
		{
			this._id = id;
			this._name = name;
			this._flags = flags;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Location other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Location == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Location)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._flags, other._flags)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Location);
		}

		public int CompareTo(Location other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Location value1, Location value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Location value1, Location value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._flags)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Flags: ").Append(this._flags).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Trinket : Document, IEquatable<Trinket>, IComparable, IComparable<Trinket>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly TrinketRarity _rarity;
		private readonly DocumentReference<Location> _originDungeon;
		private readonly DocumentReference<Hero> _heroRestriction;
		private readonly Item _item;
		private readonly ReadOnlyList<ParameterValue> _effects;

		public string Id { get { return this._id; } }
		public TrinketRarity Rarity { get { return this._rarity; } }
		public Location OriginDungeon { get { return this._originDungeon != null ? this._originDungeon.Value : null; } }
		public Hero HeroRestriction { get { return this._heroRestriction != null ? this._heroRestriction.Value : null; } }
		public Item Item { get { return this._item; } }
		public ReadOnlyList<ParameterValue> Effects { get { return this._effects; } }

		public Trinket(string id, TrinketRarity rarity, DocumentReference<Location> originDungeon, DocumentReference<Hero> heroRestriction, Item item, ReadOnlyList<ParameterValue> effects)
		{
			this._id = id;
			this._rarity = rarity;
			this._originDungeon = originDungeon;
			this._heroRestriction = heroRestriction;
			this._item = item;
			this._effects = effects;
			EmptyIfNull(ref this._effects);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._originDungeon != null) { this._originDungeon.Resolve(gameData.FindDocument); }
			if (this._heroRestriction != null) { this._heroRestriction.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			if (this._item != null)
			{
				this._item.Apply(visitor);
			}
			for(var i = 0; i < this._effects.Count; i++)
			{
				this._effects[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Trinket other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Trinket == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Trinket)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._rarity, other._rarity)
				&& AreEquals(this._originDungeon, other._originDungeon)
				&& AreEquals(this._heroRestriction, other._heroRestriction)
				&& AreEquals(this._item, other._item)
				&& AreEquals(this._effects, other._effects)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Trinket);
		}

		public int CompareTo(Trinket other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Trinket value1, Trinket value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Trinket value1, Trinket value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._rarity)
				+ GetHashCodeFor(this._originDungeon)
				+ GetHashCodeFor(this._heroRestriction)
				+ GetHashCodeFor(this._item)
				+ GetHashCodeFor(this._effects)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Rarity: ").Append(this._rarity).Append(", ");
				sb.Append("Origin Dungeon: ").Append(this._originDungeon).Append(", ");
				sb.Append("Hero Restriction: ").Append(this._heroRestriction).Append(", ");
				sb.Append("Item: ").Append(this._item).Append(", ");
				sb.Append("Effects: ").Append(this._effects).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Monster : Document, IEquatable<Monster>, IComparable, IComparable<Monster>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly MonsterType _type;
		private readonly Nullable<MonsterType> _secondType;
		private readonly ReadOnlyList<ParameterValue> _parameters;
		private readonly ReadOnlyList<DocumentReference<Location>> _locations;
		private ReadOnlyList<Location> _locations_Dereferenced;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public MonsterType Type { get { return this._type; } }
		public Nullable<MonsterType> SecondType { get { return this._secondType; } }
		public ReadOnlyList<ParameterValue> Parameters { get { return this._parameters; } }
		public ReadOnlyList<Location> Locations { get { return DereferenceCollection(this._locations, ref this._locations_Dereferenced); } }

		public Monster(string id, LocalizedString name, MonsterType type, Nullable<MonsterType> secondType, ReadOnlyList<ParameterValue> parameters, ReadOnlyList<DocumentReference<Location>> locations)
		{
			this._id = id;
			this._name = name;
			this._type = type;
			this._secondType = secondType;
			this._parameters = parameters;
			EmptyIfNull(ref this._parameters);
			this._locations = locations;
			EmptyIfNull(ref this._locations);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			foreach (var reference in this._locations) { reference.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._parameters.Count; i++)
			{
				this._parameters[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Monster other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Monster == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Monster)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._type, other._type)
				&& AreEquals(this._secondType, other._secondType)
				&& AreEquals(this._parameters, other._parameters)
				&& AreEquals(this._locations, other._locations)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Monster);
		}

		public int CompareTo(Monster other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Monster value1, Monster value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Monster value1, Monster value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._type)
				+ GetHashCodeFor(this._secondType)
				+ GetHashCodeFor(this._parameters)
				+ GetHashCodeFor(this._locations)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Type: ").Append(this._type).Append(", ");
				sb.Append("Second Type: ").Append(this._secondType).Append(", ");
				sb.Append("Parameters: ").Append(this._parameters).Append(", ");
				sb.Append("Locations: ").Append(this._locations).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Loot : Document, IEquatable<Loot>, IComparable, IComparable<Loot>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly LootType _type;
		private readonly Nullable<int> _amount;

		public int Id { get { return this._id; } }
		public LootType Type { get { return this._type; } }
		public Nullable<int> Amount { get { return this._amount; } }

		public Loot(int id, LootType type, Nullable<int> amount)
		{
			this._id = id;
			this._type = type;
			this._amount = amount;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Loot other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Loot == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Loot)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._type, other._type)
				&& AreEquals(this._amount, other._amount)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Loot);
		}

		public int CompareTo(Loot other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(Loot value1, Loot value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Loot value1, Loot value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._type)
				+ GetHashCodeFor(this._amount)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Type: ").Append(this._type).Append(", ");
				sb.Append("Amount: ").Append(this._amount).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class CombatEffect : Document, IEquatable<CombatEffect>, IComparable, IComparable<CombatEffect>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly ReadOnlyList<ParameterValue> _changes;
		private readonly Nullable<int> _duration;
		private readonly DurationUnit _durationUnit;

		public int Id { get { return this._id; } }
		public ReadOnlyList<ParameterValue> Changes { get { return this._changes; } }
		/// <summary>
		/// zero or empty - effect is permanent.
		/// </summary>
		public Nullable<int> Duration { get { return this._duration; } }
		public DurationUnit DurationUnit { get { return this._durationUnit; } }

		public CombatEffect(int id, ReadOnlyList<ParameterValue> changes, Nullable<int> duration, DurationUnit durationUnit)
		{
			this._id = id;
			this._changes = changes;
			EmptyIfNull(ref this._changes);
			this._duration = duration;
			this._durationUnit = durationUnit;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._changes.Count; i++)
			{
				this._changes[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(CombatEffect other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is CombatEffect == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (CombatEffect)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._changes, other._changes)
				&& AreEquals(this._duration, other._duration)
				&& AreEquals(this._durationUnit, other._durationUnit)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as CombatEffect);
		}

		public int CompareTo(CombatEffect other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(CombatEffect value1, CombatEffect value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(CombatEffect value1, CombatEffect value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._changes)
				+ GetHashCodeFor(this._duration)
				+ GetHashCodeFor(this._durationUnit)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Changes: ").Append(this._changes).Append(", ");
				sb.Append("Duration: ").Append(this._duration).Append(", ");
				sb.Append("Duration Unit: ").Append(this._durationUnit).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class CurioCleansingOption : Document, IEquatable<CurioCleansingOption>, IComparable, IComparable<CurioCleansingOption>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly float _chance;
		private readonly DocumentReference<Item> _item;
		private readonly ReadOnlyList<Loot> _loot;
		private readonly Nullable<float> _quirkChance;
		private readonly Nullable<float> _diseaseChance;
		private readonly ReadOnlyList<ParameterValue> _effects;
		private readonly bool _itemIsConsumed;

		public int Id { get { return this._id; } }
		/// <summary>
		/// Chance of happening of this cleansing option relative to other options.
		/// </summary>
		public float Chance { get { return this._chance; } }
		/// <summary>
		/// Cleansing item.
		/// </summary>
		public Item Item { get { return this._item != null ? this._item.Value : null; } }
		public ReadOnlyList<Loot> Loot { get { return this._loot; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%. Positive value is for positive quirks and negative for negative quirks.
		/// </summary>
		public Nullable<float> QuirkChance { get { return this._quirkChance; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public Nullable<float> DiseaseChance { get { return this._diseaseChance; } }
		public ReadOnlyList<ParameterValue> Effects { get { return this._effects; } }
		public bool ItemIsConsumed { get { return this._itemIsConsumed; } }

		public CurioCleansingOption(int id, float chance, DocumentReference<Item> item, ReadOnlyList<Loot> loot, Nullable<float> quirkChance, Nullable<float> diseaseChance, ReadOnlyList<ParameterValue> effects, bool itemIsConsumed)
		{
			this._id = id;
			this._chance = chance;
			this._item = item;
			this._loot = loot;
			EmptyIfNull(ref this._loot);
			this._quirkChance = quirkChance;
			this._diseaseChance = diseaseChance;
			this._effects = effects;
			EmptyIfNull(ref this._effects);
			this._itemIsConsumed = itemIsConsumed;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._item != null) { this._item.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._loot.Count; i++)
			{
				this._loot[i].Apply(visitor);
			}
			for(var i = 0; i < this._effects.Count; i++)
			{
				this._effects[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(CurioCleansingOption other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is CurioCleansingOption == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (CurioCleansingOption)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._chance, other._chance)
				&& AreEquals(this._item, other._item)
				&& AreEquals(this._loot, other._loot)
				&& AreEquals(this._quirkChance, other._quirkChance)
				&& AreEquals(this._diseaseChance, other._diseaseChance)
				&& AreEquals(this._effects, other._effects)
				&& AreEquals(this._itemIsConsumed, other._itemIsConsumed)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as CurioCleansingOption);
		}

		public int CompareTo(CurioCleansingOption other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(CurioCleansingOption value1, CurioCleansingOption value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(CurioCleansingOption value1, CurioCleansingOption value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._chance)
				+ GetHashCodeFor(this._item)
				+ GetHashCodeFor(this._loot)
				+ GetHashCodeFor(this._quirkChance)
				+ GetHashCodeFor(this._diseaseChance)
				+ GetHashCodeFor(this._effects)
				+ GetHashCodeFor(this._itemIsConsumed)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Chance: ").Append(this._chance).Append(", ");
				sb.Append("Item: ").Append(this._item).Append(", ");
				sb.Append("Loot: ").Append(this._loot).Append(", ");
				sb.Append("Quirk Chance: ").Append(this._quirkChance).Append(", ");
				sb.Append("Disease Chance: ").Append(this._diseaseChance).Append(", ");
				sb.Append("Effects: ").Append(this._effects).Append(", ");
				sb.Append("Item Is Consumed: ").Append(this._itemIsConsumed).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Curio : Document, IEquatable<Curio>, IComparable, IComparable<Curio>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly CurioType _type;
		private readonly LocalizedString _name;
		private readonly LocalizedString _description;
		private readonly ReadOnlyList<CurioCleansingOption> _cleansingOptions;
		private readonly CurioPlacementRestictions _placementRestictions;
		private readonly ReadOnlyList<DocumentReference<Location>> _locations;
		private ReadOnlyList<Location> _locations_Dereferenced;

		public string Id { get { return this._id; } }
		public CurioType Type { get { return this._type; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public string Description {	get { return this._description != null ? this._description.Value : null; } }
		/// <summary>
		/// None mean - can&apos;t cleanse.
		/// </summary>
		public ReadOnlyList<CurioCleansingOption> CleansingOptions { get { return this._cleansingOptions; } }
		public CurioPlacementRestictions PlacementRestictions { get { return this._placementRestictions; } }
		public ReadOnlyList<Location> Locations { get { return DereferenceCollection(this._locations, ref this._locations_Dereferenced); } }

		public Curio(string id, CurioType type, LocalizedString name, LocalizedString description, ReadOnlyList<CurioCleansingOption> cleansingOptions, CurioPlacementRestictions placementRestictions, ReadOnlyList<DocumentReference<Location>> locations)
		{
			this._id = id;
			this._type = type;
			this._name = name;
			this._description = description;
			this._cleansingOptions = cleansingOptions;
			EmptyIfNull(ref this._cleansingOptions);
			this._placementRestictions = placementRestictions;
			this._locations = locations;
			EmptyIfNull(ref this._locations);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			foreach (var reference in this._locations) { reference.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			if (this._description != null)
				this._description.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._cleansingOptions.Count; i++)
			{
				this._cleansingOptions[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Curio other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Curio == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Curio)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._type, other._type)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._description, other._description)
				&& AreEquals(this._cleansingOptions, other._cleansingOptions)
				&& AreEquals(this._placementRestictions, other._placementRestictions)
				&& AreEquals(this._locations, other._locations)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Curio);
		}

		public int CompareTo(Curio other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Curio value1, Curio value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Curio value1, Curio value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._type)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._description)
				+ GetHashCodeFor(this._cleansingOptions)
				+ GetHashCodeFor(this._placementRestictions)
				+ GetHashCodeFor(this._locations)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Type: ").Append(this._type).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Description: ").Append(this._description).Append(", ");
				sb.Append("Cleansing Options: ").Append(this._cleansingOptions).Append(", ");
				sb.Append("Placement Restictions: ").Append(this._placementRestictions).Append(", ");
				sb.Append("Locations: ").Append(this._locations).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Disease : Document, IEquatable<Disease>, IComparable, IComparable<Disease>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly ReadOnlyList<ParameterValue> _effects;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public ReadOnlyList<ParameterValue> Effects { get { return this._effects; } }

		public Disease(string id, LocalizedString name, ReadOnlyList<ParameterValue> effects)
		{
			this._id = id;
			this._name = name;
			this._effects = effects;
			EmptyIfNull(ref this._effects);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._effects.Count; i++)
			{
				this._effects[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Disease other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Disease == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Disease)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._effects, other._effects)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Disease);
		}

		public int CompareTo(Disease other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Disease value1, Disease value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Disease value1, Disease value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._effects)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Effects: ").Append(this._effects).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Quirk : Document, IEquatable<Quirk>, IComparable, IComparable<Quirk>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly bool _isPositive;
		private readonly ReadOnlyList<ParameterValue> _effects;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public bool IsPositive { get { return this._isPositive; } }
		public ReadOnlyList<ParameterValue> Effects { get { return this._effects; } }

		public Quirk(string id, LocalizedString name, bool isPositive, ReadOnlyList<ParameterValue> effects)
		{
			this._id = id;
			this._name = name;
			this._isPositive = isPositive;
			this._effects = effects;
			EmptyIfNull(ref this._effects);
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._effects.Count; i++)
			{
				this._effects[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Quirk other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Quirk == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Quirk)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._isPositive, other._isPositive)
				&& AreEquals(this._effects, other._effects)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Quirk);
		}

		public int CompareTo(Quirk other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Quirk value1, Quirk value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Quirk value1, Quirk value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._isPositive)
				+ GetHashCodeFor(this._effects)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Is Positive: ").Append(this._isPositive).Append(", ");
				sb.Append("Effects: ").Append(this._effects).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Conditions : Document, IEquatable<Conditions>, IComparable, IComparable<Conditions>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _description;
		private readonly ConditionsCheckExpression _check;
		private readonly UnboundExpression _unboundCheck;

		public string Id { get { return this._id; } }
		public string Description {	get { return this._description != null ? this._description.Value : null; } }
		public ConditionsCheckExpression Check { get { return this._check; } }
		public UnboundExpression UnboundCheck { get { return this._unboundCheck; } }

		public Conditions(string id, LocalizedString description, Dictionary<string,object> check, Dictionary<string,object> unboundCheck)
		{
			this._id = id;
			this._description = description;
			this._check = CreateFormula(check, n => new ConditionsCheckExpression(n), "Conditions", "Check", this._id);
			this._unboundCheck = unboundCheck != null ? new UnboundExpression(new SyntaxTreeNode(unboundCheck)) : null;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._check != null) { this._check.Context.@this = this; }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._description != null)
				this._description.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Conditions other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Conditions == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Conditions)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._description, other._description)
				&& AreEquals(this._check, other._check)
				&& AreEquals(this._unboundCheck, other._unboundCheck)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Conditions);
		}

		public int CompareTo(Conditions other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Conditions value1, Conditions value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Conditions value1, Conditions value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._description)
				+ GetHashCodeFor(this._check)
				+ GetHashCodeFor(this._unboundCheck)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Description: ").Append(this._description).Append(", ");
				sb.Append("Check: ").Append(this._check).Append(", ");
				sb.Append("Unbound Check: ").Append(this._unboundCheck).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Weapon : Document, IEquatable<Weapon>, IComparable, IComparable<Weapon>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly int _damageFrom;
		private readonly int _damageTo;
		private readonly float _criticalStrikeChance;
		private readonly int _speed;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		public int DamageFrom { get { return this._damageFrom; } }
		public int DamageTo { get { return this._damageTo; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float CriticalStrikeChance { get { return this._criticalStrikeChance; } }
		public int Speed { get { return this._speed; } }

		public Weapon(string id, LocalizedString name, int damageFrom, int damageTo, float criticalStrikeChance, int speed)
		{
			this._id = id;
			this._name = name;
			this._damageFrom = damageFrom;
			this._damageTo = damageTo;
			this._criticalStrikeChance = criticalStrikeChance;
			this._speed = speed;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Weapon other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Weapon == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Weapon)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._damageFrom, other._damageFrom)
				&& AreEquals(this._damageTo, other._damageTo)
				&& AreEquals(this._criticalStrikeChance, other._criticalStrikeChance)
				&& AreEquals(this._speed, other._speed)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Weapon);
		}

		public int CompareTo(Weapon other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Weapon value1, Weapon value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Weapon value1, Weapon value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._damageFrom)
				+ GetHashCodeFor(this._damageTo)
				+ GetHashCodeFor(this._criticalStrikeChance)
				+ GetHashCodeFor(this._speed)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Damage From: ").Append(this._damageFrom).Append(", ");
				sb.Append("Damage To: ").Append(this._damageTo).Append(", ");
				sb.Append("Critical Strike Chance: ").Append(this._criticalStrikeChance).Append(", ");
				sb.Append("Speed: ").Append(this._speed).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class Armor : Document, IEquatable<Armor>, IComparable, IComparable<Armor>
	{
		private readonly int hashCode;
		private readonly string _id;
		private readonly LocalizedString _name;
		private readonly float _dodge;
		private readonly int _hitPoints;

		public string Id { get { return this._id; } }
		public string Name {	get { return this._name != null ? this._name.Value : null; } }
		/// <summary>
		/// from 0.0 to 1.0 where 0.5 is 50%.
		/// </summary>
		public float Dodge { get { return this._dodge; } }
		public int HitPoints { get { return this._hitPoints; } }

		public Armor(string id, LocalizedString name, float dodge, int hitPoints)
		{
			this._id = id;
			this._name = name;
			this._dodge = dodge;
			this._hitPoints = hitPoints;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			if (this._name != null)
				this._name.SetLanguage(languageId);
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(Armor other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is Armor == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (Armor)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._name, other._name)
				&& AreEquals(this._dodge, other._dodge)
				&& AreEquals(this._hitPoints, other._hitPoints)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Armor);
		}

		public int CompareTo(Armor other)
		{
			if (other == null)
				return 1;
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Armor value1, Armor value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Armor value1, Armor value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._name)
				+ GetHashCodeFor(this._dodge)
				+ GetHashCodeFor(this._hitPoints)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Name: ").Append(this._name).Append(", ");
				sb.Append("Dodge: ").Append(this._dodge).Append(", ");
				sb.Append("Hit Points: ").Append(this._hitPoints).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class ItemWithCount : Document, IEquatable<ItemWithCount>, IComparable, IComparable<ItemWithCount>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly DocumentReference<Item> _item;
		private readonly int _count;

		public int Id { get { return this._id; } }
		public Item Item { get { return this._item != null ? this._item.Value : null; } }
		public int Count { get { return this._count; } }

		public ItemWithCount(int id, DocumentReference<Item> item, int count)
		{
			this._id = id;
			this._item = item;
			this._count = count;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			if (this._item != null) { this._item.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(ItemWithCount other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is ItemWithCount == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (ItemWithCount)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._item, other._item)
				&& AreEquals(this._count, other._count)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ItemWithCount);
		}

		public int CompareTo(ItemWithCount other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(ItemWithCount value1, ItemWithCount value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(ItemWithCount value1, ItemWithCount value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._item)
				+ GetHashCodeFor(this._count)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Item: ").Append(this._item).Append(", ");
				sb.Append("Count: ").Append(this._count).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public sealed partial class StartingSet : Document, IEquatable<StartingSet>, IComparable, IComparable<StartingSet>
	{
		private readonly int hashCode;
		private readonly int _id;
		private readonly ReadOnlyList<ItemWithCount> _items;
		private readonly ReadOnlyList<DocumentReference<Hero>> _heroes;
		private ReadOnlyList<Hero> _heroes_Dereferenced;
		private readonly DocumentReference<Location> _location;

		public int Id { get { return this._id; } }
		public ReadOnlyList<ItemWithCount> Items { get { return this._items; } }
		public ReadOnlyList<Hero> Heroes { get { return DereferenceCollection(this._heroes, ref this._heroes_Dereferenced); } }
		public Location Location { get { return this._location != null ? this._location.Value : null; } }

		public StartingSet(int id, ReadOnlyList<ItemWithCount> items, ReadOnlyList<DocumentReference<Hero>> heroes, DocumentReference<Location> location)
		{
			this._id = id;
			this._items = items;
			EmptyIfNull(ref this._items);
			this._heroes = heroes;
			EmptyIfNull(ref this._heroes);
			this._location = location;
			this.hashCode = this.ComputeHashCode();
		}

		protected internal override void Init(RpgGameData gameData, string languageId)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (languageId == null) throw new ArgumentNullException("languageId");

			this.OnBeforeInitialize();

			this.SetLanguage(languageId);
			foreach (var reference in this._heroes) { reference.Resolve(gameData.FindDocument); }
			if (this._location != null) { this._location.Resolve(gameData.FindDocument); }

			this.OnInitialize();
		}

		protected internal override void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");
			this.OnSetLanguage(languageId);
		}

		protected internal override void Apply(RpgGameData.Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			visitor.Visit(this);

			for(var i = 0; i < this._items.Count; i++)
			{
				this._items[i].Apply(visitor);
			}
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();
		partial void OnSetLanguage(string languageId);
		
		public bool Equals(StartingSet other)
		{
			return this.Equals((object)other);
		}

		public override bool Equals(object value)
		{
			if (value is StartingSet == false)
				return false;
			else if (Object.ReferenceEquals(this, value))
				return true;
			else if (Object.ReferenceEquals(value, null))
				return false;
				
			var other = (StartingSet)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this._id, other._id)
				&& AreEquals(this._items, other._items)
				&& AreEquals(this._heroes, other._heroes)
				&& AreEquals(this._location, other._location)
			);
		}

		public override int GetHashCode()
		{
			return this.hashCode;
		}

		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as StartingSet);
		}

		public int CompareTo(StartingSet other)
		{
			if (other == null)
				return 1;
			return this.Id.CompareTo(other.Id);
		}

		public static bool operator ==(StartingSet value1, StartingSet value2)
		{
			return Object.Equals(value1, value2);
		}
		public static bool operator !=(StartingSet value1, StartingSet value2)
		{
			return Object.Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this._id)
				+ GetHashCodeFor(this._items)
				+ GetHashCodeFor(this._heroes)
				+ GetHashCodeFor(this._location)
			);
		}

		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this._id).Append(", ");
				sb.Append("Items: ").Append(this._items).Append(", ");
				sb.Append("Heroes: ").Append(this._heroes).Append(", ");
				sb.Append("Location: ").Append(this._location).Append(", ");
			if (sb.Length > 2)
				sb.Length -= 2;

			return sb.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum ParameterId: uint
	{
		None = 0,
		HitPoints = 1,
		MaxHitPoints = 2,
		MaxHitPointsPercent = 3,
		Speed = 4,
		Accuracy = 5,
		CrtiticalStrikeChance = 6,
		Stress = 7,
		Dodge = 8,
		Protection = 9,
		ScoutingChance = 10,
		FoodConsumationMultiplier = 11,
		HealResistance = 20,
		StunResistance = 21,
		BlightResistance = 22,
		DiseaseResistance = 23,
		DeathBlowResistance = 24,
		MoveResistance = 25,
		BleedResistance = 26,
		DebuffResistance = 27,
		TrapResistance = 28,
		StressResistance = 29,
		HealAmplification = 30,
		StressHealAplification = 31,
		DamageFrom = 50,
		DamageTo = 51,
		DamagePercent = 52,
		HealFrom = 53,
		HealTo = 54,
		HealMultiplier = 55,
		HealPercent = 56,
		StressHealFrom = 57,
		StressHealTo = 58,
		StressHealPercent = 59,
		BleedHealChance = 60,
		StunChance = 70,
		MarkChance = 71,
		KnockbackChance = 73,
		VirtueChance = 74,
		Position = 80,
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum ParameterValueKind: uint
	{
		None = 0,
		Integer = 1,
		Number = 2,
		Percent = 3,
	}

	[Flags]
	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum LocationFlags: uint
	{
		None = 0,
		Home = 1,
		Tutorial = 2,
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum TrinketRarity: uint
	{
		None = 0,
		Common = 1,
		Uncommon = 2,
		Rare = 3,
		VeryRare = 4,
		Shrieker = 5,
		Ancestral = 6,
		CrimsonCourt = 7,
		DarkestDungeon = 8,
		Trophy = 9,
		Backer = 10,
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum MonsterType: uint
	{
		None = 0,
		Human = 1,
		Beast = 2,
		Unholy = 3,
		Eldritch = 4,
		Corpse = 5,
		Carpentry = 6,
		Crockery = 7,
		Ironwork = 8,
		Thatchery = 9,
		Cosmic = 10,
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum LootType: uint
	{
		None = 0,
		Any = 1,
		Heirloom = 2,
		Trinket = 3,
		Supplies = 4,
		Torch = 5,
		Gold = 6,
		Food = 7,
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum DurationUnit: uint
	{
		None = 0,
		Rounds = 1,
		Camps = 2,
		Missions = 3,
	}

	[Flags]
	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum CurioType: uint
	{
		None = 0,
		Reflective = 1,
		Worship = 2,
		Knowledge = 4,
		Haunted = 8,
		Scrounging = 16,
		Fountain = 32,
		Torture = 64,
		Treasure = 128,
		Body = 256,
		Unholy = 512,
		Drink = 1024,
		Food = 2048,
	}

	[Flags]
	[GeneratedCode("Charon", "2019.3.7.0")]
	public enum CurioPlacementRestictions: uint
	{
		None = 0,
		Room = 1,
		Corridor = 2,
	}

	
	[GeneratedCode("Charon", "2019.3.7.0")]
	public partial class ConditionsCheckExpression
	{
		private static readonly ITypeResolver TypeResolver;
		private static readonly Binder ExpressionBinder;

		public partial class ConditionsCheckScope
		{
			public Conditions @this;
		}

		private readonly Expression<Func<Assets.Scripts.CheckContext, bool>> expression;
		private Func<Assets.Scripts.CheckContext, bool> compiledExpression;

		public ConditionsCheckScope Context { get; private set; }

		static ConditionsCheckExpression()
		{
			// AOT
			if (typeof(object).Name == string.Empty)
			{
				new System.Runtime.CompilerServices.StrongBox<ConditionsCheckScope>(default(ConditionsCheckScope));
				
				new System.Runtime.CompilerServices.StrongBox<Assets.Scripts.AttackType>(default(Assets.Scripts.AttackType));
			}

			var parameters = new ParameterExpression[]
			{
				Expression.Parameter(typeof(Assets.Scripts.CheckContext), "context"),
			};

			TypeResolver = new KnownTypeResolver(new Type[]
			{
				typeof(Assets.Scripts.CheckContext),
				typeof(Assets.Scripts.AttackType),
				typeof(bool),
				typeof(ConditionsCheckScope)
			}, RpgGameData.TypeResolver);

			ExpressionBinder = new Binder(parameters, typeof(bool), TypeResolver);

			AotCompilation.RegisterFunc<Assets.Scripts.CheckContext, bool>();
		}
		public ConditionsCheckExpression(SyntaxTreeNode syntaxTree)
		{
			if (syntaxTree == null) throw new ArgumentNullException("syntaxTree");

			this.Context = new ConditionsCheckScope();
			this.expression = (Expression<Func<Assets.Scripts.CheckContext, bool>>)ExpressionBinder.Bind(syntaxTree, Expression.Constant(this.Context));
		}

		public bool Invoke(Assets.Scripts.CheckContext context)
		{
			var fn = this.CompileAot();
			return fn.Invoke(context);
		}

		public Func<Assets.Scripts.CheckContext, bool> CompileAot()
		{
			try
			{
				if (this.compiledExpression == null)
					this.compiledExpression = this.expression.CompileAot();
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}
		public Func<Assets.Scripts.CheckContext, bool> Compile()
		{
			try
			{
				if (this.compiledExpression == null)
					this.compiledExpression = this.expression.Compile();
				return this.compiledExpression;
			}
			catch (Exception compilationError)
			{
				throw new InvalidOperationException(string.Format("Failed to compile expression '{0}' due errors: {1}{2}", this.ToString(), Environment.NewLine, compilationError.Message), compilationError);
			}
		}

		public Expression<Func<Assets.Scripts.CheckContext, bool>> GetExpression()
		{
			return this.expression;
		}

		public override string ToString()
		{
			return this.expression.ToString();
		}
	}



	[GeneratedCode("Charon", "2019.3.7.0")]
	public partial class RpgGameData
	{
		public static readonly ITypeResolver TypeResolver = new KnownTypeResolver(new Type[]
		{
				typeof(RpgGameData),
				typeof(ProjectSettings),
				typeof(Parameter),
				typeof(ParameterValue),
				typeof(Provision),
				typeof(Hero),
				typeof(Item),
				typeof(Location),
				typeof(Trinket),
				typeof(Monster),
				typeof(Loot),
				typeof(CombatEffect),
				typeof(CurioCleansingOption),
				typeof(Curio),
				typeof(Disease),
				typeof(Quirk),
				typeof(Conditions),
				typeof(Weapon),
				typeof(Armor),
				typeof(ItemWithCount),
				typeof(StartingSet),
				typeof(ConditionsCheckExpression),
				typeof(ParameterId),
				typeof(ParameterValueKind),
				typeof(LocationFlags),
				typeof(TrinketRarity),
				typeof(MonsterType),
				typeof(LootType),
				typeof(DurationUnit),
				typeof(CurioType),
				typeof(CurioPlacementRestictions),
		});

		#region Storage fields
		private ReadOnlyList<ProjectSettings> rootProjectSettings;
		private ReadOnlyList<ProjectSettings> allProjectSettings;
		private ReadOnlyDictionary<string, ProjectSettings> allProjectSettingsById;
		private ReadOnlyList<Parameter> rootParameter;
		private ReadOnlyList<Parameter> allParameter;
		private ReadOnlyDictionary<ParameterId, Parameter> allParameterById;
		private ReadOnlyList<ParameterValue> rootParameterValue;
		private ReadOnlyList<ParameterValue> allParameterValue;
		private ReadOnlyDictionary<int, ParameterValue> allParameterValueById;
		private ReadOnlyList<Provision> rootProvision;
		private ReadOnlyList<Provision> allProvision;
		private ReadOnlyDictionary<string, Provision> allProvisionById;
		private ReadOnlyList<Hero> rootHero;
		private ReadOnlyList<Hero> allHero;
		private ReadOnlyDictionary<string, Hero> allHeroById;
		private ReadOnlyList<Item> rootItem;
		private ReadOnlyList<Item> allItem;
		private ReadOnlyDictionary<string, Item> allItemById;
		private ReadOnlyList<Location> rootLocation;
		private ReadOnlyList<Location> allLocation;
		private ReadOnlyDictionary<string, Location> allLocationById;
		private ReadOnlyList<Trinket> rootTrinket;
		private ReadOnlyList<Trinket> allTrinket;
		private ReadOnlyDictionary<string, Trinket> allTrinketById;
		private ReadOnlyList<Monster> rootMonster;
		private ReadOnlyList<Monster> allMonster;
		private ReadOnlyDictionary<string, Monster> allMonsterById;
		private ReadOnlyList<Loot> rootLoot;
		private ReadOnlyList<Loot> allLoot;
		private ReadOnlyDictionary<int, Loot> allLootById;
		private ReadOnlyList<CombatEffect> rootCombatEffect;
		private ReadOnlyList<CombatEffect> allCombatEffect;
		private ReadOnlyDictionary<int, CombatEffect> allCombatEffectById;
		private ReadOnlyList<CurioCleansingOption> rootCurioCleansingOption;
		private ReadOnlyList<CurioCleansingOption> allCurioCleansingOption;
		private ReadOnlyDictionary<int, CurioCleansingOption> allCurioCleansingOptionById;
		private ReadOnlyList<Curio> rootCurio;
		private ReadOnlyList<Curio> allCurio;
		private ReadOnlyDictionary<string, Curio> allCurioById;
		private ReadOnlyList<Disease> rootDisease;
		private ReadOnlyList<Disease> allDisease;
		private ReadOnlyDictionary<string, Disease> allDiseaseById;
		private ReadOnlyList<Quirk> rootQuirk;
		private ReadOnlyList<Quirk> allQuirk;
		private ReadOnlyDictionary<string, Quirk> allQuirkById;
		private ReadOnlyList<Conditions> rootConditions;
		private ReadOnlyList<Conditions> allConditions;
		private ReadOnlyDictionary<string, Conditions> allConditionsById;
		private ReadOnlyList<Weapon> rootWeapon;
		private ReadOnlyList<Weapon> allWeapon;
		private ReadOnlyDictionary<string, Weapon> allWeaponById;
		private ReadOnlyList<Armor> rootArmor;
		private ReadOnlyList<Armor> allArmor;
		private ReadOnlyDictionary<string, Armor> allArmorById;
		private ReadOnlyList<ItemWithCount> rootItemWithCount;
		private ReadOnlyList<ItemWithCount> allItemWithCount;
		private ReadOnlyDictionary<int, ItemWithCount> allItemWithCountById;
		private ReadOnlyList<StartingSet> rootStartingSet;
		private ReadOnlyList<StartingSet> allStartingSet;
		private ReadOnlyDictionary<int, StartingSet> allStartingSetById;
		#endregion

		private ReadOnlyCollection<String> languages = new ReadOnlyCollection<String>(new String[] { "en-US" });
#pragma warning disable 0414 // The variable `primaryLanguage, changeNumber' is declared but never used
		private string primaryLanguage = "en-US";
		private int changeNumber = 0;
#pragma warning restore 0414

		public ReadOnlyCollection<string> SupportedLanguages { get { return this.languages; } }
		public Func<string, object, Document> FindDocument { get; private set;}


		public RpgGameData(Stream data, Format format, Stream[] patches = null, Encoding encoding = null, bool leaveOpen = false)
		{
			if (data == null) throw new ArgumentNullException("data");

			if (encoding == null) encoding = Encoding.UTF8;


			this.FindDocument = this.FindDocumentInternal;

			switch(format)
			{
				case Format.Json: this.ReadJson(this, data, patches, encoding, leaveOpen); break;
				case Format.Bson: this.ReadBson(this, data, patches, encoding, leaveOpen); break;
				case Format.Xml: this.ReadXml(this, data, patches, encoding, leaveOpen); break;
				case Format.MessagePack: this.ReadMessagePack(this, data, patches, encoding, leaveOpen); break;
				default: throw new ArgumentException(string.Format("Unknown/Unsupported data format specified '{0}'.", format), "format");
			}

#pragma warning disable 0162 // Unreachable code detected
			this.Initialize();
#pragma warning restore 0162
		}

		private void Initialize()
		{
			if (this.rootProjectSettings == null) this.rootProjectSettings = ReadOnlyList<ProjectSettings>.Empty;
			if (this.rootParameter == null) this.rootParameter = ReadOnlyList<Parameter>.Empty;
			if (this.rootParameterValue == null) this.rootParameterValue = ReadOnlyList<ParameterValue>.Empty;
			if (this.rootProvision == null) this.rootProvision = ReadOnlyList<Provision>.Empty;
			if (this.rootHero == null) this.rootHero = ReadOnlyList<Hero>.Empty;
			if (this.rootItem == null) this.rootItem = ReadOnlyList<Item>.Empty;
			if (this.rootLocation == null) this.rootLocation = ReadOnlyList<Location>.Empty;
			if (this.rootTrinket == null) this.rootTrinket = ReadOnlyList<Trinket>.Empty;
			if (this.rootMonster == null) this.rootMonster = ReadOnlyList<Monster>.Empty;
			if (this.rootLoot == null) this.rootLoot = ReadOnlyList<Loot>.Empty;
			if (this.rootCombatEffect == null) this.rootCombatEffect = ReadOnlyList<CombatEffect>.Empty;
			if (this.rootCurioCleansingOption == null) this.rootCurioCleansingOption = ReadOnlyList<CurioCleansingOption>.Empty;
			if (this.rootCurio == null) this.rootCurio = ReadOnlyList<Curio>.Empty;
			if (this.rootDisease == null) this.rootDisease = ReadOnlyList<Disease>.Empty;
			if (this.rootQuirk == null) this.rootQuirk = ReadOnlyList<Quirk>.Empty;
			if (this.rootConditions == null) this.rootConditions = ReadOnlyList<Conditions>.Empty;
			if (this.rootWeapon == null) this.rootWeapon = ReadOnlyList<Weapon>.Empty;
			if (this.rootArmor == null) this.rootArmor = ReadOnlyList<Armor>.Empty;
			if (this.rootItemWithCount == null) this.rootItemWithCount = ReadOnlyList<ItemWithCount>.Empty;
			if (this.rootStartingSet == null) this.rootStartingSet = ReadOnlyList<StartingSet>.Empty;

			this.FindAllDocuments();

			this.allProjectSettingsById = ToDictionarySkippingNullKeys(this.allProjectSettings, document => document.Id);
			this.allParameterById = ToDictionarySkippingNullKeys(this.allParameter, document => document.Id);
			this.allParameterValueById = ToDictionarySkippingNullKeys(this.allParameterValue, document => document.Id);
			this.allProvisionById = ToDictionarySkippingNullKeys(this.allProvision, document => document.Id);
			this.allHeroById = ToDictionarySkippingNullKeys(this.allHero, document => document.Id);
			this.allItemById = ToDictionarySkippingNullKeys(this.allItem, document => document.Id);
			this.allLocationById = ToDictionarySkippingNullKeys(this.allLocation, document => document.Id);
			this.allTrinketById = ToDictionarySkippingNullKeys(this.allTrinket, document => document.Id);
			this.allMonsterById = ToDictionarySkippingNullKeys(this.allMonster, document => document.Id);
			this.allLootById = ToDictionarySkippingNullKeys(this.allLoot, document => document.Id);
			this.allCombatEffectById = ToDictionarySkippingNullKeys(this.allCombatEffect, document => document.Id);
			this.allCurioCleansingOptionById = ToDictionarySkippingNullKeys(this.allCurioCleansingOption, document => document.Id);
			this.allCurioById = ToDictionarySkippingNullKeys(this.allCurio, document => document.Id);
			this.allDiseaseById = ToDictionarySkippingNullKeys(this.allDisease, document => document.Id);
			this.allQuirkById = ToDictionarySkippingNullKeys(this.allQuirk, document => document.Id);
			this.allConditionsById = ToDictionarySkippingNullKeys(this.allConditions, document => document.Id);
			this.allWeaponById = ToDictionarySkippingNullKeys(this.allWeapon, document => document.Id);
			this.allArmorById = ToDictionarySkippingNullKeys(this.allArmor, document => document.Id);
			this.allItemWithCountById = ToDictionarySkippingNullKeys(this.allItemWithCount, document => document.Id);
			this.allStartingSetById = ToDictionarySkippingNullKeys(this.allStartingSet, document => document.Id);

			this.BeforeInitialize();

			foreach(var document in this.EnumerateAll())
			{
				document.Init(this, this.primaryLanguage);
			}

			this.OnInitialize();
		}

		partial void BeforeInitialize();
		partial void OnInitialize();

		#region Accessors
		// ProjectSettings -> Id
		public ProjectSettings GetProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(ProjectSettings);
			if (this.allProjectSettingsById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find ProjectSettings with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			return this.allProjectSettingsById.ContainsKey(id);
		}
		public ProjectSettings FindProjectSettings(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(ProjectSettings);
			this.allProjectSettingsById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetProjectSettings(string id, out ProjectSettings value)
		{
			ThrowIfNull(id, "id");

			return this.allProjectSettingsById.TryGetValue(id, out value);
		}
		public ReadOnlyList<ProjectSettings> GetProjectSettings(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootProjectSettings;
			else
				return this.allProjectSettings;
		}
		// ProjectSettings -> Instance
		private ProjectSettings theProjectSettings;
		public ProjectSettings ProjectSettings 
		{ 
			get 
			{ 
				if (this.theProjectSettings != null)
					return this.theProjectSettings;

				switch(this.rootProjectSettings.Count)
				{
					case 0: throw new InvalidOperationException("Unable to find ProjectSettings document. Please create ProjectSettings document before using this property.");
					case 1: return this.theProjectSettings = this.rootProjectSettings[0];
					default: throw new InvalidOperationException("There is a multiple variants of ProjectSettings document. Please remove the excess before using this property.");
				}
			}
		}
		// Parameter -> Id
		public Parameter GetParameter(ParameterId id)
		{
			ThrowIfNull(id, "id");

			var value = default(Parameter);
			if (this.allParameterById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Parameter with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasParameter(ParameterId id)
		{
			ThrowIfNull(id, "id");

			return this.allParameterById.ContainsKey(id);
		}
		public Parameter FindParameter(ParameterId id)
		{
			ThrowIfNull(id, "id");

			var value = default(Parameter);
			this.allParameterById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetParameter(ParameterId id, out Parameter value)
		{
			ThrowIfNull(id, "id");

			return this.allParameterById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Parameter> GetParameters(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootParameter;
			else
				return this.allParameter;
		}
		// ParameterValue -> Id
		public ParameterValue GetParameterValue(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(ParameterValue);
			if (this.allParameterValueById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find ParameterValue with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasParameterValue(int id)
		{
			ThrowIfNull(id, "id");

			return this.allParameterValueById.ContainsKey(id);
		}
		public ParameterValue FindParameterValue(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(ParameterValue);
			this.allParameterValueById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetParameterValue(int id, out ParameterValue value)
		{
			ThrowIfNull(id, "id");

			return this.allParameterValueById.TryGetValue(id, out value);
		}
		public ReadOnlyList<ParameterValue> GetParameterValues(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootParameterValue;
			else
				return this.allParameterValue;
		}
		// Provision -> Id
		public Provision GetProvision(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Provision);
			if (this.allProvisionById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Provision with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasProvision(string id)
		{
			ThrowIfNull(id, "id");

			return this.allProvisionById.ContainsKey(id);
		}
		public Provision FindProvision(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Provision);
			this.allProvisionById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetProvision(string id, out Provision value)
		{
			ThrowIfNull(id, "id");

			return this.allProvisionById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Provision> GetProvisions(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootProvision;
			else
				return this.allProvision;
		}
		// Hero -> Id
		public Hero GetHero(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Hero);
			if (this.allHeroById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Hero with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasHero(string id)
		{
			ThrowIfNull(id, "id");

			return this.allHeroById.ContainsKey(id);
		}
		public Hero FindHero(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Hero);
			this.allHeroById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetHero(string id, out Hero value)
		{
			ThrowIfNull(id, "id");

			return this.allHeroById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Hero> GetHeros(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootHero;
			else
				return this.allHero;
		}
		// Item -> Id
		public Item GetItem(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Item);
			if (this.allItemById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Item with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasItem(string id)
		{
			ThrowIfNull(id, "id");

			return this.allItemById.ContainsKey(id);
		}
		public Item FindItem(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Item);
			this.allItemById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetItem(string id, out Item value)
		{
			ThrowIfNull(id, "id");

			return this.allItemById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Item> GetItems(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootItem;
			else
				return this.allItem;
		}
		// Location -> Id
		public Location GetLocation(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Location);
			if (this.allLocationById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Location with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasLocation(string id)
		{
			ThrowIfNull(id, "id");

			return this.allLocationById.ContainsKey(id);
		}
		public Location FindLocation(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Location);
			this.allLocationById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetLocation(string id, out Location value)
		{
			ThrowIfNull(id, "id");

			return this.allLocationById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Location> GetLocations(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootLocation;
			else
				return this.allLocation;
		}
		// Trinket -> Id
		public Trinket GetTrinket(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Trinket);
			if (this.allTrinketById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Trinket with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasTrinket(string id)
		{
			ThrowIfNull(id, "id");

			return this.allTrinketById.ContainsKey(id);
		}
		public Trinket FindTrinket(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Trinket);
			this.allTrinketById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetTrinket(string id, out Trinket value)
		{
			ThrowIfNull(id, "id");

			return this.allTrinketById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Trinket> GetTrinkets(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootTrinket;
			else
				return this.allTrinket;
		}
		// Monster -> Id
		public Monster GetMonster(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Monster);
			if (this.allMonsterById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Monster with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasMonster(string id)
		{
			ThrowIfNull(id, "id");

			return this.allMonsterById.ContainsKey(id);
		}
		public Monster FindMonster(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Monster);
			this.allMonsterById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetMonster(string id, out Monster value)
		{
			ThrowIfNull(id, "id");

			return this.allMonsterById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Monster> GetMonsters(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootMonster;
			else
				return this.allMonster;
		}
		// Loot -> Id
		public Loot GetLoot(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(Loot);
			if (this.allLootById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Loot with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasLoot(int id)
		{
			ThrowIfNull(id, "id");

			return this.allLootById.ContainsKey(id);
		}
		public Loot FindLoot(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(Loot);
			this.allLootById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetLoot(int id, out Loot value)
		{
			ThrowIfNull(id, "id");

			return this.allLootById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Loot> GetLoots(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootLoot;
			else
				return this.allLoot;
		}
		// CombatEffect -> Id
		public CombatEffect GetCombatEffect(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(CombatEffect);
			if (this.allCombatEffectById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find CombatEffect with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasCombatEffect(int id)
		{
			ThrowIfNull(id, "id");

			return this.allCombatEffectById.ContainsKey(id);
		}
		public CombatEffect FindCombatEffect(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(CombatEffect);
			this.allCombatEffectById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetCombatEffect(int id, out CombatEffect value)
		{
			ThrowIfNull(id, "id");

			return this.allCombatEffectById.TryGetValue(id, out value);
		}
		public ReadOnlyList<CombatEffect> GetCombatEffects(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootCombatEffect;
			else
				return this.allCombatEffect;
		}
		// CurioCleansingOption -> Id
		public CurioCleansingOption GetCurioCleansingOption(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(CurioCleansingOption);
			if (this.allCurioCleansingOptionById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find CurioCleansingOption with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasCurioCleansingOption(int id)
		{
			ThrowIfNull(id, "id");

			return this.allCurioCleansingOptionById.ContainsKey(id);
		}
		public CurioCleansingOption FindCurioCleansingOption(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(CurioCleansingOption);
			this.allCurioCleansingOptionById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetCurioCleansingOption(int id, out CurioCleansingOption value)
		{
			ThrowIfNull(id, "id");

			return this.allCurioCleansingOptionById.TryGetValue(id, out value);
		}
		public ReadOnlyList<CurioCleansingOption> GetCurioCleansingOptions(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootCurioCleansingOption;
			else
				return this.allCurioCleansingOption;
		}
		// Curio -> Id
		public Curio GetCurio(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Curio);
			if (this.allCurioById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Curio with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasCurio(string id)
		{
			ThrowIfNull(id, "id");

			return this.allCurioById.ContainsKey(id);
		}
		public Curio FindCurio(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Curio);
			this.allCurioById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetCurio(string id, out Curio value)
		{
			ThrowIfNull(id, "id");

			return this.allCurioById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Curio> GetCurios(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootCurio;
			else
				return this.allCurio;
		}
		// Disease -> Id
		public Disease GetDisease(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Disease);
			if (this.allDiseaseById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Disease with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasDisease(string id)
		{
			ThrowIfNull(id, "id");

			return this.allDiseaseById.ContainsKey(id);
		}
		public Disease FindDisease(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Disease);
			this.allDiseaseById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetDisease(string id, out Disease value)
		{
			ThrowIfNull(id, "id");

			return this.allDiseaseById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Disease> GetDiseases(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootDisease;
			else
				return this.allDisease;
		}
		// Quirk -> Id
		public Quirk GetQuirk(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Quirk);
			if (this.allQuirkById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Quirk with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasQuirk(string id)
		{
			ThrowIfNull(id, "id");

			return this.allQuirkById.ContainsKey(id);
		}
		public Quirk FindQuirk(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Quirk);
			this.allQuirkById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetQuirk(string id, out Quirk value)
		{
			ThrowIfNull(id, "id");

			return this.allQuirkById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Quirk> GetQuirks(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootQuirk;
			else
				return this.allQuirk;
		}
		// Conditions -> Id
		public Conditions GetConditions(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Conditions);
			if (this.allConditionsById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Conditions with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasConditions(string id)
		{
			ThrowIfNull(id, "id");

			return this.allConditionsById.ContainsKey(id);
		}
		public Conditions FindConditions(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Conditions);
			this.allConditionsById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetConditions(string id, out Conditions value)
		{
			ThrowIfNull(id, "id");

			return this.allConditionsById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Conditions> GetConditions(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootConditions;
			else
				return this.allConditions;
		}
		// Weapon -> Id
		public Weapon GetWeapon(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Weapon);
			if (this.allWeaponById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Weapon with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasWeapon(string id)
		{
			ThrowIfNull(id, "id");

			return this.allWeaponById.ContainsKey(id);
		}
		public Weapon FindWeapon(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Weapon);
			this.allWeaponById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetWeapon(string id, out Weapon value)
		{
			ThrowIfNull(id, "id");

			return this.allWeaponById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Weapon> GetWeapons(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootWeapon;
			else
				return this.allWeapon;
		}
		// Armor -> Id
		public Armor GetArmor(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Armor);
			if (this.allArmorById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find Armor with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasArmor(string id)
		{
			ThrowIfNull(id, "id");

			return this.allArmorById.ContainsKey(id);
		}
		public Armor FindArmor(string id)
		{
			ThrowIfNull(id, "id");

			var value = default(Armor);
			this.allArmorById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetArmor(string id, out Armor value)
		{
			ThrowIfNull(id, "id");

			return this.allArmorById.TryGetValue(id, out value);
		}
		public ReadOnlyList<Armor> GetArmors(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootArmor;
			else
				return this.allArmor;
		}
		// ItemWithCount -> Id
		public ItemWithCount GetItemWithCount(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(ItemWithCount);
			if (this.allItemWithCountById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find ItemWithCount with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasItemWithCount(int id)
		{
			ThrowIfNull(id, "id");

			return this.allItemWithCountById.ContainsKey(id);
		}
		public ItemWithCount FindItemWithCount(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(ItemWithCount);
			this.allItemWithCountById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetItemWithCount(int id, out ItemWithCount value)
		{
			ThrowIfNull(id, "id");

			return this.allItemWithCountById.TryGetValue(id, out value);
		}
		public ReadOnlyList<ItemWithCount> GetItemWithCounts(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootItemWithCount;
			else
				return this.allItemWithCount;
		}
		// StartingSet -> Id
		public StartingSet GetStartingSet(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(StartingSet);
			if (this.allStartingSetById.TryGetValue(id, out value) == false)
				throw new System.ArgumentException(string.Format("Unable find StartingSet with Id '{0}'.", id) ,"id");
			return value;
		}
		public bool HasStartingSet(int id)
		{
			ThrowIfNull(id, "id");

			return this.allStartingSetById.ContainsKey(id);
		}
		public StartingSet FindStartingSet(int id)
		{
			ThrowIfNull(id, "id");

			var value = default(StartingSet);
			this.allStartingSetById.TryGetValue(id, out value);
			return value;
		}
		public bool TryGetStartingSet(int id, out StartingSet value)
		{
			ThrowIfNull(id, "id");

			return this.allStartingSetById.TryGetValue(id, out value);
		}
		public ReadOnlyList<StartingSet> GetStartingSets(bool onlyRoot = false)
		{
			if(onlyRoot)
				return this.rootStartingSet;
			else
				return this.allStartingSet;
		}
		// StartingSet -> Instance
		private StartingSet theStartingSet;
		public StartingSet StartingSet 
		{ 
			get 
			{ 
				if (this.theStartingSet != null)
					return this.theStartingSet;

				switch(this.rootStartingSet.Count)
				{
					case 0: throw new InvalidOperationException("Unable to find StartingSet document. Please create StartingSet document before using this property.");
					case 1: return this.theStartingSet = this.rootStartingSet[0];
					default: throw new InvalidOperationException("There is a multiple variants of StartingSet document. Please remove the excess before using this property.");
				}
			}
		}
		#endregion

		public IEnumerable<Document> GetAllDocuments()
		{
			return this.EnumerateAll();
		}

		public void SetLanguage(string languageId)
		{
			if (languageId == null) throw new ArgumentNullException("languageId");

			foreach(var document in this.EnumerateAll())
				document.SetLanguage(languageId);
		}

		private Document FindDocumentInternal(string entityId, object id)
		{
			if (entityId == null) throw new ArgumentNullException("entityId");

#pragma warning disable 1522 // Empty switch block
			switch (entityId)
			{
				case "ProjectSettings":
				case "55a4f32faca22e191098f3d9": return this.GetProjectSettings((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Parameter":
				case "59f5b0a730bb84165c06b547": return this.GetParameter((ParameterId)(id is ParameterId ? id : ChangeType(id, typeof(ParameterId), System.Globalization.CultureInfo.InvariantCulture)));
				case "ParameterValue":
				case "59f5b11030bb84165c06b54e": return this.GetParameterValue((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "Provision":
				case "59f5b1c830bb84165c06b556": return this.GetProvision((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Hero":
				case "59f5b29330bb84165c06b55c": return this.GetHero((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Item":
				case "59f5b3f130bb84165c06b56b": return this.GetItem((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Location":
				case "59f5b57530bb84165c06b579": return this.GetLocation((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Trinket":
				case "59f5b61630bb84165c06b57f": return this.GetTrinket((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Monster":
				case "59f5b7f330bb84165c06b58a": return this.GetMonster((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Loot":
				case "59f5b9dd30bb84165c06b59a": return this.GetLoot((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "CombatEffect":
				case "59f5baaa30bb84165c06b5a0": return this.GetCombatEffect((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "CurioCleansingOption":
				case "59f5bac130bb84165c06b5a4": return this.GetCurioCleansingOption((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "Curio":
				case "59f5bbc230bb84165c06b5ae": return this.GetCurio((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Disease":
				case "59f5d3a7983a361970003662": return this.GetDisease((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Quirk":
				case "59f5d728983a361970003684": return this.GetQuirk((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Conditions":
				case "59f5dedf983a361970003697": return this.GetConditions((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Weapon":
				case "59f9e745983a364298db5e22": return this.GetWeapon((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "Armor":
				case "59f9e7b6983a364298db5e2c": return this.GetArmor((string)(id is string ? id : ChangeType(id, typeof(string), System.Globalization.CultureInfo.InvariantCulture)));
				case "ItemWithCount":
				case "5a1d78d107ff9a7b889cba7d": return this.GetItemWithCount((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
				case "StartingSet":
				case "5a1d78de07ff9a7b889cba83": return this.GetStartingSet((int)(id is int ? id : ChangeType(id, typeof(int), System.Globalization.CultureInfo.InvariantCulture)));
			}
#pragma warning restore 1522
			throw new System.ArgumentException(string.Format("Unable find Entity with id '{0}'.", entityId) ,"entityId");
		}

		private IEnumerable<Document> EnumerateAll()
		{
			var i = 0;
			var end = 0;
			for (i = 0, end = this.allProjectSettings.Count; i < end; i++)
			{
				yield return this.allProjectSettings[i];
			}
			for (i = 0, end = this.allParameter.Count; i < end; i++)
			{
				yield return this.allParameter[i];
			}
			for (i = 0, end = this.allParameterValue.Count; i < end; i++)
			{
				yield return this.allParameterValue[i];
			}
			for (i = 0, end = this.allProvision.Count; i < end; i++)
			{
				yield return this.allProvision[i];
			}
			for (i = 0, end = this.allHero.Count; i < end; i++)
			{
				yield return this.allHero[i];
			}
			for (i = 0, end = this.allItem.Count; i < end; i++)
			{
				yield return this.allItem[i];
			}
			for (i = 0, end = this.allLocation.Count; i < end; i++)
			{
				yield return this.allLocation[i];
			}
			for (i = 0, end = this.allTrinket.Count; i < end; i++)
			{
				yield return this.allTrinket[i];
			}
			for (i = 0, end = this.allMonster.Count; i < end; i++)
			{
				yield return this.allMonster[i];
			}
			for (i = 0, end = this.allLoot.Count; i < end; i++)
			{
				yield return this.allLoot[i];
			}
			for (i = 0, end = this.allCombatEffect.Count; i < end; i++)
			{
				yield return this.allCombatEffect[i];
			}
			for (i = 0, end = this.allCurioCleansingOption.Count; i < end; i++)
			{
				yield return this.allCurioCleansingOption[i];
			}
			for (i = 0, end = this.allCurio.Count; i < end; i++)
			{
				yield return this.allCurio[i];
			}
			for (i = 0, end = this.allDisease.Count; i < end; i++)
			{
				yield return this.allDisease[i];
			}
			for (i = 0, end = this.allQuirk.Count; i < end; i++)
			{
				yield return this.allQuirk[i];
			}
			for (i = 0, end = this.allConditions.Count; i < end; i++)
			{
				yield return this.allConditions[i];
			}
			for (i = 0, end = this.allWeapon.Count; i < end; i++)
			{
				yield return this.allWeapon[i];
			}
			for (i = 0, end = this.allArmor.Count; i < end; i++)
			{
				yield return this.allArmor[i];
			}
			for (i = 0, end = this.allItemWithCount.Count; i < end; i++)
			{
				yield return this.allItemWithCount[i];
			}
			for (i = 0, end = this.allStartingSet.Count; i < end; i++)
			{
				yield return this.allStartingSet[i];
			}
			yield break;
		}

		private IEnumerable<Document> EnumerateRoots()
		{
			var i = 0;
			var end = 0;
			for (i = 0, end = this.rootProjectSettings.Count; i < end; i++)
			{
				yield return this.rootProjectSettings[i];
			}
			for (i = 0, end = this.rootParameter.Count; i < end; i++)
			{
				yield return this.rootParameter[i];
			}
			for (i = 0, end = this.rootParameterValue.Count; i < end; i++)
			{
				yield return this.rootParameterValue[i];
			}
			for (i = 0, end = this.rootProvision.Count; i < end; i++)
			{
				yield return this.rootProvision[i];
			}
			for (i = 0, end = this.rootHero.Count; i < end; i++)
			{
				yield return this.rootHero[i];
			}
			for (i = 0, end = this.rootItem.Count; i < end; i++)
			{
				yield return this.rootItem[i];
			}
			for (i = 0, end = this.rootLocation.Count; i < end; i++)
			{
				yield return this.rootLocation[i];
			}
			for (i = 0, end = this.rootTrinket.Count; i < end; i++)
			{
				yield return this.rootTrinket[i];
			}
			for (i = 0, end = this.rootMonster.Count; i < end; i++)
			{
				yield return this.rootMonster[i];
			}
			for (i = 0, end = this.rootLoot.Count; i < end; i++)
			{
				yield return this.rootLoot[i];
			}
			for (i = 0, end = this.rootCombatEffect.Count; i < end; i++)
			{
				yield return this.rootCombatEffect[i];
			}
			for (i = 0, end = this.rootCurioCleansingOption.Count; i < end; i++)
			{
				yield return this.rootCurioCleansingOption[i];
			}
			for (i = 0, end = this.rootCurio.Count; i < end; i++)
			{
				yield return this.rootCurio[i];
			}
			for (i = 0, end = this.rootDisease.Count; i < end; i++)
			{
				yield return this.rootDisease[i];
			}
			for (i = 0, end = this.rootQuirk.Count; i < end; i++)
			{
				yield return this.rootQuirk[i];
			}
			for (i = 0, end = this.rootConditions.Count; i < end; i++)
			{
				yield return this.rootConditions[i];
			}
			for (i = 0, end = this.rootWeapon.Count; i < end; i++)
			{
				yield return this.rootWeapon[i];
			}
			for (i = 0, end = this.rootArmor.Count; i < end; i++)
			{
				yield return this.rootArmor[i];
			}
			for (i = 0, end = this.rootItemWithCount.Count; i < end; i++)
			{
				yield return this.rootItemWithCount[i];
			}
			for (i = 0, end = this.rootStartingSet.Count; i < end; i++)
			{
				yield return this.rootStartingSet[i];
			}

			yield break;
		}

		private static void ThrowIfNull<T>(T value, string paramName)
		{
			if (value == null) throw new ArgumentNullException(paramName);
		}

		private static object ChangeType(object value, Type toType, IFormatProvider format)
		{
			if (toType.IsEnum && Enum.GetUnderlyingType(toType) == typeof(ulong))
				return Enum.ToObject(toType, Convert.ToUInt64(value, format));
			if (toType.IsEnum)
				return Enum.ToObject(toType, Convert.ToInt64(value, format));
			else
				return System.Convert.ChangeType(value, toType, format);
		}
		private static ReadOnlyDictionary<KeyT, ValueT> ToDictionarySkippingNullKeys<KeyT, ValueT>(ReadOnlyList<ValueT> list, Func<ValueT, KeyT> keySelector)
			where ValueT : Document
		{
			if (list == null) throw new ArgumentNullException("list");
			if (keySelector == null) throw new ArgumentNullException("keySelector");

			if (list.Count == 0)
				return ReadOnlyDictionary<KeyT, ValueT>.Empty;

			var dictionary = new Dictionary<KeyT, ValueT>(list.Count);
			if (typeof(KeyT).IsValueType)
			{
				for (var i = 0; i < list.Count; i++)
				{
					var value = list[i];
					var key = keySelector(value);
					dictionary[key] = value;
				}
			}
			else
			{
				for (var i = 0; i < list.Count; i++)
				{
					var value = list[i];
					var key = keySelector(value);
					if (Object.ReferenceEquals(key, default(KeyT))) continue;
					dictionary[key] = value;
				}
			}
			return new ReadOnlyDictionary<KeyT, ValueT>(dictionary);
		}


		#region Visitors
		public void ApplyVisitor(Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");
			
			foreach(var document in this.EnumerateRoots())
				document.Apply(visitor);
		}

		private void FindAllDocuments()
		{
			var findingVisitor = new FindingVisitor();
			this.ApplyVisitor(findingVisitor);


			if (findingVisitor.AllProjectSettings != null)
			{
				var list = findingVisitor.AllProjectSettings;
				list.Sort();
				this.allProjectSettings = new ReadOnlyList<ProjectSettings>(list);
			}
			else
			{
				this.allProjectSettings = ReadOnlyList<ProjectSettings>.Empty;
			}

			if (findingVisitor.AllParameter != null)
			{
				var list = findingVisitor.AllParameter;
				list.Sort();
				this.allParameter = new ReadOnlyList<Parameter>(list);
			}
			else
			{
				this.allParameter = ReadOnlyList<Parameter>.Empty;
			}

			if (findingVisitor.AllParameterValue != null)
			{
				var list = findingVisitor.AllParameterValue;
				list.Sort();
				this.allParameterValue = new ReadOnlyList<ParameterValue>(list);
			}
			else
			{
				this.allParameterValue = ReadOnlyList<ParameterValue>.Empty;
			}

			if (findingVisitor.AllProvision != null)
			{
				var list = findingVisitor.AllProvision;
				list.Sort();
				this.allProvision = new ReadOnlyList<Provision>(list);
			}
			else
			{
				this.allProvision = ReadOnlyList<Provision>.Empty;
			}

			if (findingVisitor.AllHero != null)
			{
				var list = findingVisitor.AllHero;
				list.Sort();
				this.allHero = new ReadOnlyList<Hero>(list);
			}
			else
			{
				this.allHero = ReadOnlyList<Hero>.Empty;
			}

			if (findingVisitor.AllItem != null)
			{
				var list = findingVisitor.AllItem;
				list.Sort();
				this.allItem = new ReadOnlyList<Item>(list);
			}
			else
			{
				this.allItem = ReadOnlyList<Item>.Empty;
			}

			if (findingVisitor.AllLocation != null)
			{
				var list = findingVisitor.AllLocation;
				list.Sort();
				this.allLocation = new ReadOnlyList<Location>(list);
			}
			else
			{
				this.allLocation = ReadOnlyList<Location>.Empty;
			}

			if (findingVisitor.AllTrinket != null)
			{
				var list = findingVisitor.AllTrinket;
				list.Sort();
				this.allTrinket = new ReadOnlyList<Trinket>(list);
			}
			else
			{
				this.allTrinket = ReadOnlyList<Trinket>.Empty;
			}

			if (findingVisitor.AllMonster != null)
			{
				var list = findingVisitor.AllMonster;
				list.Sort();
				this.allMonster = new ReadOnlyList<Monster>(list);
			}
			else
			{
				this.allMonster = ReadOnlyList<Monster>.Empty;
			}

			if (findingVisitor.AllLoot != null)
			{
				var list = findingVisitor.AllLoot;
				list.Sort();
				this.allLoot = new ReadOnlyList<Loot>(list);
			}
			else
			{
				this.allLoot = ReadOnlyList<Loot>.Empty;
			}

			if (findingVisitor.AllCombatEffect != null)
			{
				var list = findingVisitor.AllCombatEffect;
				list.Sort();
				this.allCombatEffect = new ReadOnlyList<CombatEffect>(list);
			}
			else
			{
				this.allCombatEffect = ReadOnlyList<CombatEffect>.Empty;
			}

			if (findingVisitor.AllCurioCleansingOption != null)
			{
				var list = findingVisitor.AllCurioCleansingOption;
				list.Sort();
				this.allCurioCleansingOption = new ReadOnlyList<CurioCleansingOption>(list);
			}
			else
			{
				this.allCurioCleansingOption = ReadOnlyList<CurioCleansingOption>.Empty;
			}

			if (findingVisitor.AllCurio != null)
			{
				var list = findingVisitor.AllCurio;
				list.Sort();
				this.allCurio = new ReadOnlyList<Curio>(list);
			}
			else
			{
				this.allCurio = ReadOnlyList<Curio>.Empty;
			}

			if (findingVisitor.AllDisease != null)
			{
				var list = findingVisitor.AllDisease;
				list.Sort();
				this.allDisease = new ReadOnlyList<Disease>(list);
			}
			else
			{
				this.allDisease = ReadOnlyList<Disease>.Empty;
			}

			if (findingVisitor.AllQuirk != null)
			{
				var list = findingVisitor.AllQuirk;
				list.Sort();
				this.allQuirk = new ReadOnlyList<Quirk>(list);
			}
			else
			{
				this.allQuirk = ReadOnlyList<Quirk>.Empty;
			}

			if (findingVisitor.AllConditions != null)
			{
				var list = findingVisitor.AllConditions;
				list.Sort();
				this.allConditions = new ReadOnlyList<Conditions>(list);
			}
			else
			{
				this.allConditions = ReadOnlyList<Conditions>.Empty;
			}

			if (findingVisitor.AllWeapon != null)
			{
				var list = findingVisitor.AllWeapon;
				list.Sort();
				this.allWeapon = new ReadOnlyList<Weapon>(list);
			}
			else
			{
				this.allWeapon = ReadOnlyList<Weapon>.Empty;
			}

			if (findingVisitor.AllArmor != null)
			{
				var list = findingVisitor.AllArmor;
				list.Sort();
				this.allArmor = new ReadOnlyList<Armor>(list);
			}
			else
			{
				this.allArmor = ReadOnlyList<Armor>.Empty;
			}

			if (findingVisitor.AllItemWithCount != null)
			{
				var list = findingVisitor.AllItemWithCount;
				list.Sort();
				this.allItemWithCount = new ReadOnlyList<ItemWithCount>(list);
			}
			else
			{
				this.allItemWithCount = ReadOnlyList<ItemWithCount>.Empty;
			}

			if (findingVisitor.AllStartingSet != null)
			{
				var list = findingVisitor.AllStartingSet;
				list.Sort();
				this.allStartingSet = new ReadOnlyList<StartingSet>(list);
			}
			else
			{
				this.allStartingSet = ReadOnlyList<StartingSet>.Empty;
			}
		}

		public class Visitor
		{
			public virtual void Visit(ProjectSettings value)
			{
			}
			public virtual void Visit(Parameter value)
			{
			}
			public virtual void Visit(ParameterValue value)
			{
			}
			public virtual void Visit(Provision value)
			{
			}
			public virtual void Visit(Hero value)
			{
			}
			public virtual void Visit(Item value)
			{
			}
			public virtual void Visit(Location value)
			{
			}
			public virtual void Visit(Trinket value)
			{
			}
			public virtual void Visit(Monster value)
			{
			}
			public virtual void Visit(Loot value)
			{
			}
			public virtual void Visit(CombatEffect value)
			{
			}
			public virtual void Visit(CurioCleansingOption value)
			{
			}
			public virtual void Visit(Curio value)
			{
			}
			public virtual void Visit(Disease value)
			{
			}
			public virtual void Visit(Quirk value)
			{
			}
			public virtual void Visit(Conditions value)
			{
			}
			public virtual void Visit(Weapon value)
			{
			}
			public virtual void Visit(Armor value)
			{
			}
			public virtual void Visit(ItemWithCount value)
			{
			}
			public virtual void Visit(StartingSet value)
			{
			}
		}

		private class FindingVisitor : Visitor
		{
			public List<ProjectSettings> AllProjectSettings;
			public List<Parameter> AllParameter;
			public List<ParameterValue> AllParameterValue;
			public List<Provision> AllProvision;
			public List<Hero> AllHero;
			public List<Item> AllItem;
			public List<Location> AllLocation;
			public List<Trinket> AllTrinket;
			public List<Monster> AllMonster;
			public List<Loot> AllLoot;
			public List<CombatEffect> AllCombatEffect;
			public List<CurioCleansingOption> AllCurioCleansingOption;
			public List<Curio> AllCurio;
			public List<Disease> AllDisease;
			public List<Quirk> AllQuirk;
			public List<Conditions> AllConditions;
			public List<Weapon> AllWeapon;
			public List<Armor> AllArmor;
			public List<ItemWithCount> AllItemWithCount;
			public List<StartingSet> AllStartingSet;
		
			public override void Visit(ProjectSettings value) 
			{ 
				if (this.AllProjectSettings == null)
					this.AllProjectSettings = new List<ProjectSettings>(6);

				this.AllProjectSettings.Add(value); 
			}
			public override void Visit(Parameter value) 
			{ 
				if (this.AllParameter == null)
					this.AllParameter = new List<Parameter>(44);

				this.AllParameter.Add(value); 
			}
			public override void Visit(ParameterValue value) 
			{ 
				if (this.AllParameterValue == null)
					this.AllParameterValue = new List<ParameterValue>(82);

				this.AllParameterValue.Add(value); 
			}
			public override void Visit(Provision value) 
			{ 
				if (this.AllProvision == null)
					this.AllProvision = new List<Provision>(15);

				this.AllProvision.Add(value); 
			}
			public override void Visit(Hero value) 
			{ 
				if (this.AllHero == null)
					this.AllHero = new List<Hero>(8);

				this.AllHero.Add(value); 
			}
			public override void Visit(Item value) 
			{ 
				if (this.AllItem == null)
					this.AllItem = new List<Item>(46);

				this.AllItem.Add(value); 
			}
			public override void Visit(Location value) 
			{ 
				if (this.AllLocation == null)
					this.AllLocation = new List<Location>(12);

				this.AllLocation.Add(value); 
			}
			public override void Visit(Trinket value) 
			{ 
				if (this.AllTrinket == null)
					this.AllTrinket = new List<Trinket>(11);

				this.AllTrinket.Add(value); 
			}
			public override void Visit(Monster value) 
			{ 
				if (this.AllMonster == null)
					this.AllMonster = new List<Monster>(11);

				this.AllMonster.Add(value); 
			}
			public override void Visit(Loot value) 
			{ 
				if (this.AllLoot == null)
					this.AllLoot = new List<Loot>(16);

				this.AllLoot.Add(value); 
			}
			public override void Visit(CombatEffect value) 
			{ 
				if (this.AllCombatEffect == null)
					this.AllCombatEffect = new List<CombatEffect>(50);

				this.AllCombatEffect.Add(value); 
			}
			public override void Visit(CurioCleansingOption value) 
			{ 
				if (this.AllCurioCleansingOption == null)
					this.AllCurioCleansingOption = new List<CurioCleansingOption>(19);

				this.AllCurioCleansingOption.Add(value); 
			}
			public override void Visit(Curio value) 
			{ 
				if (this.AllCurio == null)
					this.AllCurio = new List<Curio>(10);

				this.AllCurio.Add(value); 
			}
			public override void Visit(Disease value) 
			{ 
				if (this.AllDisease == null)
					this.AllDisease = new List<Disease>(11);

				this.AllDisease.Add(value); 
			}
			public override void Visit(Quirk value) 
			{ 
				if (this.AllQuirk == null)
					this.AllQuirk = new List<Quirk>(13);

				this.AllQuirk.Add(value); 
			}
			public override void Visit(Conditions value) 
			{ 
				if (this.AllConditions == null)
					this.AllConditions = new List<Conditions>(23);

				this.AllConditions.Add(value); 
			}
			public override void Visit(Weapon value) 
			{ 
				if (this.AllWeapon == null)
					this.AllWeapon = new List<Weapon>(20);

				this.AllWeapon.Add(value); 
			}
			public override void Visit(Armor value) 
			{ 
				if (this.AllArmor == null)
					this.AllArmor = new List<Armor>(20);

				this.AllArmor.Add(value); 
			}
			public override void Visit(ItemWithCount value) 
			{ 
				if (this.AllItemWithCount == null)
					this.AllItemWithCount = new List<ItemWithCount>(10);

				this.AllItemWithCount.Add(value); 
			}
			public override void Visit(StartingSet value) 
			{ 
				if (this.AllStartingSet == null)
					this.AllStartingSet = new List<StartingSet>(6);

				this.AllStartingSet.Add(value); 
			}
		}
		#endregion

		#region Serialization


		#region Serialization: Common Types
		private static readonly IFormatProvider FormatProvider = System.Globalization.CultureInfo.InvariantCulture;
		private const string DateTimeFormat = "o";

		private static readonly StringLookupTable SharedStringsLookupTable = null;

		public enum Format
		{
			Json,
			Bson,
			Xml,
			MessagePack
		}

		private abstract class Reader
		{
			protected readonly StringLookupTable stringLookupTable = SharedStringsLookupTable;

			public abstract ReaderNode Node { get; }

			public abstract int LineNumber { get; }
			public abstract int ColumnNumber { get; }

			public abstract bool NextToken();

			public void ReadGameData(RpgGameData gameData, Dictionary<string, object> patch = null)
			{
				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var memberName = this.ReadMember();
					switch(memberName)
					{
						case "ChangeNumber":
							gameData.changeNumber = (Int32)this.Node.AsInt32;
							this.NextToken();
						break;
						case "Collections":
							var collectionPatch = GetDocument(patch, "Collections");
							this.ReadObjectBegin();
							while(this.Node.Token != ReaderToken.EndOfObject)
							{
								var collectionName = this.ReadMember();
								switch (collectionName.Length)
								{
									case 4:
										switch(collectionName)
										{
											case "Hero":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var heroPatch = GetDocumentCollection(collectionPatch, "Hero") ?? GetDocumentCollection(collectionPatch, "59f5b29330bb84165c06b55c");

												gameData.rootHero = this.ReadHeroCollection(heroPatch, 3, isRootCollection: true);
												break;
											}
											case "Item":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var itemPatch = GetDocumentCollection(collectionPatch, "Item") ?? GetDocumentCollection(collectionPatch, "59f5b3f130bb84165c06b56b");

												gameData.rootItem = this.ReadItemCollection(itemPatch, 25, isRootCollection: true);
												break;
											}
											case "Loot":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var lootPatch = GetDocumentCollection(collectionPatch, "Loot") ?? GetDocumentCollection(collectionPatch, "59f5b9dd30bb84165c06b59a");

												gameData.rootLoot = this.ReadLootCollection(lootPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 5:
										switch(collectionName)
										{
											case "Curio":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var curioPatch = GetDocumentCollection(collectionPatch, "Curio") ?? GetDocumentCollection(collectionPatch, "59f5bbc230bb84165c06b5ae");

												gameData.rootCurio = this.ReadCurioCollection(curioPatch, 5, isRootCollection: true);
												break;
											}
											case "Quirk":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var quirkPatch = GetDocumentCollection(collectionPatch, "Quirk") ?? GetDocumentCollection(collectionPatch, "59f5d728983a361970003684");

												gameData.rootQuirk = this.ReadQuirkCollection(quirkPatch, 8, isRootCollection: true);
												break;
											}
											case "Armor":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var armorPatch = GetDocumentCollection(collectionPatch, "Armor") ?? GetDocumentCollection(collectionPatch, "59f9e7b6983a364298db5e2c");

												gameData.rootArmor = this.ReadArmorCollection(armorPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 6:
										switch(collectionName)
										{
											case "Weapon":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var weaponPatch = GetDocumentCollection(collectionPatch, "Weapon") ?? GetDocumentCollection(collectionPatch, "59f9e745983a364298db5e22");

												gameData.rootWeapon = this.ReadWeaponCollection(weaponPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 7:
										switch(collectionName)
										{
											case "Trinket":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var trinketPatch = GetDocumentCollection(collectionPatch, "Trinket") ?? GetDocumentCollection(collectionPatch, "59f5b61630bb84165c06b57f");

												gameData.rootTrinket = this.ReadTrinketCollection(trinketPatch, 6, isRootCollection: true);
												break;
											}
											case "Monster":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var monsterPatch = GetDocumentCollection(collectionPatch, "Monster") ?? GetDocumentCollection(collectionPatch, "59f5b7f330bb84165c06b58a");

												gameData.rootMonster = this.ReadMonsterCollection(monsterPatch, 6, isRootCollection: true);
												break;
											}
											case "Disease":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var diseasePatch = GetDocumentCollection(collectionPatch, "Disease") ?? GetDocumentCollection(collectionPatch, "59f5d3a7983a361970003662");

												gameData.rootDisease = this.ReadDiseaseCollection(diseasePatch, 6, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 8:
										switch(collectionName)
										{
											case "Location":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var locationPatch = GetDocumentCollection(collectionPatch, "Location") ?? GetDocumentCollection(collectionPatch, "59f5b57530bb84165c06b579");

												gameData.rootLocation = this.ReadLocationCollection(locationPatch, 7, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 9:
										switch(collectionName)
										{
											case "Parameter":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var parameterPatch = GetDocumentCollection(collectionPatch, "Parameter") ?? GetDocumentCollection(collectionPatch, "59f5b0a730bb84165c06b547");

												gameData.rootParameter = this.ReadParameterCollection(parameterPatch, 39, isRootCollection: true);
												break;
											}
											case "Provision":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var provisionPatch = GetDocumentCollection(collectionPatch, "Provision") ?? GetDocumentCollection(collectionPatch, "59f5b1c830bb84165c06b556");

												gameData.rootProvision = this.ReadProvisionCollection(provisionPatch, 10, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 10:
										switch(collectionName)
										{
											case "Conditions":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var conditionsPatch = GetDocumentCollection(collectionPatch, "Conditions") ?? GetDocumentCollection(collectionPatch, "59f5dedf983a361970003697");

												gameData.rootConditions = this.ReadConditionsCollection(conditionsPatch, 18, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 11:
										switch(collectionName)
										{
											case "StartingSet":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var startingSetPatch = GetDocumentCollection(collectionPatch, "StartingSet") ?? GetDocumentCollection(collectionPatch, "5a1d78de07ff9a7b889cba83");

												gameData.rootStartingSet = this.ReadStartingSetCollection(startingSetPatch, 1, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 12:
										switch(collectionName)
										{
											case "CombatEffect":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var combatEffectPatch = GetDocumentCollection(collectionPatch, "CombatEffect") ?? GetDocumentCollection(collectionPatch, "59f5baaa30bb84165c06b5a0");

												gameData.rootCombatEffect = this.ReadCombatEffectCollection(combatEffectPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 13:
										switch(collectionName)
										{
											case "ItemWithCount":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var itemWithCountPatch = GetDocumentCollection(collectionPatch, "ItemWithCount") ?? GetDocumentCollection(collectionPatch, "5a1d78d107ff9a7b889cba7d");

												gameData.rootItemWithCount = this.ReadItemWithCountCollection(itemWithCountPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 14:
										switch(collectionName)
										{
											case "ParameterValue":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var parameterValuePatch = GetDocumentCollection(collectionPatch, "ParameterValue") ?? GetDocumentCollection(collectionPatch, "59f5b11030bb84165c06b54e");

												gameData.rootParameterValue = this.ReadParameterValueCollection(parameterValuePatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 15:
										switch(collectionName)
										{
											case "ProjectSettings":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var projectSettingsPatch = GetDocumentCollection(collectionPatch, "ProjectSettings") ?? GetDocumentCollection(collectionPatch, "55a4f32faca22e191098f3d9");

												gameData.rootProjectSettings = this.ReadProjectSettingsCollection(projectSettingsPatch, 1, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									case 20:
										switch(collectionName)
										{
											case "CurioCleansingOption":
											{
												if (this.IsNull())
												{
													this.NextToken();
													break;
												}
												var curioCleansingOptionPatch = GetDocumentCollection(collectionPatch, "CurioCleansingOption") ?? GetDocumentCollection(collectionPatch, "59f5bac130bb84165c06b5a4");

												gameData.rootCurioCleansingOption = this.ReadCurioCleansingOptionCollection(curioCleansingOptionPatch, 100, isRootCollection: true);
												break;
											}
											default:
												this.ReadAny();
												break;
										}
										break;
									default:
										this.ReadAny();
										break;
								}
							}
							this.ReadObjectEnd();
							return;
						default:
							this.ReadAny();
							break;
					}
				}

				this.ReadObjectEnd();

				// update language list
				var projectSettings = gameData.rootProjectSettings.FirstOrDefault();
				if (projectSettings != null && string.IsNullOrEmpty(projectSettings.Languages) == false)
				{
						var languages = new List<String>(projectSettings.Languages.Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries));
						if (string.IsNullOrEmpty(projectSettings.PrimaryLanguage) == false)
						{
							gameData.primaryLanguage = projectSettings.PrimaryLanguage;
						}
						else if (languages.Count > 0)
						{
							gameData.primaryLanguage = languages[0];
						}
						else
						{
							gameData.primaryLanguage = "EN-US";
						}
						languages.Remove(projectSettings.PrimaryLanguage);
						languages.Add(projectSettings.PrimaryLanguage);
						languages.Sort(StringComparer.OrdinalIgnoreCase);

						gameData.languages = new ReadOnlyCollection<String>(languages);
				}
			}

			private ReadOnlyList<ProjectSettings> ReadProjectSettingsCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<ProjectSettings>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadProjectSettings(collectionPatch);
					if (collection == null) { collection = new List<ProjectSettings>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, ProjectSettings>(collection, collectionPatch, d => CreateProjectSettings(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<ProjectSettings>.Create(collection);
			}
			private ProjectSettings CreateProjectSettings(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = GetAndCovertValue<string>(values, "Name");
				var _primaryLanguage_ = GetAndCovertValue<string>(values, "PrimaryLanguage");
				var _languages_ = GetAndCovertValue<string>(values, "Languages");
				var _copyright_ = GetAndCovertValue<string>(values, "Copyright");

				return new ProjectSettings(_id_, _name_, _primaryLanguage_, _languages_, _copyright_);
			}
			private ProjectSettings ReadProjectSettings(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(string);
				var _primaryLanguage_ = default(string);
				var _languages_ = default(string);
				var _copyright_ = default(string);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "ProjectSettings");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of Text type", "Name", "ProjectSettings");

									this.ThrowIfNotValue();

									_name_ = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Languages":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_languages_ = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								case "Copyright":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_copyright_ = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 15:
						{
							switch (attributeName)
							{
								case "PrimaryLanguage":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_primaryLanguage_ = (string)this.Node.AsString;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "PrimaryLanguage", ref _primaryLanguage_);
					PatchValue(documentPatch, "Languages", ref _languages_);
					PatchValue(documentPatch, "Copyright", ref _copyright_);
				}

				return new ProjectSettings(_id_, _name_, _primaryLanguage_, _languages_, _copyright_);
			}

			private ReadOnlyList<Parameter> ReadParameterCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Parameter>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadParameter(collectionPatch);
					if (collection == null) { collection = new List<Parameter>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<ParameterId, Parameter>(collection, collectionPatch, d => CreateParameter(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Parameter>.Create(collection);
			}
			private Parameter CreateParameter(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = (ParameterId)GetAndCovertValue<ParameterId>(values, "Id");
				var _minValue_ = GetAndCovertValue<Nullable<float>>(values, "MinValue");
				var _maxValue_ = GetAndCovertValue<Nullable<float>>(values, "MaxValue");
				var _minValueParameter_ = DocumentReference<Parameter>.Create(GetDocument(values, "MinValueParameter"));
				var _maxValueParameter_ = DocumentReference<Parameter>.Create(GetDocument(values, "MaxValueParameter"));
				var _valueKind_ = (ParameterValueKind)GetAndCovertValue<ParameterValueKind>(values, "ValueKind");

				return new Parameter(_id_, _minValue_, _maxValue_, _minValueParameter_, _maxValueParameter_, _valueKind_);
			}
			private Parameter ReadParameter(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(ParameterId);
				var _minValue_ = default(Nullable<float>);
				var _maxValue_ = default(Nullable<float>);
				var _minValueParameter_ = default(DocumentReference<Parameter>);
				var _maxValueParameter_ = default(DocumentReference<Parameter>);
				var _valueKind_ = default(ParameterValueKind);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of PickList type", "Id", "Parameter");

									this.ThrowIfNotValue();

									_id_ = (ParameterId)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 8:
						{
							switch (attributeName)
							{
								case "MinValue":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_minValue_ = (Nullable<float>)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								case "MaxValue":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_maxValue_ = (Nullable<float>)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "ValueKind":
								{
									this.ThrowIfNull("value of PickList type", "ValueKind", "Parameter");

									this.ThrowIfNotValue();

									_valueKind_ = (ParameterValueKind)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 17:
						{
							switch (attributeName)
							{
								case "MinValueParameter":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_minValueParameter_ = this.ReadReference<Parameter>();

									break;
								}
								case "MaxValueParameter":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_maxValueParameter_ = this.ReadReference<Parameter>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "MinValue", ref _minValue_);
					PatchValue(documentPatch, "MaxValue", ref _maxValue_);
					PatchReference(documentPatch, "MinValueParameter", ref _minValueParameter_);
					PatchReference(documentPatch, "MaxValueParameter", ref _maxValueParameter_);
					PatchValue(documentPatch, "ValueKind", ref _valueKind_);
				}

				return new Parameter(_id_, _minValue_, _maxValue_, _minValueParameter_, _maxValueParameter_, _valueKind_);
			}

			private ReadOnlyList<ParameterValue> ReadParameterValueCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<ParameterValue>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadParameterValue(collectionPatch);
					if (collection == null) { collection = new List<ParameterValue>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, ParameterValue>(collection, collectionPatch, d => CreateParameterValue(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<ParameterValue>.Create(collection);
			}
			private ParameterValue CreateParameterValue(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _parameter_ = DocumentReference<Parameter>.Create(GetDocument(values, "Parameter"));
				var _value_ = GetAndCovertValue<float>(values, "Value");
				var _condition_ = DocumentReference<Conditions>.Create(GetDocument(values, "Condition"));

				return new ParameterValue(_id_, _parameter_, _value_, _condition_);
			}
			private ParameterValue ReadParameterValue(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _parameter_ = default(DocumentReference<Parameter>);
				var _value_ = default(float);
				var _condition_ = default(DocumentReference<Conditions>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "ParameterValue");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Value":
								{
									this.ThrowIfNull("value of Number type", "Value", "ParameterValue");

									this.ThrowIfNotValue();

									_value_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Parameter":
								{
									this.ThrowIfNull("value of Reference type", "Parameter", "ParameterValue");

									_parameter_ = this.ReadReference<Parameter>();

									break;
								}
								case "Condition":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_condition_ = this.ReadReference<Conditions>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchReference(documentPatch, "Parameter", ref _parameter_);
					PatchValue(documentPatch, "Value", ref _value_);
					PatchReference(documentPatch, "Condition", ref _condition_);
				}

				return new ParameterValue(_id_, _parameter_, _value_, _condition_);
			}

			private ReadOnlyList<Provision> ReadProvisionCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Provision>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadProvision(collectionPatch);
					if (collection == null) { collection = new List<Provision>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Provision>(collection, collectionPatch, d => CreateProvision(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Provision>.Create(collection);
			}
			private Provision CreateProvision(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _cost_ = GetAndCovertValue<int>(values, "Cost");
				var _item_ = CreateItem(GetDocument(values, "Item"));

				return new Provision(_id_, _cost_, _item_);
			}
			private Provision ReadProvision(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _cost_ = default(int);
				var _item_ = default(Item);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Provision");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Cost":
								{
									this.ThrowIfNull("value of Integer type", "Cost", "Provision");

									this.ThrowIfNotValue();

									_cost_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "Item":
								{
									this.ThrowIfNull("value of Document type", "Item", "Provision");

									var documentPatchObj = default(object);
									if (documentPatch != null && documentPatch.TryGetValue("Item", out documentPatchObj) && documentPatchObj == null)
									{
										this.ReadAny(); // skip because it was removed in patch
									}
									else
									{
										_item_ = this.ReadItem(documentPatchObj as Dictionary<string, object>);
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Cost", ref _cost_);
				}

				return new Provision(_id_, _cost_, _item_);
			}

			private ReadOnlyList<Hero> ReadHeroCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Hero>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadHero(collectionPatch);
					if (collection == null) { collection = new List<Hero>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Hero>(collection, collectionPatch, d => CreateHero(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Hero>.Create(collection);
			}
			private Hero CreateHero(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _bio_ = LocalizedString.Create(GetDocument(values, "Bio"));
				var _religious_ = GetAndCovertValue<bool>(values, "Religious");
				var _dislikeHeroes_Collection_ = GetDocumentCollection(values, "DislikeHeroes").Values.OfType<Dictionary<string, object>>().Select(DocumentReference<Hero>.Create).ToList();
				var _dislikeHeroes_ = ReadOnlyList<DocumentReference<Hero>>.Create(_dislikeHeroes_Collection_);
				var _provisions_ = DocumentReference<Provision>.Create(GetDocument(values, "Provisions"));
				var _provisionsCount_ = GetAndCovertValue<int>(values, "ProvisionsCount");
				var _movementForward_ = GetAndCovertValue<int>(values, "MovementForward");
				var _movementBackward_ = GetAndCovertValue<int>(values, "MovementBackward");
				var _protection_ = GetAndCovertValue<int>(values, "Protection");
				var _accuracyModifier_ = GetAndCovertValue<int>(values, "AccuracyModifier");
				var _stunResistance_ = GetAndCovertValue<float>(values, "StunResistance");
				var _blightResistance_ = GetAndCovertValue<float>(values, "BlightResistance");
				var _diseaseResistance_ = GetAndCovertValue<float>(values, "DiseaseResistance");
				var _deathBlowResistance_ = GetAndCovertValue<float>(values, "DeathBlowResistance");
				var _moveResistance_ = GetAndCovertValue<float>(values, "MoveResistance");
				var _bleedResistance_ = GetAndCovertValue<float>(values, "BleedResistance");
				var _debuffResistance_ = GetAndCovertValue<float>(values, "DebuffResistance");
				var _trapResistance_ = GetAndCovertValue<float>(values, "TrapResistance");
				var _armors_Collection_ = GetDocumentCollection(values, "Armors").Values.OfType<Dictionary<string, object>>().Select(CreateArmor).ToList();
				var _armors_ = ReadOnlyList<Armor>.Create(_armors_Collection_);
				var _weapons_Collection_ = GetDocumentCollection(values, "Weapons").Values.OfType<Dictionary<string, object>>().Select(CreateWeapon).ToList();
				var _weapons_ = ReadOnlyList<Weapon>.Create(_weapons_Collection_);

				return new Hero(_id_, _name_, _bio_, _religious_, _dislikeHeroes_, _provisions_, _provisionsCount_, _movementForward_, _movementBackward_, _protection_, _accuracyModifier_, _stunResistance_, _blightResistance_, _diseaseResistance_, _deathBlowResistance_, _moveResistance_, _bleedResistance_, _debuffResistance_, _trapResistance_, _armors_, _weapons_);
			}
			private Hero ReadHero(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _bio_ = default(LocalizedString);
				var _religious_ = default(bool);
				var _dislikeHeroes_ = default(ReadOnlyList<DocumentReference<Hero>>);
				var _provisions_ = default(DocumentReference<Provision>);
				var _provisionsCount_ = default(int);
				var _movementForward_ = default(int);
				var _movementBackward_ = default(int);
				var _protection_ = default(int);
				var _accuracyModifier_ = default(int);
				var _stunResistance_ = default(float);
				var _blightResistance_ = default(float);
				var _diseaseResistance_ = default(float);
				var _deathBlowResistance_ = default(float);
				var _moveResistance_ = default(float);
				var _bleedResistance_ = default(float);
				var _debuffResistance_ = default(float);
				var _trapResistance_ = default(float);
				var _armors_ = default(ReadOnlyList<Armor>);
				var _weapons_ = default(ReadOnlyList<Weapon>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Hero");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 3:
						{
							switch (attributeName)
							{
								case "Bio":
								{
									this.ThrowIfNull("value of LocalizedText type", "Bio", "Hero");

									_bio_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Hero");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 6:
						{
							switch (attributeName)
							{
								case "Armors":
								{
									this.ThrowIfNull("value of DocumentList type", "Armors", "Hero");

									_armors_ = ReadArmorCollection(collectionPatch: GetDocumentCollection(documentPatch, "Armors"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Weapons":
								{
									this.ThrowIfNull("value of DocumentList type", "Weapons", "Hero");

									_weapons_ = ReadWeaponCollection(collectionPatch: GetDocumentCollection(documentPatch, "Weapons"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Religious":
								{
									this.ThrowIfNull("value of Logical type", "Religious", "Hero");

									this.ThrowIfNotValue();

									_religious_ = (bool)this.Node.AsBoolean;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 10:
						{
							switch (attributeName)
							{
								case "Provisions":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_provisions_ = this.ReadReference<Provision>();

									break;
								}
								case "Protection":
								{
									this.ThrowIfNull("value of Integer type", "Protection", "Hero");

									this.ThrowIfNotValue();

									_protection_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 13:
						{
							switch (attributeName)
							{
								case "DislikeHeroes":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_dislikeHeroes_ = ReadReferenceCollection<Hero>();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 14:
						{
							switch (attributeName)
							{
								case "StunResistance":
								{
									this.ThrowIfNull("value of Number type", "StunResistance", "Hero");

									this.ThrowIfNotValue();

									_stunResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								case "MoveResistance":
								{
									this.ThrowIfNull("value of Number type", "MoveResistance", "Hero");

									this.ThrowIfNotValue();

									_moveResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								case "TrapResistance":
								{
									this.ThrowIfNull("value of Number type", "TrapResistance", "Hero");

									this.ThrowIfNotValue();

									_trapResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 15:
						{
							switch (attributeName)
							{
								case "ProvisionsCount":
								{
									this.ThrowIfNull("value of Integer type", "ProvisionsCount", "Hero");

									this.ThrowIfNotValue();

									_provisionsCount_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "MovementForward":
								{
									this.ThrowIfNull("value of Integer type", "MovementForward", "Hero");

									this.ThrowIfNotValue();

									_movementForward_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "BleedResistance":
								{
									this.ThrowIfNull("value of Number type", "BleedResistance", "Hero");

									this.ThrowIfNotValue();

									_bleedResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 16:
						{
							switch (attributeName)
							{
								case "MovementBackward":
								{
									this.ThrowIfNull("value of Integer type", "MovementBackward", "Hero");

									this.ThrowIfNotValue();

									_movementBackward_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "AccuracyModifier":
								{
									this.ThrowIfNull("value of Integer type", "AccuracyModifier", "Hero");

									this.ThrowIfNotValue();

									_accuracyModifier_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "BlightResistance":
								{
									this.ThrowIfNull("value of Number type", "BlightResistance", "Hero");

									this.ThrowIfNotValue();

									_blightResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								case "DebuffResistance":
								{
									this.ThrowIfNull("value of Number type", "DebuffResistance", "Hero");

									this.ThrowIfNotValue();

									_debuffResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 17:
						{
							switch (attributeName)
							{
								case "DiseaseResistance":
								{
									this.ThrowIfNull("value of Number type", "DiseaseResistance", "Hero");

									this.ThrowIfNotValue();

									_diseaseResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 19:
						{
							switch (attributeName)
							{
								case "DeathBlowResistance":
								{
									this.ThrowIfNull("value of Number type", "DeathBlowResistance", "Hero");

									this.ThrowIfNotValue();

									_deathBlowResistance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchLocalizedString(documentPatch, "Bio", ref _bio_);
					PatchValue(documentPatch, "Religious", ref _religious_);
					PatchReferenceCollection(documentPatch, "DislikeHeroes", ref _dislikeHeroes_);
					PatchReference(documentPatch, "Provisions", ref _provisions_);
					PatchValue(documentPatch, "ProvisionsCount", ref _provisionsCount_);
					PatchValue(documentPatch, "MovementForward", ref _movementForward_);
					PatchValue(documentPatch, "MovementBackward", ref _movementBackward_);
					PatchValue(documentPatch, "Protection", ref _protection_);
					PatchValue(documentPatch, "AccuracyModifier", ref _accuracyModifier_);
					PatchValue(documentPatch, "StunResistance", ref _stunResistance_);
					PatchValue(documentPatch, "BlightResistance", ref _blightResistance_);
					PatchValue(documentPatch, "DiseaseResistance", ref _diseaseResistance_);
					PatchValue(documentPatch, "DeathBlowResistance", ref _deathBlowResistance_);
					PatchValue(documentPatch, "MoveResistance", ref _moveResistance_);
					PatchValue(documentPatch, "BleedResistance", ref _bleedResistance_);
					PatchValue(documentPatch, "DebuffResistance", ref _debuffResistance_);
					PatchValue(documentPatch, "TrapResistance", ref _trapResistance_);
				}

				return new Hero(_id_, _name_, _bio_, _religious_, _dislikeHeroes_, _provisions_, _provisionsCount_, _movementForward_, _movementBackward_, _protection_, _accuracyModifier_, _stunResistance_, _blightResistance_, _diseaseResistance_, _deathBlowResistance_, _moveResistance_, _bleedResistance_, _debuffResistance_, _trapResistance_, _armors_, _weapons_);
			}

			private ReadOnlyList<Item> ReadItemCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Item>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadItem(collectionPatch);
					if (collection == null) { collection = new List<Item>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Item>(collection, collectionPatch, d => CreateItem(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Item>.Create(collection);
			}
			private Item CreateItem(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _description_ = LocalizedString.Create(GetDocument(values, "Description"));
				var _stackSize_ = GetAndCovertValue<int>(values, "StackSize");
				var _goldValue_ = GetAndCovertValue<int>(values, "GoldValue");
				var _activationEffects_Collection_ = GetDocumentCollection(values, "ActivationEffects").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _activationEffects_ = ReadOnlyList<ParameterValue>.Create(_activationEffects_Collection_);

				return new Item(_id_, _name_, _description_, _stackSize_, _goldValue_, _activationEffects_);
			}
			private Item ReadItem(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _description_ = default(LocalizedString);
				var _stackSize_ = default(int);
				var _goldValue_ = default(int);
				var _activationEffects_ = default(ReadOnlyList<ParameterValue>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Item");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Item");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "StackSize":
								{
									this.ThrowIfNull("value of Integer type", "StackSize", "Item");

									this.ThrowIfNotValue();

									_stackSize_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "GoldValue":
								{
									this.ThrowIfNull("value of Integer type", "GoldValue", "Item");

									this.ThrowIfNotValue();

									_goldValue_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 11:
						{
							switch (attributeName)
							{
								case "Description":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_description_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 17:
						{
							switch (attributeName)
							{
								case "ActivationEffects":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_activationEffects_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "ActivationEffects"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchLocalizedString(documentPatch, "Description", ref _description_);
					PatchValue(documentPatch, "StackSize", ref _stackSize_);
					PatchValue(documentPatch, "GoldValue", ref _goldValue_);
				}

				return new Item(_id_, _name_, _description_, _stackSize_, _goldValue_, _activationEffects_);
			}

			private ReadOnlyList<Location> ReadLocationCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Location>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadLocation(collectionPatch);
					if (collection == null) { collection = new List<Location>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Location>(collection, collectionPatch, d => CreateLocation(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Location>.Create(collection);
			}
			private Location CreateLocation(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _flags_ = (Nullable<LocationFlags>)GetAndCovertValue<Nullable<LocationFlags>>(values, "Flags");

				return new Location(_id_, _name_, _flags_);
			}
			private Location ReadLocation(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _flags_ = default(Nullable<LocationFlags>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Location");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Location");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Flags":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_flags_ = (Nullable<LocationFlags>)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "Flags", ref _flags_);
				}

				return new Location(_id_, _name_, _flags_);
			}

			private ReadOnlyList<Trinket> ReadTrinketCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Trinket>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadTrinket(collectionPatch);
					if (collection == null) { collection = new List<Trinket>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Trinket>(collection, collectionPatch, d => CreateTrinket(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Trinket>.Create(collection);
			}
			private Trinket CreateTrinket(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _rarity_ = (TrinketRarity)GetAndCovertValue<TrinketRarity>(values, "Rarity");
				var _originDungeon_ = DocumentReference<Location>.Create(GetDocument(values, "OriginDungeon"));
				var _heroRestriction_ = DocumentReference<Hero>.Create(GetDocument(values, "HeroRestriction"));
				var _item_ = CreateItem(GetDocument(values, "Item"));
				var _effects_Collection_ = GetDocumentCollection(values, "Effects").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _effects_ = ReadOnlyList<ParameterValue>.Create(_effects_Collection_);

				return new Trinket(_id_, _rarity_, _originDungeon_, _heroRestriction_, _item_, _effects_);
			}
			private Trinket ReadTrinket(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _rarity_ = default(TrinketRarity);
				var _originDungeon_ = default(DocumentReference<Location>);
				var _heroRestriction_ = default(DocumentReference<Hero>);
				var _item_ = default(Item);
				var _effects_ = default(ReadOnlyList<ParameterValue>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Trinket");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Item":
								{
									this.ThrowIfNull("value of Document type", "Item", "Trinket");

									var documentPatchObj = default(object);
									if (documentPatch != null && documentPatch.TryGetValue("Item", out documentPatchObj) && documentPatchObj == null)
									{
										this.ReadAny(); // skip because it was removed in patch
									}
									else
									{
										_item_ = this.ReadItem(documentPatchObj as Dictionary<string, object>);
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 6:
						{
							switch (attributeName)
							{
								case "Rarity":
								{
									this.ThrowIfNull("value of PickList type", "Rarity", "Trinket");

									this.ThrowIfNotValue();

									_rarity_ = (TrinketRarity)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Effects":
								{
									this.ThrowIfNull("value of DocumentList type", "Effects", "Trinket");

									_effects_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Effects"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 13:
						{
							switch (attributeName)
							{
								case "OriginDungeon":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_originDungeon_ = this.ReadReference<Location>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 15:
						{
							switch (attributeName)
							{
								case "HeroRestriction":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_heroRestriction_ = this.ReadReference<Hero>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Rarity", ref _rarity_);
					PatchReference(documentPatch, "OriginDungeon", ref _originDungeon_);
					PatchReference(documentPatch, "HeroRestriction", ref _heroRestriction_);
				}

				return new Trinket(_id_, _rarity_, _originDungeon_, _heroRestriction_, _item_, _effects_);
			}

			private ReadOnlyList<Monster> ReadMonsterCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Monster>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadMonster(collectionPatch);
					if (collection == null) { collection = new List<Monster>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Monster>(collection, collectionPatch, d => CreateMonster(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Monster>.Create(collection);
			}
			private Monster CreateMonster(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _type_ = (MonsterType)GetAndCovertValue<MonsterType>(values, "Type");
				var _secondType_ = (Nullable<MonsterType>)GetAndCovertValue<Nullable<MonsterType>>(values, "SecondType");
				var _parameters_Collection_ = GetDocumentCollection(values, "Parameters").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _parameters_ = ReadOnlyList<ParameterValue>.Create(_parameters_Collection_);
				var _locations_Collection_ = GetDocumentCollection(values, "Locations").Values.OfType<Dictionary<string, object>>().Select(DocumentReference<Location>.Create).ToList();
				var _locations_ = ReadOnlyList<DocumentReference<Location>>.Create(_locations_Collection_);

				return new Monster(_id_, _name_, _type_, _secondType_, _parameters_, _locations_);
			}
			private Monster ReadMonster(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _type_ = default(MonsterType);
				var _secondType_ = default(Nullable<MonsterType>);
				var _parameters_ = default(ReadOnlyList<ParameterValue>);
				var _locations_ = default(ReadOnlyList<DocumentReference<Location>>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Monster");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Monster");

									_name_ = this.ReadLocalizedString();
									break;
								}
								case "Type":
								{
									this.ThrowIfNull("value of PickList type", "Type", "Monster");

									this.ThrowIfNotValue();

									_type_ = (MonsterType)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Locations":
								{
									this.ThrowIfNull("value of ReferenceList type", "Locations", "Monster");

									_locations_ = ReadReferenceCollection<Location>();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 10:
						{
							switch (attributeName)
							{
								case "SecondType":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_secondType_ = (Nullable<MonsterType>)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "Parameters":
								{
									this.ThrowIfNull("value of DocumentList type", "Parameters", "Monster");

									_parameters_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Parameters"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "Type", ref _type_);
					PatchValue(documentPatch, "SecondType", ref _secondType_);
					PatchReferenceCollection(documentPatch, "Locations", ref _locations_);
				}

				return new Monster(_id_, _name_, _type_, _secondType_, _parameters_, _locations_);
			}

			private ReadOnlyList<Loot> ReadLootCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Loot>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadLoot(collectionPatch);
					if (collection == null) { collection = new List<Loot>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, Loot>(collection, collectionPatch, d => CreateLoot(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Loot>.Create(collection);
			}
			private Loot CreateLoot(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _type_ = (LootType)GetAndCovertValue<LootType>(values, "Type");
				var _amount_ = GetAndCovertValue<Nullable<int>>(values, "Amount");

				return new Loot(_id_, _type_, _amount_);
			}
			private Loot ReadLoot(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _type_ = default(LootType);
				var _amount_ = default(Nullable<int>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "Loot");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Type":
								{
									this.ThrowIfNull("value of PickList type", "Type", "Loot");

									this.ThrowIfNotValue();

									_type_ = (LootType)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 6:
						{
							switch (attributeName)
							{
								case "Amount":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_amount_ = (Nullable<int>)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Type", ref _type_);
					PatchValue(documentPatch, "Amount", ref _amount_);
				}

				return new Loot(_id_, _type_, _amount_);
			}

			private ReadOnlyList<CombatEffect> ReadCombatEffectCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<CombatEffect>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadCombatEffect(collectionPatch);
					if (collection == null) { collection = new List<CombatEffect>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, CombatEffect>(collection, collectionPatch, d => CreateCombatEffect(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<CombatEffect>.Create(collection);
			}
			private CombatEffect CreateCombatEffect(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _changes_Collection_ = GetDocumentCollection(values, "Changes").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _changes_ = ReadOnlyList<ParameterValue>.Create(_changes_Collection_);
				var _duration_ = GetAndCovertValue<Nullable<int>>(values, "Duration");
				var _durationUnit_ = (DurationUnit)GetAndCovertValue<DurationUnit>(values, "DurationUnit");

				return new CombatEffect(_id_, _changes_, _duration_, _durationUnit_);
			}
			private CombatEffect ReadCombatEffect(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _changes_ = default(ReadOnlyList<ParameterValue>);
				var _duration_ = default(Nullable<int>);
				var _durationUnit_ = default(DurationUnit);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "CombatEffect");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Changes":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_changes_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Changes"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 8:
						{
							switch (attributeName)
							{
								case "Duration":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_duration_ = (Nullable<int>)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 12:
						{
							switch (attributeName)
							{
								case "DurationUnit":
								{
									this.ThrowIfNull("value of PickList type", "DurationUnit", "CombatEffect");

									this.ThrowIfNotValue();

									_durationUnit_ = (DurationUnit)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Duration", ref _duration_);
					PatchValue(documentPatch, "DurationUnit", ref _durationUnit_);
				}

				return new CombatEffect(_id_, _changes_, _duration_, _durationUnit_);
			}

			private ReadOnlyList<CurioCleansingOption> ReadCurioCleansingOptionCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<CurioCleansingOption>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadCurioCleansingOption(collectionPatch);
					if (collection == null) { collection = new List<CurioCleansingOption>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, CurioCleansingOption>(collection, collectionPatch, d => CreateCurioCleansingOption(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<CurioCleansingOption>.Create(collection);
			}
			private CurioCleansingOption CreateCurioCleansingOption(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _chance_ = GetAndCovertValue<float>(values, "Chance");
				var _item_ = DocumentReference<Item>.Create(GetDocument(values, "Item"));
				var _loot_Collection_ = GetDocumentCollection(values, "Loot").Values.OfType<Dictionary<string, object>>().Select(CreateLoot).ToList();
				var _loot_ = ReadOnlyList<Loot>.Create(_loot_Collection_);
				var _quirkChance_ = GetAndCovertValue<Nullable<float>>(values, "QuirkChance");
				var _diseaseChance_ = GetAndCovertValue<Nullable<float>>(values, "DiseaseChance");
				var _effects_Collection_ = GetDocumentCollection(values, "Effects").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _effects_ = ReadOnlyList<ParameterValue>.Create(_effects_Collection_);
				var _itemIsConsumed_ = GetAndCovertValue<bool>(values, "ItemIsConsumed");

				return new CurioCleansingOption(_id_, _chance_, _item_, _loot_, _quirkChance_, _diseaseChance_, _effects_, _itemIsConsumed_);
			}
			private CurioCleansingOption ReadCurioCleansingOption(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _chance_ = default(float);
				var _item_ = default(DocumentReference<Item>);
				var _loot_ = default(ReadOnlyList<Loot>);
				var _quirkChance_ = default(Nullable<float>);
				var _diseaseChance_ = default(Nullable<float>);
				var _effects_ = default(ReadOnlyList<ParameterValue>);
				var _itemIsConsumed_ = default(bool);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "CurioCleansingOption");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Item":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_item_ = this.ReadReference<Item>();

									break;
								}
								case "Loot":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_loot_ = ReadLootCollection(collectionPatch: GetDocumentCollection(documentPatch, "Loot"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 6:
						{
							switch (attributeName)
							{
								case "Chance":
								{
									this.ThrowIfNull("value of Number type", "Chance", "CurioCleansingOption");

									this.ThrowIfNotValue();

									_chance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Effects":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_effects_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Effects"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 11:
						{
							switch (attributeName)
							{
								case "QuirkChance":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_quirkChance_ = (Nullable<float>)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 13:
						{
							switch (attributeName)
							{
								case "DiseaseChance":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									this.ThrowIfNotValue();

									_diseaseChance_ = (Nullable<float>)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 14:
						{
							switch (attributeName)
							{
								case "ItemIsConsumed":
								{
									this.ThrowIfNull("value of Logical type", "ItemIsConsumed", "CurioCleansingOption");

									this.ThrowIfNotValue();

									_itemIsConsumed_ = (bool)this.Node.AsBoolean;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Chance", ref _chance_);
					PatchReference(documentPatch, "Item", ref _item_);
					PatchValue(documentPatch, "QuirkChance", ref _quirkChance_);
					PatchValue(documentPatch, "DiseaseChance", ref _diseaseChance_);
					PatchValue(documentPatch, "ItemIsConsumed", ref _itemIsConsumed_);
				}

				return new CurioCleansingOption(_id_, _chance_, _item_, _loot_, _quirkChance_, _diseaseChance_, _effects_, _itemIsConsumed_);
			}

			private ReadOnlyList<Curio> ReadCurioCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Curio>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadCurio(collectionPatch);
					if (collection == null) { collection = new List<Curio>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Curio>(collection, collectionPatch, d => CreateCurio(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Curio>.Create(collection);
			}
			private Curio CreateCurio(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _type_ = (CurioType)GetAndCovertValue<CurioType>(values, "Type");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _description_ = LocalizedString.Create(GetDocument(values, "Description"));
				var _cleansingOptions_Collection_ = GetDocumentCollection(values, "CleansingOptions").Values.OfType<Dictionary<string, object>>().Select(CreateCurioCleansingOption).ToList();
				var _cleansingOptions_ = ReadOnlyList<CurioCleansingOption>.Create(_cleansingOptions_Collection_);
				var _placementRestictions_ = (CurioPlacementRestictions)GetAndCovertValue<CurioPlacementRestictions>(values, "PlacementRestictions");
				var _locations_Collection_ = GetDocumentCollection(values, "Locations").Values.OfType<Dictionary<string, object>>().Select(DocumentReference<Location>.Create).ToList();
				var _locations_ = ReadOnlyList<DocumentReference<Location>>.Create(_locations_Collection_);

				return new Curio(_id_, _type_, _name_, _description_, _cleansingOptions_, _placementRestictions_, _locations_);
			}
			private Curio ReadCurio(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _type_ = default(CurioType);
				var _name_ = default(LocalizedString);
				var _description_ = default(LocalizedString);
				var _cleansingOptions_ = default(ReadOnlyList<CurioCleansingOption>);
				var _placementRestictions_ = default(CurioPlacementRestictions);
				var _locations_ = default(ReadOnlyList<DocumentReference<Location>>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Curio");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Type":
								{
									this.ThrowIfNull("value of Flags type", "Type", "Curio");

									this.ThrowIfNotValue();

									_type_ = (CurioType)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Curio");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "Locations":
								{
									this.ThrowIfNull("value of ReferenceList type", "Locations", "Curio");

									_locations_ = ReadReferenceCollection<Location>();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 11:
						{
							switch (attributeName)
							{
								case "Description":
								{
									this.ThrowIfNull("value of LocalizedText type", "Description", "Curio");

									_description_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 16:
						{
							switch (attributeName)
							{
								case "CleansingOptions":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_cleansingOptions_ = ReadCurioCleansingOptionCollection(collectionPatch: GetDocumentCollection(documentPatch, "CleansingOptions"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 20:
						{
							switch (attributeName)
							{
								case "PlacementRestictions":
								{
									this.ThrowIfNull("value of Flags type", "PlacementRestictions", "Curio");

									this.ThrowIfNotValue();

									_placementRestictions_ = (CurioPlacementRestictions)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchValue(documentPatch, "Type", ref _type_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchLocalizedString(documentPatch, "Description", ref _description_);
					PatchValue(documentPatch, "PlacementRestictions", ref _placementRestictions_);
					PatchReferenceCollection(documentPatch, "Locations", ref _locations_);
				}

				return new Curio(_id_, _type_, _name_, _description_, _cleansingOptions_, _placementRestictions_, _locations_);
			}

			private ReadOnlyList<Disease> ReadDiseaseCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Disease>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadDisease(collectionPatch);
					if (collection == null) { collection = new List<Disease>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Disease>(collection, collectionPatch, d => CreateDisease(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Disease>.Create(collection);
			}
			private Disease CreateDisease(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _effects_Collection_ = GetDocumentCollection(values, "Effects").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _effects_ = ReadOnlyList<ParameterValue>.Create(_effects_Collection_);

				return new Disease(_id_, _name_, _effects_);
			}
			private Disease ReadDisease(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _effects_ = default(ReadOnlyList<ParameterValue>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Disease");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Disease");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Effects":
								{
									this.ThrowIfNull("value of DocumentList type", "Effects", "Disease");

									_effects_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Effects"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
				}

				return new Disease(_id_, _name_, _effects_);
			}

			private ReadOnlyList<Quirk> ReadQuirkCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Quirk>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadQuirk(collectionPatch);
					if (collection == null) { collection = new List<Quirk>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Quirk>(collection, collectionPatch, d => CreateQuirk(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Quirk>.Create(collection);
			}
			private Quirk CreateQuirk(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _isPositive_ = GetAndCovertValue<bool>(values, "IsPositive");
				var _effects_Collection_ = GetDocumentCollection(values, "Effects").Values.OfType<Dictionary<string, object>>().Select(CreateParameterValue).ToList();
				var _effects_ = ReadOnlyList<ParameterValue>.Create(_effects_Collection_);

				return new Quirk(_id_, _name_, _isPositive_, _effects_);
			}
			private Quirk ReadQuirk(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _isPositive_ = default(bool);
				var _effects_ = default(ReadOnlyList<ParameterValue>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Quirk");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Quirk");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 7:
						{
							switch (attributeName)
							{
								case "Effects":
								{
									this.ThrowIfNull("value of DocumentList type", "Effects", "Quirk");

									_effects_ = ReadParameterValueCollection(collectionPatch: GetDocumentCollection(documentPatch, "Effects"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 10:
						{
							switch (attributeName)
							{
								case "IsPositive":
								{
									this.ThrowIfNull("value of Logical type", "IsPositive", "Quirk");

									this.ThrowIfNotValue();

									_isPositive_ = (bool)this.Node.AsBoolean;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "IsPositive", ref _isPositive_);
				}

				return new Quirk(_id_, _name_, _isPositive_, _effects_);
			}

			private ReadOnlyList<Conditions> ReadConditionsCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Conditions>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadConditions(collectionPatch);
					if (collection == null) { collection = new List<Conditions>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Conditions>(collection, collectionPatch, d => CreateConditions(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Conditions>.Create(collection);
			}
			private Conditions CreateConditions(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _description_ = LocalizedString.Create(GetDocument(values, "Description"));
				var _check_ = GetDocument(values, "Check");
				var _unboundCheck_ = GetDocument(values, "UnboundCheck");

				return new Conditions(_id_, _description_, _check_, _unboundCheck_);
			}
			private Conditions ReadConditions(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _description_ = default(LocalizedString);
				var _check_ = default(Dictionary<string,object>);
				var _unboundCheck_ = default(Dictionary<string,object>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Conditions");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Check":
								{
									this.ThrowIfNull("value of Formula type", "Check", "Conditions");

									_check_ = this.ReadObject();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 11:
						{
							switch (attributeName)
							{
								case "Description":
								{
									this.ThrowIfNull("value of LocalizedText type", "Description", "Conditions");

									_description_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 12:
						{
							switch (attributeName)
							{
								case "UnboundCheck":
								{
									if (this.IsNull())
									{
										this.NextToken();
										continue;
									}

									_unboundCheck_ = this.ReadObject();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Description", ref _description_);
					PatchValue(documentPatch, "Check", ref _check_);
					PatchValue(documentPatch, "UnboundCheck", ref _unboundCheck_);
				}

				return new Conditions(_id_, _description_, _check_, _unboundCheck_);
			}

			private ReadOnlyList<Weapon> ReadWeaponCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Weapon>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadWeapon(collectionPatch);
					if (collection == null) { collection = new List<Weapon>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Weapon>(collection, collectionPatch, d => CreateWeapon(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Weapon>.Create(collection);
			}
			private Weapon CreateWeapon(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _damageFrom_ = GetAndCovertValue<int>(values, "DamageFrom");
				var _damageTo_ = GetAndCovertValue<int>(values, "DamageTo");
				var _criticalStrikeChance_ = GetAndCovertValue<float>(values, "CriticalStrikeChance");
				var _speed_ = GetAndCovertValue<int>(values, "Speed");

				return new Weapon(_id_, _name_, _damageFrom_, _damageTo_, _criticalStrikeChance_, _speed_);
			}
			private Weapon ReadWeapon(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _damageFrom_ = default(int);
				var _damageTo_ = default(int);
				var _criticalStrikeChance_ = default(float);
				var _speed_ = default(int);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Weapon");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Weapon");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Speed":
								{
									this.ThrowIfNull("value of Integer type", "Speed", "Weapon");

									this.ThrowIfNotValue();

									_speed_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 8:
						{
							switch (attributeName)
							{
								case "DamageTo":
								{
									this.ThrowIfNull("value of Integer type", "DamageTo", "Weapon");

									this.ThrowIfNotValue();

									_damageTo_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 10:
						{
							switch (attributeName)
							{
								case "DamageFrom":
								{
									this.ThrowIfNull("value of Integer type", "DamageFrom", "Weapon");

									this.ThrowIfNotValue();

									_damageFrom_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 20:
						{
							switch (attributeName)
							{
								case "CriticalStrikeChance":
								{
									this.ThrowIfNull("value of Number type", "CriticalStrikeChance", "Weapon");

									this.ThrowIfNotValue();

									_criticalStrikeChance_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "DamageFrom", ref _damageFrom_);
					PatchValue(documentPatch, "DamageTo", ref _damageTo_);
					PatchValue(documentPatch, "CriticalStrikeChance", ref _criticalStrikeChance_);
					PatchValue(documentPatch, "Speed", ref _speed_);
				}

				return new Weapon(_id_, _name_, _damageFrom_, _damageTo_, _criticalStrikeChance_, _speed_);
			}

			private ReadOnlyList<Armor> ReadArmorCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<Armor>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadArmor(collectionPatch);
					if (collection == null) { collection = new List<Armor>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<string, Armor>(collection, collectionPatch, d => CreateArmor(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<Armor>.Create(collection);
			}
			private Armor CreateArmor(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<string>(values, "Id");
				var _name_ = LocalizedString.Create(GetDocument(values, "Name"));
				var _dodge_ = GetAndCovertValue<float>(values, "Dodge");
				var _hitPoints_ = GetAndCovertValue<int>(values, "HitPoints");

				return new Armor(_id_, _name_, _dodge_, _hitPoints_);
			}
			private Armor ReadArmor(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(string);
				var _name_ = default(LocalizedString);
				var _dodge_ = default(float);
				var _hitPoints_ = default(int);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Text type", "Id", "Armor");

									this.ThrowIfNotValue();

									_id_ = (string)this.Node.AsString;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Name":
								{
									this.ThrowIfNull("value of LocalizedText type", "Name", "Armor");

									_name_ = this.ReadLocalizedString();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Dodge":
								{
									this.ThrowIfNull("value of Number type", "Dodge", "Armor");

									this.ThrowIfNotValue();

									_dodge_ = (float)this.Node.AsSingle;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 9:
						{
							switch (attributeName)
							{
								case "HitPoints":
								{
									this.ThrowIfNull("value of Integer type", "HitPoints", "Armor");

									this.ThrowIfNotValue();

									_hitPoints_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchLocalizedString(documentPatch, "Name", ref _name_);
					PatchValue(documentPatch, "Dodge", ref _dodge_);
					PatchValue(documentPatch, "HitPoints", ref _hitPoints_);
				}

				return new Armor(_id_, _name_, _dodge_, _hitPoints_);
			}

			private ReadOnlyList<ItemWithCount> ReadItemWithCountCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<ItemWithCount>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadItemWithCount(collectionPatch);
					if (collection == null) { collection = new List<ItemWithCount>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, ItemWithCount>(collection, collectionPatch, d => CreateItemWithCount(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<ItemWithCount>.Create(collection);
			}
			private ItemWithCount CreateItemWithCount(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _item_ = DocumentReference<Item>.Create(GetDocument(values, "Item"));
				var _count_ = GetAndCovertValue<int>(values, "Count");

				return new ItemWithCount(_id_, _item_, _count_);
			}
			private ItemWithCount ReadItemWithCount(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _item_ = default(DocumentReference<Item>);
				var _count_ = default(int);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "ItemWithCount");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 4:
						{
							switch (attributeName)
							{
								case "Item":
								{
									this.ThrowIfNull("value of Reference type", "Item", "ItemWithCount");

									_item_ = this.ReadReference<Item>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Count":
								{
									this.ThrowIfNull("value of Integer type", "Count", "ItemWithCount");

									this.ThrowIfNotValue();

									_count_ = (int)this.Node.AsInt32;
									this.NextToken();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchReference(documentPatch, "Item", ref _item_);
					PatchValue(documentPatch, "Count", ref _count_);
				}

				return new ItemWithCount(_id_, _item_, _count_);
			}

			private ReadOnlyList<StartingSet> ReadStartingSetCollection(Dictionary<string, object> collectionPatch = null, int capacity = 0, bool isRootCollection = false)
			{
				var collection = default(List<StartingSet>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadStartingSet(collectionPatch);
					if (collection == null) { collection = new List<StartingSet>(capacity > 0 ? capacity : 10); }

					collection.Add(value);
				}
				this.ReadArrayEnd();
				if (collectionPatch != null)
				{
					PatchCollection<int, StartingSet>(collection, collectionPatch, d => CreateStartingSet(d), d => d.Id, isRootCollection);
				}

				return ReadOnlyList<StartingSet>.Create(collection);
			}
			private StartingSet CreateStartingSet(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var _id_ = GetAndCovertValue<int>(values, "Id");
				var _items_Collection_ = GetDocumentCollection(values, "Items").Values.OfType<Dictionary<string, object>>().Select(CreateItemWithCount).ToList();
				var _items_ = ReadOnlyList<ItemWithCount>.Create(_items_Collection_);
				var _heroes_Collection_ = GetDocumentCollection(values, "Heroes").Values.OfType<Dictionary<string, object>>().Select(DocumentReference<Hero>.Create).ToList();
				var _heroes_ = ReadOnlyList<DocumentReference<Hero>>.Create(_heroes_Collection_);
				var _location_ = DocumentReference<Location>.Create(GetDocument(values, "Location"));

				return new StartingSet(_id_, _items_, _heroes_, _location_);
			}
			private StartingSet ReadStartingSet(Dictionary<string, object> collectionOrDocumentPatch = null)
			{
				var documentPatch = default(Dictionary<string, object>);

				// if patch douments contains 'Id' property then is is a document patch. If not then it is a collection of patches by document id
				if (collectionOrDocumentPatch != null && collectionOrDocumentPatch.ContainsKey("Id"))
				{
					documentPatch = collectionOrDocumentPatch;
					collectionOrDocumentPatch = null;
				}

#pragma warning disable 0168 // The variable is declared but never used
				var _id_ = default(int);
				var _items_ = default(ReadOnlyList<ItemWithCount>);
				var _heroes_ = default(ReadOnlyList<DocumentReference<Hero>>);
				var _location_ = default(DocumentReference<Location>);
#pragma warning restore 0168
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var attributeName = this.ReadMember();
					switch (attributeName.Length)
					{
						case 2:
						{
							switch (attributeName)
							{
								case "Id":
								{
									this.ThrowIfNull("value of Integer type", "Id", "StartingSet");

									this.ThrowIfNotValue();

									_id_ = (int)this.Node.AsInt32;
									this.NextToken();

									if (collectionOrDocumentPatch != null)
									{
										documentPatch = GetDocument(collectionOrDocumentPatch, Convert.ToString(_id_, FormatProvider));
									}
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 5:
						{
							switch (attributeName)
							{
								case "Items":
								{
									this.ThrowIfNull("value of DocumentList type", "Items", "StartingSet");

									_items_ = ReadItemWithCountCollection(collectionPatch: GetDocumentCollection(documentPatch, "Items"));
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 6:
						{
							switch (attributeName)
							{
								case "Heroes":
								{
									this.ThrowIfNull("value of ReferenceList type", "Heroes", "StartingSet");

									_heroes_ = ReadReferenceCollection<Hero>();
									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						case 8:
						{
							switch (attributeName)
							{
								case "Location":
								{
									this.ThrowIfNull("value of Reference type", "Location", "StartingSet");

									_location_ = this.ReadReference<Location>();

									break;
								}
								default:
								{
									this.ReadAny();
									break;
								}
							}
							break;
						}
						default:
						{
							this.ReadAny();
							break;
						}
					}
				}
				this.ReadObjectEnd();

				if (documentPatch != null && documentPatch.Count > 1)
				{
					PatchValue(documentPatch, "Id", ref _id_);
					PatchReferenceCollection(documentPatch, "Heroes", ref _heroes_);
					PatchReference(documentPatch, "Location", ref _location_);
				}

				return new StartingSet(_id_, _items_, _heroes_, _location_);
			}
			public Dictionary<string, object> ReadDocument()
			{
				return this.ReadObject();
			}
			
			private void ReadArrayBegin(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.BeginArray)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
				}
				if (this.IsEndOfStream())
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
				}

				if (nextToken)
					this.NextToken();
			}
			private void ReadArrayEnd(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.EndOfArray)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
				}

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}
			}
			private void ReadObjectBegin(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.BeginObject)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
				}

				if (this.IsEndOfStream())
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
				}

				if (nextToken)
				{
					this.NextToken();
				}
			}
			private void ReadObjectEnd(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.EndOfObject)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
				}

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}
			}
			private string ReadMember(bool nextToken = true)
			{
				if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
				}

				var memberName = this.Node.AsString;

				if (!this.IsEndOfStream() && nextToken)
				{
					this.NextToken();
				}

				return memberName;
			}

			protected object ReadAny(bool nextToken = true)
			{
				var value = default(object);
				switch(this.Node.Token)
				{
					case ReaderToken.BeginArray: value = this.ReadArray(false); break;
					case ReaderToken.BeginObject: value = this.ReadObject(false); break;
					case ReaderToken.Null: value = null; break;
					case ReaderToken.Value: value = this.Node.AsObject; break;
					default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
				}

				if (nextToken)
				{
					this.NextToken();
				}

				return value;
			}
			private List<object> ReadArray(bool nextToken = true)
			{
				var list = default(List<object>);
				var itemIndex = 0;
				var item1 = default(object);
				var item2 = default(object);
				var item3 = default(object);
				var item4 = default(object);

				this.ReadArrayBegin();
				while(this.Node.Token != ReaderToken.EndOfArray)
				{
					var value = this.ReadAny();

					if (list == null)
					{
						switch (itemIndex)
						{
							case 0:
								item1 = value;
								itemIndex = 1;
								continue;
							case 1:
								item2 = value;
								itemIndex = 2;
								continue;
							case 2:
								item3 = value;
								itemIndex = 3;
								continue;
							case 3:
								item4 = value;
								itemIndex = 4;
								continue;
							default:
								list = new List<object>(itemIndex + 1);
								list.Add(item1);
								list.Add(item2);
								list.Add(item3);
								list.Add(item4);
								break;
						}
					}

					list.Add(value);
				}
				this.ReadArrayEnd(nextToken);

				if (itemIndex == 0)
				{
					list = new List<object>(1);
				}
				else if (list == null)
				{
					list = new List<object>(itemIndex);

					if (itemIndex > 0) { list.Add(item1); }
					if (itemIndex > 1) { list.Add(item2); }
					if (itemIndex > 2) { list.Add(item3); }
					if (itemIndex > 3) { list.Add(item4); }
				}

				return list;
			}
			private Dictionary<string, object> ReadObject(bool nextToken = true)
			{
				var keyValueIndex = 0;
				var keyValuePair1 = default(KeyValuePair<string, object>);
				var keyValuePair2 = default(KeyValuePair<string, object>);
				var keyValuePair3 = default(KeyValuePair<string, object>);
				var keyValuePair4 = default(KeyValuePair<string, object>);
				var dictionary = default(Dictionary<string, object>);

				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					var value = this.ReadAny();

					if (dictionary == null)
					{
						switch (keyValueIndex)
						{
							case 0:
								keyValuePair1 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 1;
								continue;
							case 1:
								keyValuePair2 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 2;
								continue;
							case 2:
								keyValuePair3 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 3;
								continue;
							case 3:
								keyValuePair4 = new KeyValuePair<string, object>(key, value);
								keyValueIndex = 4;
								continue;
							default:
								dictionary = new Dictionary<string, object>(keyValueIndex + 1);
								dictionary[keyValuePair1.Key] = keyValuePair1.Value;
								dictionary[keyValuePair2.Key] = keyValuePair2.Value;
								dictionary[keyValuePair3.Key] = keyValuePair3.Value;
								dictionary[keyValuePair4.Key] = keyValuePair4.Value;
								break;
						}
					}

					dictionary[key] = value;
				}
				this.ReadObjectEnd(nextToken);

				
				if (keyValueIndex == 0)
				{
					dictionary = new Dictionary<string, object>(1);
				}
				else if (dictionary == null)
				{
					dictionary = new Dictionary<string, object>(keyValueIndex);
					switch (keyValueIndex)
					{					
						case 1: dictionary[keyValuePair1.Key] = keyValuePair1.Value; break;
						case 2: dictionary[keyValuePair2.Key] = keyValuePair2.Value; goto case 1;
						case 3: dictionary[keyValuePair3.Key] = keyValuePair3.Value; goto case 2;
						case 4: dictionary[keyValuePair4.Key] = keyValuePair4.Value; goto case 3;
					}
				}

				return dictionary;
			}
			private LocalizedString ReadLocalizedString(bool nextToken = true)
			{
				var locString = new LocalizedString();
				this.ReadObjectBegin();
				while(this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					var value = Convert.ToString(this.ReadAny(), FormatProvider);

					if (key == "notes")
					{
						continue;
					}

					locString[key] = value;
				}
				this.ReadObjectEnd(nextToken);
				return locString;
			}
			private ReadOnlyList<DocumentReference<T>> ReadReferenceCollection<T>(bool nextToken = true) where T : Document
			{
				var referenceCollection = default(List<DocumentReference<T>>);
				this.ReadArrayBegin();
				while (this.Node.Token != ReaderToken.EndOfArray)
				{
					if (this.IsNull())
					{
						this.NextToken();
						continue;
					}

					var value = this.ReadReference<T>();
					if (referenceCollection == null) { referenceCollection = new List<DocumentReference<T>>(5); }
					referenceCollection.Add(value);
				}
				this.ReadArrayEnd(nextToken);

				return ReadOnlyList<DocumentReference<T>>.Create(referenceCollection);
			}
			private DocumentReference<T> ReadReference<T>(bool nextToken = true) where T : Document
			{
				var reference = new DocumentReference<T>();
				this.ReadObjectBegin();
				while (this.Node.Token != ReaderToken.EndOfObject)
				{
					var key = this.ReadMember();
					if (key == "Id")
						reference.Id = this.ReadAny();
					else
						this.ReadAny();
				}
				this.ReadObjectEnd(nextToken);
				return reference;
			}

			private bool IsEndOfStream()
			{
				return this.Node.Token == ReaderToken.EndOfStream;
			}
			private bool IsNull()
			{
				return this.Node.Token == ReaderToken.Null;
			}
			private void ThrowIfNotValue()
			{
				if (this.Node.Token != ReaderToken.Value)
				{
					throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
				}
			}
			private void ThrowIfNull(string expected, string attributeName, string entityName)
			{
				if (this.Node.Token == ReaderToken.Null)
				{
					throw ReaderException.UnexpectedNullValue(expected, attributeName, entityName, this);
				}
			}

			private static T GetValueAs<T>(Dictionary<string, object> values, string key, T defaultValue = default(T))
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false || valueObj is T == false)
				{
					return defaultValue;
				}
				return (T)valueObj;
			}
			private static object GetValue(Dictionary<string, object> values, string key)
			{
				if (key == null) throw new ArgumentNullException("key");

				if (values == null)
				{
					return null;
				}

				var valueObj = default(object);
				values.TryGetValue(key, out valueObj);
				return valueObj;
			}
			private static Dictionary<string, object> GetDocument(Dictionary<string, object> values, string key)
			{
				return GetValueAs<Dictionary<string, object>>(values, key);
			}
			private static T GetAndCovertValue<T>(Dictionary<string, object> values, string key, T defaultValue = default(T))
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false)
				{
					return defaultValue;
				}

				return ConvertTo<T>(valueObj);
			}
			
			private static Dictionary<string, object> GetDocumentCollection(Dictionary<string, object> values, string key)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.TryGetValue(key, out valueObj) == false)
				{
					return null;
				}

				if (valueObj is Dictionary<string, object>)
				{
					return (Dictionary<string, object>)valueObj;
				}
				else if (valueObj is List<object>)
				{
					var documents = (List<object>)valueObj;
					var documentsById = new Dictionary<string, object>(documents.Count);
					foreach (var document in documents)
					{
						var id = Convert.ToString(GetValue(document as Dictionary<string, object>, "Id"), FormatProvider);
						if (string.IsNullOrEmpty(id))
						{
							continue;
						}
						documentsById[id] = document;
					}
					return documentsById;
				}
				else
				{
					return null;
				}
			}
			private static void PatchValue<T>(Dictionary<string, object> values, string key, ref T value)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				value = ConvertTo<T>(valueObj);
			}
			private void PatchCollection<IdType, EntityT>(List<EntityT> collection, Dictionary<string, object> collectionPatch, Func<Dictionary<string, object>, EntityT> constructor, Func<EntityT, IdType> getId, bool isRootCollection)
			{
				if (collection == null) throw new ArgumentNullException("collection");
				if (collectionPatch == null) throw new ArgumentNullException("collectionPatch");
				if (constructor == null) throw new ArgumentNullException("constructor");
				if (getId == null) throw new ArgumentNullException("getId");

				var collectionIndex = 0;
				var idComparer = Comparer<IdType>.Default;
				var patchIndex = 0;
				foreach (var kv in collectionPatch)
				{
					var id = ConvertTo<IdType>(kv.Key);
					collectionIndex = -1;
					for (int k = 0; k < collection.Count; k++)
					{
						if (idComparer.Compare(getId(collection[k]), id) != 0)
						{
							continue;
						}
						collectionIndex = k;
						break;
					}

					if (kv.Value == null && collectionIndex != -1)
					{
						// remove document
						collection.RemoveAt(collectionIndex);
					}
					else if (kv.Value is Dictionary<string, object> && collectionIndex == -1)
					{
						// create document
						var document = (Dictionary<string, object>)kv.Value;
						collection.Add(constructor(document));
					}
					else if (patchIndex != collectionIndex && collectionIndex != -1 && isRootCollection == false)
					{
						// re-order document
						var document = collection[collectionIndex];
						collection.RemoveAt(collectionIndex);
						collection.Insert(patchIndex, document);
					}

					patchIndex++;
				}
			}
			private static void PatchReference<T>(Dictionary<string, object> values, string key, ref DocumentReference<T> value) where T : Document
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				var newReference = valueObj as Dictionary<string, object>;
				var newReferenceId = default(object);
				if (newReference == null || newReference.TryGetValue("Id", out newReferenceId) == false || newReferenceId == null) 
				{
					value = null;
					return;
				}
				value = new DocumentReference<T>() { Id = newReferenceId };
			}
			private static void PatchReferenceCollection<T>(Dictionary<string, object> values, string key, ref ReadOnlyList<DocumentReference<T>> value) where T : Document
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				if (valueObj is Dictionary<string, object>)
				{
					var referenceById = (Dictionary<string, object>)valueObj;
					var collection = new List<DocumentReference<T>>(referenceById.Count);

					foreach(var kv in referenceById)
					{
						if (kv.Value == null)
						{
							continue;
						}
						collection.Add(new DocumentReference<T> { Id = kv.Key });
					}

					value = ReadOnlyList<DocumentReference<T>>.Create(collection);
				}
				else if (valueObj is List<object>)
				{
					var referenceList = (List<object>)valueObj;
					var collection = new List<DocumentReference<T>>(referenceList.Count);

					foreach(var reference in referenceList)
					{
						if (reference == null || reference is Dictionary<string, object> == false)
						{
							continue;
						}
						var id = GetValue((Dictionary<string, object>)reference, "Id");
						if (id == null)
						{
							continue;
						}
						collection.Add(new DocumentReference<T> { Id = id });
					}

					value = ReadOnlyList<DocumentReference<T>>.Create(collection);
				}
			}
			private static void PatchLocalizedString(Dictionary<string, object> values, string key, ref LocalizedString value)
			{
				if (key == null) throw new ArgumentNullException("key");

				var valueObj = default(object);
				if (values == null || values.Count == 0 || values.TryGetValue(key, out valueObj) == false)
				{
					return;
				}

				var newLocalization = valueObj as Dictionary<string, object>;
				if (newLocalization == null) 
				{
					value = null;
					return;
				}

				value = value ?? new LocalizedString();
				foreach (var kv in newLocalization)
				{
					if (kv.Value == null)
					{
						value[kv.Key] = null;
					}
					else
					{
						value[kv.Key] = Convert.ToString(kv.Value, FormatProvider);
					}
				}
			}
			private static T ConvertTo<T>(object valueObj)
			{
				if (valueObj is T)
				{
					return (T)valueObj;
				}

				var nullableType = Nullable.GetUnderlyingType(typeof(T));
				var valueType = nullableType ?? typeof(T);
				if (valueObj == null)
				{
					if (typeof(T).IsValueType && nullableType == null)
					{
						throw new InvalidOperationException(string.Format("Unable to convert null value to type '{0}'.", typeof(T)));
					}
					return default(T);
				}
				else if (valueType.IsEnum)
				{
					return (T)Enum.Parse(valueType, Convert.ToString(valueObj, FormatProvider), true);
				}
				else
				{
					return (T)Convert.ChangeType(valueObj, valueType, FormatProvider);
				}
			}

			public override string ToString()
			{
				return this.Node.ToString();
			}
		}

		private struct ReaderNode
		{
			private readonly object value;

			public readonly ReaderToken Token;
			public readonly Type ValueType;

			public bool HasValue { get { return this.ValueType != typeof(void); } }

			public ReaderNode(ReaderToken token)
			{
				this.Token = token;
				this.value = null;
				this.ValueType = typeof(void);
			}
			public ReaderNode(ReaderToken token, object value)
			{
				if (value == null) throw new ArgumentNullException("value");

				this.Token = token;
				this.value = value;
				this.ValueType = value is IStrongBox ? ((IStrongBox)value).ValueType : value.GetType();
			}

			public bool AsBoolean
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsBoolean;
					return Convert.ToBoolean(this.value, FormatProvider);
				}
			}
			public byte AsByte
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsByte;
					return Convert.ToByte(this.value, FormatProvider);
				}
			}
			public short AsInt16
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt16;
					return Convert.ToInt16(this.value, FormatProvider);
				}
			}
			public int AsInt32
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt32;
					return Convert.ToInt32(this.value, FormatProvider);
				}
			}
			public long AsInt64
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsInt64;
					return Convert.ToInt64(this.value, FormatProvider);
				}
			}
			public sbyte AsSByte
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsSByte;
					return Convert.ToSByte(this.value, FormatProvider);
				}
			}
			public ushort AsUInt16
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt16;
					return Convert.ToUInt16(this.value, FormatProvider);
				}
			}
			public uint AsUInt32
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt32;
					return Convert.ToUInt32(this.value, FormatProvider);
				}
			}
			public ulong AsUInt64
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsUInt64;
					return Convert.ToUInt64(this.value, FormatProvider);
				}
			}
			public float AsSingle
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsSingle;
					return Convert.ToSingle(this.value, FormatProvider);
				}
			}
			public double AsDouble
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsDouble;
					return Convert.ToDouble(this.value, FormatProvider);
				}
			}
			public decimal AsDecimal
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsDecimal;
					return Convert.ToDecimal(this.value, FormatProvider);
				}
			}
			public string AsString
			{
				get
				{
					var value = this.value;
					if (this.value is IStrongBox) value = (this.value as IStrongBox).AsObject;
					return Convert.ToString(value, FormatProvider);
				}
			}
			public DateTime AsDateTime
			{
				get
				{
					var dateTimeStr = this.AsString;
					var date = DateTime.ParseExact(dateTimeStr, DateTimeFormat, FormatProvider, System.Globalization.DateTimeStyles.RoundtripKind);
					return date;
				}
			}
			public TimeSpan AsTimeSpan
			{
				get
				{
					var timeSpanStr = this.AsString;
					var timeSpan = TimeSpan.Parse(timeSpanStr);
					return timeSpan;
				}
			}
			public object AsObject
			{
				get
				{
					if (this.value is IStrongBox) return (this.value as IStrongBox).AsObject;
					return this.value;
				}
			}

			public override string ToString()
			{
				return string.Format(FormatProvider, "{0}:{1}", this.Token, this.value);
			}
		}

		private interface IStrongBox
		{
			bool AsBoolean { get; }
			byte AsByte { get; }
			short AsInt16 { get; }
			int AsInt32 { get; }
			long AsInt64 { get; }
			sbyte AsSByte { get; }
			ushort AsUInt16 { get; }
			uint AsUInt32 { get; }
			ulong AsUInt64 { get; }
			float AsSingle { get; }
			double AsDouble { get; }
			decimal AsDecimal { get; }
			Type ValueType { get; }
			object AsObject { get; }

			void Store<T>(T value);
		}

		private sealed class StrongBox<ValueT> : IStrongBox
		{
			private static readonly Type ValueType = typeof(ValueT);

			private readonly IFormatProvider formatProvider;

			public ValueT Value;

			public StrongBox(ValueT value, IFormatProvider formatProvider)
				: this(formatProvider)
			{
				this.Value = value;
			}
			public StrongBox(IFormatProvider formatProvider)
			{
				if (formatProvider == null) throw new ArgumentNullException("formatProvider");

				this.formatProvider = formatProvider;
			}

			Type IStrongBox.ValueType { get { return ValueType; } }
			public bool AsBoolean { get	{ return Convert.ToBoolean((object)Value, this.formatProvider);	} }
			public byte AsByte { get { return Convert.ToByte((object)Value, this.formatProvider); } }
			public short AsInt16 { get { return Convert.ToInt16((object)Value, this.formatProvider); } }
			public int AsInt32 { get { return Convert.ToInt32((object)Value, this.formatProvider); } }
			public long AsInt64 { get { return Convert.ToInt64((object)Value, this.formatProvider); } }
			public sbyte AsSByte { get { return Convert.ToSByte((object)Value, this.formatProvider); } }
			public ushort AsUInt16 { get { return Convert.ToUInt16((object)Value, this.formatProvider); } }
			public uint AsUInt32 { get { return Convert.ToUInt32((object)Value, this.formatProvider); } }
			public ulong AsUInt64 { get { return Convert.ToUInt64((object)Value, this.formatProvider); } }
			public float AsSingle { get { return Convert.ToSingle((object)Value, this.formatProvider); } }
			public double AsDouble { get { return Convert.ToDouble((object)Value, this.formatProvider); } }
			public decimal AsDecimal { get { return Convert.ToDecimal((object)Value, this.formatProvider); } }
			public object AsObject { get { return this.Value; } }

			public void Store<T>(T value)
			{
				var type = typeof(T);
				if (type != ValueType)
				{
					throw new ArgumentException(string.Format("Unable to store value of type '{0}' in container of type '{1}'", typeof(ValueT), type));
				}
				this.Value = (ValueT)(object)value;
			}

			public override string ToString()
			{
				return Convert.ToString(this.Value, this.formatProvider);
			}
		}

		private enum ReaderToken
		{
			None = 0,
			BeginArray,
			EndOfArray,
			BeginObject,
			EndOfObject,
			Member,
			Null,
			Value,
			Comment,
			EndOfStream
		}

		public sealed class StringSet
		{
			public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

			private readonly ulong[] keys;
			private readonly StringSet[] subSets;
			private readonly string[] values;

			public StringSet(ulong[] keys, StringSet[] subSets)
			{
				if(keys == null) throw new ArgumentNullException("keys");
				if(subSets == null) throw new ArgumentNullException("subSets");
				if(subSets.Length != keys.Length) throw new ArgumentException("invalid sets", "keys");

				this.keys = keys;
				this.subSets = subSets;
			}
			public StringSet(ulong[] keys, string[] values)
			{
				if(keys == null) throw new ArgumentNullException("keys");
				if(values == null) throw new ArgumentNullException("values");
				if(values.Length != keys.Length) throw new ArgumentException("invalid sets", "keys");

				this.keys = keys;
				this.values = values;
			}

			public bool TryNarrow(ulong octet, out StringSet value)
			{
				var subSetIndex = 0;
				switch (this.keys.Length)
				{
					case 1: subSetIndex = this.keys[0] == octet ? 0 : -1; break;
					case 2: subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1; break;
					case 3:
					case 4:
					case 5: subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length); break;
					default: subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer); break;
				}

				if (subSetIndex < 0)
				{
					value =  null;
					return false;
				}
				value = this.subSets[subSetIndex];
				return true;
			}
			public bool TryGetValue(ulong octet, out string value)
			{
				var valueIndex = 0;
				switch (this.keys.Length)
				{
					case 1: valueIndex = this.keys[0] == octet ? 0 : -1; break;
					case 2: valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1; break;
					case 3:
					case 4:
					case 5: valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length); break;
					default: valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer); break;
				}

				if (valueIndex < 0)
				{
					value = null;
					return false;
				}

				value = this.values[valueIndex];
				return value != null;
			}
		}

		public sealed class StringLookupTable
		{
			public const int MAX_STRING_SIZE = 8 * 8;

			private readonly StringSet[] table;

			public StringLookupTable(StringSet[] table)
			{
				if (table == null) throw new ArgumentNullException("table");

				this.table = table;
				Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
			}

			public bool TryGetString(byte[] bytes, int offset, int count, out string value)
			{
				const int LAST_ASCII_CHARACTER = 0x7f;

				if (bytes == null) { throw new ArgumentNullException("bytes"); }
				if (count < 0) throw new ArgumentOutOfRangeException("count");
				if (offset < 0) throw new ArgumentOutOfRangeException("offset");
				if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException("offset");

				if (count == 0)
				{
					value = string.Empty;
					return true;
				}

				value = null;
				if (count > MAX_STRING_SIZE || this.table[count] == null)
				{
					return false;
				}

				var end = offset + count;
				var octet = 0UL;
				for (var i = 0; offset + i < end; i++)
				{
					var character = bytes[offset + i];
					if (character > LAST_ASCII_CHARACTER)
					{
						return false;
					}

					if (i < 8)
					{
						octet = unchecked(octet | ((ulong)character << 8 * i));
					}
				}

				var set = this.table[count];
				var narrowOffset = 1;
				for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
				{
					if (set == null || !set.TryNarrow(octet, out set))
					{
						return false;
					}

					octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
				}
				
				return set != null && set.TryGetValue(octet, out value);
			}
			public bool TryGetString(char[] chars, int offset, int count, out string value)
			{
				const int LAST_ASCII_CHARACTER = 0x7f;

				if (chars == null) { throw new ArgumentNullException("chars"); }
				if (count < 0) throw new ArgumentOutOfRangeException("count");
				if (offset < 0) throw new ArgumentOutOfRangeException("offset");
				if (offset + count > chars.Length) throw new ArgumentOutOfRangeException("offset");

				if (count == 0)
				{
					value = string.Empty;
					return true;
				}

				value = null;
				if (count > MAX_STRING_SIZE || this.table[count] == null)
				{
					return false;
				}

				var end = offset + count;
				var octet = 0UL;
				for (var i = 0; offset + i < end; i++)
				{
					var character = chars[offset + i];
					if (character > LAST_ASCII_CHARACTER)
					{
						return false;
					}

					if (i < 8)
					{
						octet = unchecked(octet | ((ulong)character << 8 * i));
					}
				}

				var set = this.table[count];
				var narrowOffset = 1;
				for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
				{
					if (set == null || !set.TryNarrow(octet, out set))
					{
						return false;
					}

					octet = GetUInt64(chars, offset + narrowOffset * 8, end);
				}
				
				return set != null && set.TryGetValue(octet, out value);
			}

			private static ulong GetUInt64(byte[] bytes, int offset, int end)
			{
				if (offset >= end)
				{
					return 0;
				}

				switch (end - offset)
				{
					case 1: return (ulong)bytes[offset];
					case 2:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1;
					case 3:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2;
					case 4:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3;
					case 5:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4;
					case 6:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5;
					case 7:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5 |
							(ulong)bytes[offset + 6] << 8 * 6;
					default:
						return (ulong)bytes[offset] |
							(ulong)bytes[offset + 1] << 8 * 1 |
							(ulong)bytes[offset + 2] << 8 * 2 |
							(ulong)bytes[offset + 3] << 8 * 3 |
							(ulong)bytes[offset + 4] << 8 * 4 |
							(ulong)bytes[offset + 5] << 8 * 5 |
							(ulong)bytes[offset + 6] << 8 * 6 |
							(ulong)bytes[offset + 7] << 8 * 7;
				}
			}
			private static ulong GetUInt64(char[] chars, int offset, int end)
			{
				if (offset >= end)
				{
					return 0;
				}

				switch (end - offset)
				{
					case 1: return (ulong)chars[offset];
					case 2:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1;
					case 3:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2;
					case 4:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3;
					case 5:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4;
					case 6:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5;
					case 7:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5 |
							(ulong)chars[offset + 6] << 8 * 6;
					default:
						return (ulong)chars[offset] |
							(ulong)chars[offset + 1] << 8 * 1 |
							(ulong)chars[offset + 2] << 8 * 2 |
							(ulong)chars[offset + 3] << 8 * 3 |
							(ulong)chars[offset + 4] << 8 * 4 |
							(ulong)chars[offset + 5] << 8 * 5 |
							(ulong)chars[offset + 6] << 8 * 6 |
							(ulong)chars[offset + 7] << 8 * 7;
				}
			}
		}

		[Serializable]
		private class ReaderException : SerializationException
		{
			public int Code { get; set; }
			public int LineNumber { get; set; }
			public int ColumnNumber { get; set; }

			private ReaderException(string message, Reader reader)
				: base(message)
			{
				if (message == null) throw new ArgumentNullException("message");

				if (reader != null)
					this.Update(reader);
			}

			protected ReaderException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
				if (info == null) throw new ArgumentNullException("info");

				this.LineNumber = info.GetInt32("LineNumber");
				this.ColumnNumber = info.GetInt32("ColumnNumber");
			}

			private void Update(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				this.LineNumber = reader.LineNumber;
				this.ColumnNumber = reader.ColumnNumber;
			}

			public override void GetObjectData(SerializationInfo info, StreamingContext context)
			{
				if (info == null) throw new ArgumentNullException("info");

				info.AddValue("Code", this.Code);
				info.AddValue("LineNumber", this.LineNumber);
				info.AddValue("ColumnNumber", this.ColumnNumber);

				base.GetObjectData(info, context);
			}

			public static Exception UnexpectedEndOfStream(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Unexpected end of stream."), reader);
			}
			public static Exception UnexpectedToken(Reader reader, params ReaderToken[] expectedTokens)
			{
				if (reader == null) throw new ArgumentNullException("reader");
				if (expectedTokens == null) throw new ArgumentNullException("expectedTokens");

				var tokensStr = default(string);
				if (expectedTokens.Length == 0)
				{
					tokensStr = "<no tokens>";
				}
				else
				{
					var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
					tokensStr = String.Join(", ", tokens);
				}

				return new ReaderException(string.Format("Expected one of there '{2}' but found '{0}'({1}).", reader.Node.Token, reader.Node.ValueType.Name, tokensStr), reader);
			}
			public static Exception UnknownEscapeSequence(string escape, Reader reader)
			{
				if (escape == null) throw new ArgumentNullException("escape");
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown escape sequence '{0}'.", escape),reader);
			}
			public static Exception UnterminatedStringLiteral(Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unterminated string literal."), reader);
			}
			public static Exception UnknownNotation(Reader reader, string notation)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown notation '{0}'.", notation), reader);
			}
			public static Exception StringLiteralIsTooLong(Reader reader, int size, int maxSize)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("String literal is too long '{0}'. Maximum size is {1}.", size, maxSize), reader);
			}
			public static Exception BinaryDataIsTooLong(Reader reader, int size, int maxSize)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Binary data is too long '{0}'. Maximum size is {1}.", size, maxSize), reader);
			}
			public static Exception ReadingBrokenDocument(Reader reader, string additionalInformation)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("Failed to continue deserialize because document's structure is invalid. Additional information: {0}", additionalInformation), reader);
			}
			public static Exception UnknownMessagePackType(string type, Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("An unknown Message Pack type '{0}'.", type), reader);
			}
			public static Exception UnexpectedNullValue(string expected, string attributeName, string entityName, Reader reader)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				return new ReaderException(string.Format("A null value is deserialized instead of {0} for required attribute '{1}' in entity '{2}'.", expected, attributeName, entityName), reader);
			}
		}

		public static Dictionary<string, object> MergeDocuments(Dictionary<string, object> left, Dictionary<string, object> right)
		{
			if (left == null && right == null)
			{
				return null;
			}
			else if (left == null)
			{
				return right;
			}
			else if (right == null)
			{
				return left;
			}

			var keys = new HashSet<string>(left.Keys.Concat(right.Keys));
			var result = new Dictionary<string, object>(keys.Count);
			foreach (var key in keys)
			{
				var leftValue = default(object);
				var rightValue = default(object);
				var leftHasValue = left.TryGetValue(key, out leftValue);
				var rightHasValue = right.TryGetValue(key, out rightValue);
				var leftDocument = leftValue as Dictionary<string, object>;
				var rightDocument = rightValue as Dictionary<string, object>;
				var leftIsDeleted = leftHasValue && leftValue == null;
				var rightIsDeleted = rightHasValue && rightValue == null;

				if (!leftHasValue && !rightHasValue)
				{
					continue;
				}
				if ((leftIsDeleted || rightIsDeleted) && (leftDocument != null || rightDocument != null))
				{
					result[key] = null; // keep deleted documents as deleted
				}
				else if (!rightHasValue)
				{
					result[key] = leftValue;
				}
				else if (!leftHasValue)
				{
					result[key] = rightValue;
				}
				else if (leftDocument != null && rightDocument != null)
				{
					result[key] = MergeDocuments(leftDocument, rightDocument);
				}
				else
				{
					result[key] = rightValue;
				}
			}
			return result;
		}

		#region EndianBitConverter by Jon Skeet and Marc Gravell
		/* "Miscellaneous Utility Library" Software Licence

		Version 1.0

		Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
		All rights reserved.

		Redistribution and use in source and binary forms, with or without
		modification, are permitted provided that the following conditions
		are met:

		1. Redistributions of source code must retain the above copyright
		notice, this list of conditions and the following disclaimer.

		2. Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.

		3. The end-user documentation included with the redistribution, if
		any, must include the following acknowledgment:

		"This product includes software developed by Jon Skeet
		and Marc Gravell. Contact skeet@pobox.com, or see
		http://www.pobox.com/~skeet/)."

		Alternately, this acknowledgment may appear in the software itself,
		if and wherever such third-party acknowledgments normally appear.

		4. The name "Miscellaneous Utility Library" must not be used to endorse
		or promote products derived from this software without prior written
		permission. For written permission, please contact skeet@pobox.com.

		5. Products derived from this software may not be called
		"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
		appear in their name, without prior written permission of Jon Skeet.

		THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
		WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
		MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
		IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
		INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
		BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
		CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
		LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
		ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
		POSSIBILITY OF SUCH DAMAGE.
		*/

		internal enum Endianness
		{
			LittleEndian,

			BigEndian
		}

		private abstract class EndianBitConverter
		{
			#region Endianness of this converter

			public abstract bool IsLittleEndian();

			public abstract Endianness Endianness { get; }

			#endregion

			#region Factory properties

			private static readonly LittleEndianBitConverter little = new LittleEndianBitConverter();

			public static LittleEndianBitConverter Little
			{
				get { return little; }
			}

			private static readonly BigEndianBitConverter big = new BigEndianBitConverter();

			public static BigEndianBitConverter Big
			{
				get { return big; }
			}

			#endregion

			#region Double/primitive conversions

			public long DoubleToInt64Bits(double value)
			{
				return BitConverter.DoubleToInt64Bits(value);
			}

			public double Int64BitsToDouble(long value)
			{
				return BitConverter.Int64BitsToDouble(value);
			}

			public int SingleToInt32Bits(float value)
			{
				return new Int32SingleUnion(value).AsInt32;
			}

			public float Int32BitsToSingle(int value)
			{
				return new Int32SingleUnion(value).AsSingle;
			}

			#endregion

			#region To(PrimitiveType) conversions

			public bool ToBoolean(byte[] value, int startIndex)
			{
				CheckByteArgument(value, startIndex, 1);
				return BitConverter.ToBoolean(value, startIndex);
			}

			public char ToChar(byte[] value, int startIndex)
			{
				return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
			}

			public double ToDouble(byte[] value, int startIndex)
			{
				return Int64BitsToDouble(ToInt64(value, startIndex));
			}

			public float ToSingle(byte[] value, int startIndex)
			{
				return Int32BitsToSingle(ToInt32(value, startIndex));
			}

			public short ToInt16(byte[] value, int startIndex)
			{
				return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
			}

			public int ToInt32(byte[] value, int startIndex)
			{
				return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
			}

			public long ToInt64(byte[] value, int startIndex)
			{
				return CheckedFromBytes(value, startIndex, 8);
			}

			public ushort ToUInt16(byte[] value, int startIndex)
			{
				return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
			}

			public uint ToUInt32(byte[] value, int startIndex)
			{
				return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
			}

			public ulong ToUInt64(byte[] value, int startIndex)
			{
				return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
			}

			private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (startIndex < 0 || startIndex > value.Length - bytesRequired)
				{
					throw new ArgumentOutOfRangeException("startIndex");
				}
			}

			private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
			{
				CheckByteArgument(value, startIndex, bytesToConvert);
				return FromBytes(value, startIndex, bytesToConvert);
			}

			protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

			#endregion

			#region ToString conversions

			public static string ToString(byte[] value)
			{
				return BitConverter.ToString(value);
			}

			public static string ToString(byte[] value, int startIndex)
			{
				return BitConverter.ToString(value, startIndex);
			}

			public static string ToString(byte[] value, int startIndex, int length)
			{
				return BitConverter.ToString(value, startIndex, length);
			}

			#endregion

			#region	Decimal conversions

			public decimal ToDecimal(byte[] value, int startIndex)
			{
				// HACK: This always assumes four parts, each in their own endianness,
				// starting with the first part at the start of the byte array.
				// On the other hand, there's no real format specified...
				var parts = new int[4];
				for (var i = 0; i < 4; i++)
				{
					parts[i] = ToInt32(value, startIndex + i * 4);
				}
				return new decimal(parts);
			}

			public byte[] GetBytes(decimal value)
			{
				var bytes = new byte[16];
				var parts = decimal.GetBits(value);
				for (var i = 0; i < 4; i++)
				{
					CopyBytesImpl(parts[i], 4, bytes, i * 4);
				}
				return bytes;
			}

			public void CopyBytes(decimal value, byte[] buffer, int index)
			{
				var parts = decimal.GetBits(value);
				for (var i = 0; i < 4; i++)
				{
					CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
				}
			}

			#endregion

			#region GetBytes conversions

			private byte[] GetBytes(long value, int bytes)
			{
				var buffer = new byte[bytes];
				CopyBytes(value, bytes, buffer, 0);
				return buffer;
			}

			public byte[] GetBytes(bool value)
			{
				return BitConverter.GetBytes(value);
			}

			public byte[] GetBytes(char value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(double value)
			{
				return GetBytes(DoubleToInt64Bits(value), 8);
			}

			public byte[] GetBytes(short value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(int value)
			{
				return GetBytes(value, 4);
			}

			public byte[] GetBytes(long value)
			{
				return GetBytes(value, 8);
			}

			public byte[] GetBytes(float value)
			{
				return GetBytes(SingleToInt32Bits(value), 4);
			}

			public byte[] GetBytes(ushort value)
			{
				return GetBytes(value, 2);
			}

			public byte[] GetBytes(uint value)
			{
				return GetBytes(value, 4);
			}

			public byte[] GetBytes(ulong value)
			{
				return GetBytes(unchecked((long)value), 8);
			}

			#endregion

			#region CopyBytes conversions

			private void CopyBytes(long value, int bytes, byte[] buffer, int index)
			{
				if (buffer == null)
				{
					throw new ArgumentNullException("buffer", "Byte array must not be null");
				}
				if (buffer.Length < index + bytes)
				{
					throw new ArgumentOutOfRangeException("Buffer not big enough for value");
				}
				CopyBytesImpl(value, bytes, buffer, index);
			}

			protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

			public void CopyBytes(bool value, byte[] buffer, int index)
			{
				CopyBytes(value ? 1 : 0, 1, buffer, index);
			}

			public void CopyBytes(char value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(double value, byte[] buffer, int index)
			{
				CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
			}

			public void CopyBytes(short value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(int value, byte[] buffer, int index)
			{
				CopyBytes(value, 4, buffer, index);
			}

			public void CopyBytes(long value, byte[] buffer, int index)
			{
				CopyBytes(value, 8, buffer, index);
			}

			public void CopyBytes(float value, byte[] buffer, int index)
			{
				CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
			}

			public void CopyBytes(ushort value, byte[] buffer, int index)
			{
				CopyBytes(value, 2, buffer, index);
			}

			public void CopyBytes(uint value, byte[] buffer, int index)
			{
				CopyBytes(value, 4, buffer, index);
			}

			public void CopyBytes(ulong value, byte[] buffer, int index)
			{
				CopyBytes(unchecked((long)value), 8, buffer, index);
			}

			#endregion

			#region Private struct used for Single/Int32 conversions

			[StructLayout(LayoutKind.Explicit)]
			private struct Int32SingleUnion
			{
				[FieldOffset(0)]
				private readonly int i;

				[FieldOffset(0)]
				private readonly float f;

				internal Int32SingleUnion(int i)
				{
					this.f = 0; // Just to keep the compiler happy
					this.i = i;
				}

				internal Int32SingleUnion(float f)
				{
					this.i = 0; // Just to keep the compiler happy
					this.f = f;
				}

				internal int AsInt32
				{
					get { return i; }
				}

				internal float AsSingle
				{
					get { return f; }
				}
			}

			#endregion
		}

		private sealed class BigEndianBitConverter : EndianBitConverter
		{
			public sealed override bool IsLittleEndian()
			{
				return false;
			}

			public sealed override Endianness Endianness
			{
				get { return Endianness.BigEndian; }
			}

			protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
			{
				var endOffset = index + bytes - 1;
				for (var i = 0; i < bytes; i++)
				{
					buffer[endOffset - i] = unchecked((byte)(value & 0xff));
					value = value >> 8;
				}
			}

			protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
			{
				long ret = 0;
				for (var i = 0; i < bytesToConvert; i++)
				{
					ret = unchecked((ret << 8) | buffer[startIndex + i]);
				}
				return ret;
			}
		}

		private sealed class LittleEndianBitConverter : EndianBitConverter
		{
			public sealed override bool IsLittleEndian()
			{
				return true;
			}

			public sealed override Endianness Endianness
			{
				get { return Endianness.LittleEndian; }
			}

			protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
			{
				for (var i = 0; i < bytes; i++)
				{
					buffer[i + index] = unchecked((byte)(value & 0xff));
					value = value >> 8;
				}
			}

			protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
			{
				long ret = 0;
				for (var i = 0; i < bytesToConvert; i++)
				{
					ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
				}
				return ret;
			}
		}

		/* end of Jon Skeet and Marc Gravell code */
		#endregion

		#endregion

		#region Serialization: JSON
		private void ReadJson(RpgGameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using(var patchJsonReader = new JsonReader(new StreamReader(patchStream, encoding), leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchJsonReader.ReadDocument());
					}
				}
			}

			using(var jsonReader = new JsonReader(new StreamReader(data, encoding), leaveOpen))
			{
				jsonReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private sealed partial class JsonReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
			private const int CHAR_SIZE = 2;

			const int LEXER_STATE_COMPLETE = -1;
			const int LEXER_STATE_START = 0;
			const int LEXER_STATE_LEXEME = 1;
			const int LEXER_STATE_QUOTED = 2;
			const int LEXER_STATE_QUOTED_ESCAPE = 3;
			const int LEXER_STATE_COMMENT_BEGINING = 4;
			const int LEXER_STATE_COMMENT_SINGLELINE = 5;
			const int LEXER_STATE_COMMENT_MULTILINE = 6;
			const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

			private const int NUMBER_FLOAT = 2;
			private const int NUMBER_FLOAT_WITH_EXP = 3;
			private const int NUMBER_INTEGER = 0;
			private const int NUMBER_NEGATIVE_INTEGER = 1;
			private const int NUMBER_NOT = -1;

			private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
			private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

			private readonly ArraySegment<char> LexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
			private readonly ArraySegment<char> LexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
			private readonly ArraySegment<char> LexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

			private readonly bool leaveOpen;
			private readonly TextReader textReader;

			// tokenizing
			private readonly char[] buffer;
			private int bufferOffset;
			private int bufferAvailable;
			private int lineNum = 1;
			private int colNum = 1;

			// parsing
			private ReaderNode node;
			private ArraySegment<char> rawJson;

			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;
			private StrongBox<int> intBox;
			private StrongBox<DateTime> dateBox;
			private JsonValueBox jsonValueBox;

			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			// statistics
			public override int LineNumber { get { return this.lineNum; } }
			public override int ColumnNumber { get { return this.colNum; } }

			public JsonReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (textReader == null) throw new ArgumentNullException("textReader");
				if (bufferSize <= 0) throw new ArgumentOutOfRangeException("bufferSize");

				this.buffer = new char[bufferSize];
				this.textReader = textReader;
				this.leaveOpen = leaveOpen;
			}

			public override bool NextToken()
			{
				this.rawJson = default(ArraySegment<char>);
				this.node = default(ReaderNode);

				var fragments = default(ArraySegment<char>[]);
				var state = LEXER_STATE_COMPLETE;
				var lexemeSize = 0;

				var lexeme = this.NextLexeme(ref state);
				if (lexeme.Count == 0)
				{
					this.node = new ReaderNode(ReaderToken.EndOfStream);
					return false;
				}
				if (state != LEXER_STATE_COMPLETE)
				{
					var firstFragment = Copy(ref lexeme);
					var secondFragment = this.NextLexeme(ref state);

					if (state == LEXER_STATE_COMPLETE)
					{
						if (secondFragment.Count == 0)
						{
							lexeme = firstFragment;
							lexemeSize = lexeme.Count;
						}
						else
						{
							fragments = new ArraySegment<char>[2] { firstFragment, secondFragment };
							lexemeSize = firstFragment.Count + secondFragment.Count;
						}
					}
					else
					{
						var fragmentIndex = 0;
						fragments = new ArraySegment<char>[8];
						fragments[fragmentIndex++] = firstFragment;
						fragments[fragmentIndex++] = Copy(ref secondFragment);
						lexemeSize = firstFragment.Count + secondFragment.Count;

						do
						{
							lexeme = this.NextLexeme(ref state);

							if (lexeme.Count == 0)
							{
								break;
							}
							if (fragmentIndex == fragments.Length)
							{
								Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
							}

							fragments[fragmentIndex++] = Copy(ref lexeme);
							lexemeSize += lexeme.Count;

						} while (state != LEXER_STATE_COMPLETE);
					}
				}
				else
				{
					lexemeSize = lexeme.Count;
				}

				if (lexemeSize == 1)
				{
					this.rawJson = fragments != null ? fragments[0] : lexeme;
					switch (rawJson.Array[rawJson.Offset])
					{
						case JsonNotation.Const0: this.node = new ReaderNode(ReaderToken.Value, this.Box(0)); return true;
						case JsonNotation.Const1: this.node = new ReaderNode(ReaderToken.Value, this.Box(1)); return true;
						case JsonNotation.Const2: this.node = new ReaderNode(ReaderToken.Value, this.Box(2)); return true;
						case JsonNotation.Const3: this.node = new ReaderNode(ReaderToken.Value, this.Box(3)); return true;
						case JsonNotation.Const4: this.node = new ReaderNode(ReaderToken.Value, this.Box(4)); return true;
						case JsonNotation.Const5: this.node = new ReaderNode(ReaderToken.Value, this.Box(5)); return true;
						case JsonNotation.Const6: this.node = new ReaderNode(ReaderToken.Value, this.Box(6)); return true;
						case JsonNotation.Const7: this.node = new ReaderNode(ReaderToken.Value, this.Box(7)); return true;
						case JsonNotation.Const8: this.node = new ReaderNode(ReaderToken.Value, this.Box(8)); return true;
						case JsonNotation.Const9: this.node = new ReaderNode(ReaderToken.Value, this.Box(9)); return true;
						case JsonNotation.BeginArray: this.node = new ReaderNode(ReaderToken.BeginArray); return true;
						case JsonNotation.BeginObject: this.node = new ReaderNode(ReaderToken.BeginObject); return true;
						case JsonNotation.EndArray: this.node = new ReaderNode(ReaderToken.EndOfArray); return true;
						case JsonNotation.EndObject: this.node = new ReaderNode(ReaderToken.EndOfObject); return true;
						default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
					}
				}
				if (lexemeSize == 4)
				{
					if (Match(ref lexeme, fragments, 0, LexemeTrue))
					{
						this.rawJson = LexemeTrue;
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						return true;
					}
					if (Match(ref lexeme, fragments, 0, LexemeNull))
					{
						this.rawJson = LexemeNull;
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					}
				}
				if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, LexemeFalse))
				{
					this.rawJson = LexemeFalse;
					this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
					return true;
				}

				// combine fragments into one lexeme
				if (fragments != null)
				{
					var combined = new char[lexemeSize];
					var offset = 0;
					foreach (var fragment in fragments)
					{
						if (fragment.Array == null) break;
						Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
						offset += fragment.Count;
					}
					lexeme = new ArraySegment<char>(combined, 0, offset);
					//fragments = null;
				}

				this.rawJson = lexeme;
				if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
				{
					if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
						throw ReaderException.UnterminatedStringLiteral(this);

					if (lexemeSize == 2)
					{
						this.node = new ReaderNode(ReaderToken.Value, string.Empty);
						return true;
					}
					{
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme));
					}
					return true;
				}

				switch (GetNumberType(ref lexeme))
				{
					case NUMBER_INTEGER:
						var integerType = lexeme.Count < Int32MaxLength
							? typeof(int)
							: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, integerType));
						return true;
					case NUMBER_NEGATIVE_INTEGER:
						var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, signedIntegerType));
						return true;
					case NUMBER_FLOAT:
					case NUMBER_FLOAT_WITH_EXP:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(ref lexeme, typeof(double)));
						return true;
					default:
						throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}

			private object Box(ref ArraySegment<char> lexeme)
			{
				if (this.jsonValueBox == null)
					this.jsonValueBox = new JsonValueBox(FormatProvider);

				this.jsonValueBox.Store(lexeme, typeof(string));

				return this.jsonValueBox;
			}
			private object Box(ref ArraySegment<char> lexeme, Type type)
			{
				if (type == null) throw new ArgumentNullException("type");

				if (this.jsonValueBox == null)
					this.jsonValueBox = new JsonValueBox(FormatProvider);

				this.jsonValueBox.Store(lexeme, type);
				return this.jsonValueBox;
			}
			private object Box(int value)
			{
				if (this.intBox == null)
					this.intBox = new StrongBox<int>(FormatProvider);

				this.intBox.Store(value);
				return this.intBox;
			}
			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);

				return this.intBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				if (this.falseBox == null)
					this.falseBox = new StrongBox<bool>(false, FormatProvider);
				return falseBox;
			}

			private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
			{
				var count = matchTo.Count;
				if (fragments == null)
				{
					for (int i = 0; i < count; i++)
					{
						if (lexeme.Array[lexeme.Offset + i] != matchTo.Array[matchTo.Offset + i])
							return false;
					}

					return true;
				}
				var mo = 0;
				foreach (var fg in fragments)
				{
					if (fg.Array == null) break;

					for (int i = 0; i < fg.Count; i++)
					{
						if (fg.Array[fg.Offset + i] != matchTo.Array[mo])
							return false;

						mo++;
					}
				}

				return true;
			}
			private static int GetNumberType(ref ArraySegment<char> lexeme)
			{
				const int INT_PART = 0;
				const int FRAC_PART = 1;
				const int EXP_PART = 2;
				const char POINT = '.';
				const char EXPONENT = 'E';
				const char EXPONENT_ALT = 'e';
				const char PLUS = '+';
				const char MINUS = '-';
				const char DIGIT_START = '0';
				const char DIGIT_END = '9';

				var isNegative = false;
				var buffer = lexeme.Array;
				var offset = lexeme.Offset;
				var count = lexeme.Offset + lexeme.Count;

				var part = INT_PART;

				for (var i = offset; i < count; i++)
				{
					var character = buffer[i];

					switch (part)
					{
						case INT_PART:
							switch (character)
							{
								case MINUS:
									if (i != offset)
									{
										return NUMBER_NOT;
									}
									isNegative = true;
									break;
								case PLUS:
									if (i != offset)
									{
										return NUMBER_NOT;
									}
									break;
								case POINT:
									if (i == offset)
									{
										return NUMBER_NOT; // decimal point as first character
									}
									part = FRAC_PART;
									break;
								default:
									if (character == EXPONENT || character == EXPONENT_ALT)
									{
										if (i == offset)
										{
											return NUMBER_NOT; // exponent at first character
										}
										part = EXP_PART;
									}
									else if (character < DIGIT_START && character > DIGIT_END)
									{
										return NUMBER_NOT; // non digit character in integer part
									}
									break;
							}
							break;
						case FRAC_PART:
							if (character == EXPONENT || character == EXPONENT_ALT)
							{
								if (i == offset)
								{
									return NUMBER_NOT; // exponent at first character
								}
								part = EXP_PART;
							}
							else if (character < DIGIT_START && character > DIGIT_END)
							{
								return NUMBER_NOT; // non digit character in fraction part
							}
							break;
						case EXP_PART:
							if (character == PLUS || character == MINUS)
							{
								if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
								{
									return NUMBER_NOT; // sign not at start of exponent part
								}
							}
							else if (character < DIGIT_START && character > DIGIT_END)
							{
								return NUMBER_NOT; // non digit character in integer part
							}
							break;
					}
				}

				switch (part)
				{
					case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
					case FRAC_PART: return NUMBER_FLOAT;
					case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
					default: return NUMBER_NOT;
				}
			}
			private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
			{
				var newLexeme = new ArraySegment<char>(new char[lexeme.Count], 0, lexeme.Count);
				Buffer.BlockCopy(lexeme.Array, lexeme.Offset * CHAR_SIZE, newLexeme.Array, 0, lexeme.Count * CHAR_SIZE);
				return newLexeme;
			}
			private static bool IsWhiteSpaceLatin(char character)
			{
				return character == ' ' || character >= '\t' && character <= '\r' || (character == ' ' || character == '\x0085');
			}
			private ArraySegment<char> NextLexeme(ref int state)
			{
				this.ResetBufferIfNeeded();

				var buffer = this.buffer;
				var lexemeStartIndex = this.bufferOffset;
				var lexemeLength = 0;

				start:
				if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
				{
					state = LEXER_STATE_COMPLETE;
					return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
				}

				if (state == LEXER_STATE_COMPLETE)
					state = LEXER_STATE_START;

				var bufferEnd = this.bufferOffset + this.bufferAvailable;
				for (var i = this.bufferOffset; i < bufferEnd; i++)
				{
					this.colNum++;
					switch (state)
					{
						case LEXER_STATE_START:
							switch (buffer[i])
							{
								case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
								case JsonNotation.Space:
								case JsonNotation.Return:
								case JsonNotation.Tab:
								case JsonNotation.IdentifierSeparator:
								case JsonNotation.ValueSeparator:
									continue; // insignificant whitespaces
								case JsonNotation.Comment:
									state = LEXER_STATE_COMMENT_BEGINING;
									continue;
								case JsonNotation.EndArray:
								case JsonNotation.EndObject:
								case JsonNotation.BeginObject:
								case JsonNotation.BeginArray:
									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i + 1;
									this.bufferAvailable = bufferEnd - i - 1;
									return new ArraySegment<char>(buffer, i, 1);
								case JsonNotation.Quote:
									lexemeStartIndex = i;
									state = LEXER_STATE_QUOTED;
									continue;
								default:
									if (IsWhiteSpaceLatin(buffer[i]))
									{
										goto case JsonNotation.Space;
									}
									lexemeStartIndex = i;
									state = LEXER_STATE_LEXEME;
									continue;
							}
						case LEXER_STATE_LEXEME:
							switch (buffer[i])
							{
								// lexeme terminators
								case JsonNotation.Space:
								case JsonNotation.Newline:
								case JsonNotation.Return:
								case JsonNotation.Tab:
								case JsonNotation.IdentifierSeparator:
								case JsonNotation.ValueSeparator:
								case JsonNotation.EndArray:
								case JsonNotation.EndObject:
								case JsonNotation.BeginObject:
								case JsonNotation.BeginArray:
									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i;
									this.bufferAvailable = bufferEnd - i;
									return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
								default:
									if (IsWhiteSpaceLatin(buffer[i]))
									{
										goto case JsonNotation.Space;
									}
									continue;
							}
						case LEXER_STATE_QUOTED:
						case LEXER_STATE_QUOTED_ESCAPE:
							switch (buffer[i])
							{
								case JsonNotation.Newline:
								case JsonNotation.Return:
									throw ReaderException.UnterminatedStringLiteral(this);
								case JsonNotation.Quote:
									if (state == LEXER_STATE_QUOTED_ESCAPE)
									{
										state = LEXER_STATE_QUOTED;
										continue;
									}

									state = LEXER_STATE_COMPLETE;
									this.bufferOffset = i + 1;
									this.bufferAvailable = bufferEnd - i - 1;
									return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
								case JsonNotation.Escape:
									state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
									continue;
								default:
									if (state == LEXER_STATE_QUOTED_ESCAPE)
									{
										state = LEXER_STATE_QUOTED;
									}
									continue;
							}
						case LEXER_STATE_COMMENT_BEGINING:
							switch (buffer[i])
							{
								case JsonNotation.Comment:
									state = LEXER_STATE_COMMENT_SINGLELINE;
									continue;
								case JsonNotation.CommentMultiline:
									state = LEXER_STATE_COMMENT_MULTILINE;
									continue;
								default:
									throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
							}
						case LEXER_STATE_COMMENT_SINGLELINE:
							switch (buffer[i])
							{
								case JsonNotation.Newline:
								case JsonNotation.Return:
									state = LEXER_STATE_START;
									continue;
								default: continue;
							}
						case LEXER_STATE_COMMENT_MULTILINE_ENDING:
						case LEXER_STATE_COMMENT_MULTILINE:
							switch (buffer[i])
							{
								case JsonNotation.CommentMultiline:
									state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
									continue;
								case JsonNotation.Comment:
									if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
										state = LEXER_STATE_START;
									continue;
								default: continue;
							}

					}
				}

				if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINING || state == LEXER_STATE_COMMENT_MULTILINE || 
					state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLELINE)
				{
					// no lexemes found in current buffer
					this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
					goto start; // restart
				}

				lexemeLength = bufferEnd - lexemeStartIndex;
			
				// buffer contains only fragment of lexeme
				// lexeme parsing is not complete so there is 2 options:
				// 1) try to fill buffer and retry parsing
				// 2) return fragment to caller

				if (lexemeLength < this.buffer.Length / 2)
				{
					// if fragment is small then move fragment to the start of the buffer and re-start parsing
					if (lexemeStartIndex != 0)
					{
						Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
						lexemeStartIndex = 0;
					}

					this.bufferOffset = lexemeLength;
					this.bufferAvailable = 0;

					goto start; // restart
				}
				else
				{
					// if fragment is huge then return it to caller

					// set buffer is consumed
					this.bufferOffset = this.bufferAvailable = 0;

					return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
				}
			}
			private void ResetBufferIfNeeded()
			{
				if (this.bufferAvailable == 0)
				{
					this.bufferOffset = 0;
				}
			}
			private int ReadToBuffer()
			{
				if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
				{
					throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
				}

				var offset = this.bufferOffset + this.bufferAvailable;
				var count = this.buffer.Length - offset;
				var read = this.textReader.Read(this.buffer, offset, count);
				this.bufferAvailable += read;
				return read;
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.textReader.Dispose();
			}

			private sealed class JsonValueBox : IStrongBox
			{
				private readonly IFormatProvider formatProvider;
				private ArraySegment<char> value;
				private Type valueType;

				public Type ValueType { get { return this.valueType; } }

				public bool AsBoolean { get { return Convert.ToBoolean(this.LoadString(), FormatProvider); } }
				public byte AsByte { get { return checked((byte)this.LoadUInt32()); } }
				public short AsInt16 { get { return checked((short)this.LoadInt32()); } }
				public int AsInt32 { get { return this.LoadInt32(); } }
				public long AsInt64 { get { return this.LoadInt64(); } }
				public sbyte AsSByte { get { return checked((sbyte)this.LoadInt32()); } }
				public ushort AsUInt16 { get { return checked((ushort)this.LoadUInt32()); } }
				public uint AsUInt32 { get { return this.LoadUInt32(); } }
				public ulong AsUInt64 { get { return this.LoadUInt64(); } }
				public float AsSingle { get { return Convert.ToSingle(this.LoadString(), FormatProvider); } }
				public double AsDouble { get { return Convert.ToDouble(this.LoadString(), FormatProvider); } }
				public decimal AsDecimal { get { return Convert.ToDecimal(this.LoadString(), FormatProvider); } }
				public object AsObject { get { return this.LoadString(); } }

				public JsonValueBox(IFormatProvider formatProvider)
				{
					if (formatProvider == null) throw new ArgumentNullException("formatProvider");

					this.formatProvider = formatProvider;
				}

				private uint LoadUInt32()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToUInt32(array, offset, count, this.formatProvider);
				}
				private ulong LoadUInt64()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToUInt64(array, offset, count, this.formatProvider);
				}
				private int LoadInt32()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToInt32(array, offset, count, this.formatProvider);
				}
				private long LoadInt64()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.StringToInt64(array, offset, count, this.formatProvider);
				}
				private string LoadString()
				{
					var array = this.value.Array;
					var offset = this.value.Offset;
					var count = this.value.Count;

					if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
					{
						offset++;
						count -= 2;
					}

					return JsonUtils.UnEscapeBuffer(array, offset, count, false);
				}

				public void Store<T>(T value)
				{
					this.value = (ArraySegment<char>)(object)value;
					this.valueType = typeof(string);
				}

				public void Store(ArraySegment<char> value, Type valueType)
				{
					if (valueType == null) throw new ArgumentNullException("valueType");

					this.value = value;
					this.valueType = valueType;
				}

				public override string ToString()
				{
					return this.LoadString();
				}
			}

			private static class JsonUtils
			{
				public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
				{
					if (charsToUnEscape == null) throw new ArgumentNullException("charsToUnEscape");
					if (offset < 0) throw new ArgumentOutOfRangeException("offset");
					if (count < 0) throw new ArgumentOutOfRangeException("count");
					if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException("offset");

					var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
					if (unEscapedCount == count)
					{
						return new string(charsToUnEscape, offset, count);
					}

					var resultBuilder = new StringBuilder(unEscapedCount);
					var plainStart = offset;
					var plainLen = 0;
					var end = offset + count;
					for (var i = offset; i < end; i++)
					{
						var ch = charsToUnEscape[i];
						if (ch != '\\')
						{
							plainLen++;
							continue;
						}

						if (i + 1 >= end)
						{
							if (strict)
							{
								throw ReaderException.UnknownEscapeSequence("\\\0", null);
							}
							else
							{
								plainLen++;
								break; // u
							}
						}

						var sequenceLength = 1;
						// append unencoded chunk
						if (plainLen != 0)
						{
							resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
							plainLen = 0;
						}

						var sequenceKind = charsToUnEscape[i + 1];
						switch (sequenceKind)
						{
							case 'n':
								resultBuilder.Append('\n');
								break;
							case 'r':
								resultBuilder.Append('\r');
								break;
							case 'b':
								resultBuilder.Append('\b');
								break;
							case 'f':
								resultBuilder.Append('\f');
								break;
							case 't':
								resultBuilder.Append('\t');
								break;
							case '\\':
								resultBuilder.Append('\\');
								break;
							case '/':
								resultBuilder.Append('/');
								break;
							case '\'':
								resultBuilder.Append('\'');
								break;
							case '\"':
								resultBuilder.Append('\"');
								break;

							// unicode symbol
							case 'u':
								resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
								sequenceLength = 5;
								break;

							// latin hex encoded symbol
							case 'x':
								resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
								sequenceLength = 3;
								break;

							// latin dec encoded symbol
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
							case '0':
								resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
								sequenceLength = 3;
								break;
							default:
								if (!strict)
								{
									resultBuilder.Append(sequenceKind);
									break;
								}
								else
								{
									throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
								}
						}

						// set next chunk start right after this escape
						plainStart = i + sequenceLength + 1;
						i += sequenceLength;
					}

					// append last unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
					}

					return resultBuilder.ToString();
				}
				private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
				{
					if (charsToUnEscape == null) throw new ArgumentNullException("charsToUnEscape");
					if (offset < 0) throw new ArgumentOutOfRangeException("offset");
					if (count < 0) throw new ArgumentOutOfRangeException("count");
					if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException("offset");

					var newCount = 0;
					var end = offset + count;
					for (var i = offset; i < end; i++)
					{
						var ch = charsToUnEscape[i];
						newCount++;
						if (ch != '\\')
						{
							continue;
						}

						var toSkip = 1;
						var sequenceKind = charsToUnEscape[i + 1];
						switch (sequenceKind)
						{
							// unicode symbol
							case 'u':
								toSkip = 5;
								break;

							// latin hex encoded symbol
							case 'x':
								toSkip = 3;
								break;
							// latin dec encoded symbol
							case '1':
							case '2':
							case '3':
							case '4':
							case '5':
							case '6':
							case '7':
							case '8':
							case '9':
							case '0':
								toSkip = 3;
								break;
							default:
								toSkip = 1;
								break;
						}
						i += toSkip;
					}
					return newCount;
				}

				public static uint HexStringToUInt32(char[] buffer, int offset, int count)
				{
					const uint ZERO = (ushort)'0';
					const uint a = (ushort)'a';
					const uint A = (ushort)'A';

					var result = 0u;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						var d = 0u;
						if (c >= '0' && c <= '9')
							d = (c - ZERO);
						else if (c >= 'a' && c <= 'f')
							d = 10u + (c - a);
						else if (c >= 'A' && c <= 'F')
							d = 10u + (c - A);
						else
							throw new FormatException();

						result = 16u * result + d;
					}

					return result;
				}

				public static long StringToInt64(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const ulong ZERO = (ushort)'0';

					var result = 0UL;
					var neg = false;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (i == 0 && c == '-')
						{
							neg = true;
							continue;
						}
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10UL * result + (c - ZERO));
					}

					if (neg)
						return -(long)(result);
					return (long)result;
				}
				public static int StringToInt32(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const uint ZERO = (ushort)'0';

					var result = 0u;
					var neg = false;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (i == 0 && c == '-')
						{
							neg = true;
							continue;
						}
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10u * result + (c - ZERO));
					}

					if (neg)
						return -(int)(result);
					return (int)result;
				}
				public static ulong StringToUInt64(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const ulong ZERO = (ushort)'0';

					var result = 0UL;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10UL * result + (c - ZERO));
					}

					return result;
				}
				public static uint StringToUInt32(char[] buffer, int offset, int count, IFormatProvider formatProvider = null)
				{
					const uint ZERO = (ushort)'0';

					var result = 0U;
					for (var i = 0; i < count; i++)
					{
						var c = buffer[offset + i];
						if (c < '0' || c > '9')
							throw new FormatException();

						result = checked(10 * result + (c - ZERO));
					}

					return result;
				}
			}

			private static class JsonNotation
			{
				public const char Tab = '\t';
				public const char Space = ' ';
				public const char Newline = '\n';
				public const char Return = '\r';
				public const char IdentifierSeparator = ':';
				public const char ValueSeparator = ',';
				public const char BeginArray = '[';
				public const char EndArray = ']';
				public const char BeginObject = '{';
				public const char EndObject = '}';
				public const char Escape = '\\';
				public const char Comment = '/';
				public const char CommentMultiline = '*';
				public const char Quote = '\"';
				public const char Const0 = '0';
				public const char Const1 = '1';
				public const char Const2 = '2';
				public const char Const3 = '3';
				public const char Const4 = '4';
				public const char Const5 = '5';
				public const char Const6 = '6';
				public const char Const7 = '7';
				public const char Const8 = '8';
				public const char Const9 = '9';
				public const string True = "true";
				public const string False = "false";
				public const string Null = "null";
			}
		}
		#endregion

		#region Serialization: Message Pack
		private void ReadMessagePack(RpgGameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using(var patchMsgPackReader = new MessagePackReader(patchStream, leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchMsgPackReader.ReadDocument());
					}
				}
			}

			using (var msgPackReader = new MessagePackReader(data, leaveOpen))
			{
				msgPackReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private sealed class MessagePackReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
			private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
			private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

			internal struct Map
			{
				public ReaderToken Token;
				public long Counter;
			}

			private readonly Stream inputStream;
			private readonly bool leaveOpen;
			private readonly byte[] buffer;
			private readonly EndianBitConverter bitConverter;
			private readonly Stack<Map> maps;
			private ReaderNode node;
			private int bufferOffset;
			private int bufferReaded;
			private int bufferAvailable;
			private int totalBytesReaded;

			private StrongBox<int> int32Box;
			private StrongBox<uint> uInt32Box;
			private StrongBox<long> int64Box;
			private StrongBox<ulong> uInt64Box;
			private StrongBox<float> singleBox;
			private StrongBox<double> doubleBox;
			private StrongBox<decimal> decimalBox;
			private StrongBox<DateTime> dateBox;
			private StrongBox<DateTimeOffset> dateOffsetBox;
			private StrongBox<TimeSpan> timeSpanBox;
			private StrongBox<Guid> guidBox;
			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;

			public override int LineNumber { get { return 0; } }
			public override int ColumnNumber { get { return this.totalBytesReaded; } }
			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			public MessagePackReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (stream == null) throw new ArgumentNullException("stream");

				if (bufferSize < DEFAULT_BUFFER_SIZE)
					bufferSize = DEFAULT_BUFFER_SIZE;

				this.inputStream = stream;
				this.leaveOpen = leaveOpen;
				this.buffer = new byte[bufferSize];
				this.bufferOffset = 0;
				this.bufferReaded = 0;
				this.bufferAvailable = 0;
				this.bitConverter = EndianBitConverter.Big;
				this.maps = new Stack<Map>();
			}

			public override bool NextToken()
			{
				if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
				{
					var closingToken = this.maps.Pop();
					this.node = new ReaderNode(closingToken.Token);

					this.DecrementClosingTokenCounter();
					return true;
				}

				if (!this.ReadToBuffer(1, throwOnEos: false))
				{
					this.node = new ReaderNode(ReaderToken.EndOfStream);
					return false;
				}

				var formatValue = buffer[this.bufferOffset];
				if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
				{
					var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

					this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
					this.node = new ReaderNode(ReaderToken.BeginArray);
				}
				else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
				{
					var strCount = formatValue - (byte)MessagePackType.FixStrStart;
					var strBytes = this.ReadBytes(strCount);

					var token = ReaderToken.Value;
					if (this.maps.Count > 0)
					{
						var closingToken = this.maps.Peek();
						if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
							token = ReaderToken.Member;
					}

					var strValue = default(string);

					{
						strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
					}

					this.node = new ReaderNode(token, strValue);
				}
				else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
				{
					var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
					this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
					this.node = new ReaderNode(ReaderToken.BeginObject);
				}
				else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
				{
					var value = unchecked((sbyte)formatValue);
					this.node = new ReaderNode(ReaderToken.Value, this.Box(value));
				}
				else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
				{
					var value = unchecked((byte)formatValue);
					this.node = new ReaderNode(ReaderToken.Value, this.Box(value));
				}
				else
				{
					switch ((MessagePackType)formatValue)
					{
						case MessagePackType.Nil:
							this.node = new ReaderNode(ReaderToken.Null);
							break;
						case MessagePackType.Array16:
						case MessagePackType.Array32:
							var arrayCount = 0L;
							if (formatValue == (int)MessagePackType.Array16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								arrayCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Array32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								arrayCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

							this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
							this.node = new ReaderNode(ReaderToken.BeginArray);
							break;
						case MessagePackType.Map16:
						case MessagePackType.Map32:
							var mapCount = 0L;
							if (formatValue == (int)MessagePackType.Map16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								mapCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Map32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								mapCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

							this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
							this.node = new ReaderNode(ReaderToken.BeginObject);
							break;
						case MessagePackType.Str16:
						case MessagePackType.Str32:
						case MessagePackType.Str8:
							var strBytesCount = 0L;
							if (formatValue == (int)MessagePackType.Str8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								strBytesCount = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Str16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								strBytesCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Str32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								strBytesCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							var token = ReaderToken.Value;
							if (this.maps.Count > 0)
							{
								var closingToken = this.maps.Peek();
								if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
									token = ReaderToken.Member;
							}

							if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);
							if (strBytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of string");

							var strBytes = this.ReadBytes(strBytesCount);
							var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
							this.node = new ReaderNode(token, stringValue);
							break;
						case MessagePackType.Bin32:
						case MessagePackType.Bin16:
						case MessagePackType.Bin8:
							var bytesCount = 0L;
							if (formatValue == (int)MessagePackType.Bin8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								bytesCount = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Bin16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								bytesCount = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Bin32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								bytesCount = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
							if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

							var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
							this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
							break;
						case MessagePackType.FixExt1:
						case MessagePackType.FixExt16:
						case MessagePackType.FixExt2:
						case MessagePackType.FixExt4:
						case MessagePackType.FixExt8:
						case MessagePackType.Ext32:
						case MessagePackType.Ext16:
						case MessagePackType.Ext8:
							var extLength = 0L;
							if (formatValue == (int)MessagePackType.FixExt1)
								extLength = 1;
							else if (formatValue == (int)MessagePackType.FixExt2)
								extLength = 2;
							else if (formatValue == (int)MessagePackType.FixExt4)
								extLength = 4;
							else if (formatValue == (int)MessagePackType.FixExt8)
								extLength = 8;
							else if (formatValue == (int)MessagePackType.FixExt16)
								extLength = 16;
							if (formatValue == (int)MessagePackType.Ext8)
							{
								this.ReadToBuffer(1, throwOnEos: true);
								extLength = this.buffer[this.bufferOffset];
							}
							else if (formatValue == (int)MessagePackType.Ext16)
							{
								this.ReadToBuffer(2, throwOnEos: true);
								extLength = bitConverter.ToUInt16(this.buffer, this.bufferOffset);
							}
							else if (formatValue == (int)MessagePackType.Ext32)
							{
								this.ReadToBuffer(4, throwOnEos: true);
								extLength = bitConverter.ToUInt32(this.buffer, this.bufferOffset);
							}

							this.ReadToBuffer(1, throwOnEos: true);
							var extType = buffer[this.bufferOffset];

							if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);
							if (extLength < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

							var data = this.ReadBytes(extLength, forceNewBuffer: true);
							if (!this.TryReadExtType(extType, data, out this.node))
								this.node = new ReaderNode(ReaderToken.Value, data.Array);
							break;
						case MessagePackType.False:
							this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
							break;
						case MessagePackType.True:
							this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
							break;
						case MessagePackType.Float32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToSingle(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Float64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToDouble(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int16:
							this.ReadToBuffer(2, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt16(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt32(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToInt64(buffer, this.bufferOffset)));
							break;
						case MessagePackType.Int8:
							this.ReadToBuffer(1, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)buffer[this.bufferOffset])));
							break;
						case MessagePackType.UInt16:
							this.ReadToBuffer(2, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)bitConverter.ToUInt16(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt32:
							this.ReadToBuffer(4, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToUInt32(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt64:
							this.ReadToBuffer(8, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box(bitConverter.ToUInt64(buffer, this.bufferOffset)));
							break;
						case MessagePackType.UInt8:
							this.ReadToBuffer(1, throwOnEos: true);
							this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)buffer[this.bufferOffset]));
							break;
						case MessagePackType.PositiveFixIntStart:
						case MessagePackType.PositiveFixIntEnd:
						case MessagePackType.FixMapStart:
						case MessagePackType.FixMapEnd:
						case MessagePackType.FixArrayStart:
						case MessagePackType.FixArrayEnd:
						case MessagePackType.FixStrStart:
						case MessagePackType.FixStrEnd:
						case MessagePackType.Unused:
						case MessagePackType.NegativeFixIntStart:
						case MessagePackType.NegativeFixIntEnd:
						default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
					}
				}

				this.DecrementClosingTokenCounter();

				return true;
			}

			private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
			{
				this.bufferAvailable -= this.bufferReaded;
				this.bufferOffset += this.bufferReaded;
				this.bufferReaded = 0;

				if (this.bufferAvailable < bytesRequired)
				{
					if (this.bufferAvailable > 0)
						Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

					this.bufferOffset = 0;
					while (this.bufferAvailable < bytesRequired)
					{
						var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
						this.bufferAvailable += read;

						if (read != 0 || this.bufferAvailable >= bytesRequired)
							continue;

						if (throwOnEos)
							throw ReaderException.UnexpectedEndOfStream(this);
						else
							return false;
					}
				}

				this.bufferReaded = bytesRequired;
				this.totalBytesReaded += bytesRequired;
				return true;
			}
			private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
			{
				if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException("bytesRequired");

				this.bufferAvailable -= this.bufferReaded;
				this.bufferOffset += this.bufferReaded;
				this.bufferReaded = 0;

				if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
				{
					var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

					this.bufferAvailable -= (int)bytesRequired;
					this.bufferOffset += (int)bytesRequired;
					this.totalBytesReaded += (int)bytesRequired;

					return bytes;
				}
				else
				{
					var bytes = new byte[bytesRequired];
					var bytesOffset = 0;
					if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
					{
						var bytesToCopy = Math.Min(bytes.Length - bytesOffset, this.bufferAvailable);
						Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

						bytesOffset += bytesToCopy;
						this.bufferOffset += bytesToCopy;

						this.bufferAvailable -= bytesToCopy;
						this.totalBytesReaded += bytesToCopy;
					}

					if (this.bufferAvailable == 0)
						this.bufferOffset = 0;

					while (bytesOffset < bytes.Length)
					{
						var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

						bytesOffset += read;
						this.totalBytesReaded += read;

						if (read == 0 && bytesOffset < bytes.Length)
							throw ReaderException.UnexpectedEndOfStream(this);
					}

					return new ArraySegment<byte>(bytes, 0, bytes.Length);
				}
			}
			private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
			{
				const byte EXTENSION_TYPE_TIMESTAMP = 255;
				const byte EXTENSION_TYPE_DATE_TIME = 40;
				const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
				const byte EXTENSION_TYPE_DECIMAL = 42;
				const byte EXTENSION_TYPE_GUID = 43;
				const byte GUID_SIZE = 16;
				const byte DECIMAL_SIZE = 16;
				const byte DATE_TIME_SIZE = 16;
				const byte DATE_TIME_OFFSET_SIZE = 16;

				node = default(ReaderNode);
				switch (extType)
				{
					case EXTENSION_TYPE_TIMESTAMP:
						unchecked
						{
							var seconds = 0L;
							var nanoSeconds = 0u;
							switch (data.Count)
							{
								case 4:
									seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
									break;
								case 8:
									var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
									seconds = (int) (data64 & 0x00000003ffffffffL);
									nanoSeconds = (uint) (data64 >> 34 & uint.MaxValue);
									break;
								case 12:
									nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
									seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
									break;
								default:
									return false;
							}
							node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
							return true;
						}
					case EXTENSION_TYPE_DATE_TIME:
						if (data.Count != DATE_TIME_SIZE)
							return false;
							var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
							node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
						return true;
					case EXTENSION_TYPE_DATE_TIME_OFFSET:
						if (data.Count != DATE_TIME_OFFSET_SIZE)
							return false;
						var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
						var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
						var dateTimeOffset = new DateTimeOffset(ticks, offset);
						node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
						return true;
					case EXTENSION_TYPE_DECIMAL:
						if (data.Count != DECIMAL_SIZE)
							return false;
						var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
						node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
						return true;
					case EXTENSION_TYPE_GUID:
						if (data.Count != GUID_SIZE)
							return false;

						var buffer = data.Array;
						unchecked
						{
							var guidValue = new Guid
							(
									(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
									(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
									(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
									buffer[data.Offset + 8],
									buffer[data.Offset + 9],
									buffer[data.Offset + 10],
									buffer[data.Offset + 11],
									buffer[data.Offset + 12],
									buffer[data.Offset + 13],
									buffer[data.Offset + 14],
									buffer[data.Offset + 15]
							);

							node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
							return true;
						}
					default:
						return false;
				}
			}

			private object Box(int value)
			{
				if (this.int32Box == null)
					this.int32Box = new StrongBox<int>(FormatProvider);

				this.int32Box.Store(value);

				return this.int32Box;
			}
			private object Box(uint value)
			{
				if (this.uInt32Box == null)
					this.uInt32Box = new StrongBox<uint>(FormatProvider);

				this.uInt32Box.Store(value);

				return this.uInt32Box;
			}
			private object Box(long value)
			{
				if (this.int64Box == null)
					this.int64Box = new StrongBox<long>(FormatProvider);

				this.int64Box.Store(value);

				return this.int64Box;
			}
			private object Box(ulong value)
			{
				if (this.uInt64Box == null)
					this.uInt64Box = new StrongBox<ulong>(FormatProvider);

				this.uInt64Box.Store(value);

				return this.uInt64Box;
			}
			private object Box(float value)
			{
				if (this.singleBox == null)
					this.singleBox = new StrongBox<float>(FormatProvider);

				this.singleBox.Store(value);

				return this.singleBox;
			}
			private object Box(double value)
			{
				if (this.doubleBox == null)
					this.doubleBox = new StrongBox<double>(FormatProvider);

				this.doubleBox.Store(value);

				return this.doubleBox;
			}
			private object Box(decimal value)
			{
				if (this.decimalBox == null)
					this.decimalBox = new StrongBox<decimal>(FormatProvider);

				this.decimalBox.Store(value);

				return this.decimalBox;
			}
			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);
				return this.dateBox;
			}
			private object Box(DateTimeOffset value)
			{
				if (this.dateOffsetBox == null)
					this.dateOffsetBox = new StrongBox<DateTimeOffset>(FormatProvider);

				this.dateOffsetBox.Store(value);
				return this.dateOffsetBox;
			}
			private object Box(TimeSpan value)
			{
				if (this.timeSpanBox == null)
					this.timeSpanBox = new StrongBox<TimeSpan>(FormatProvider);

				this.timeSpanBox.Store(value);
				return this.timeSpanBox;
			}
			private object Box(Guid value)
			{
				if (this.guidBox == null)
					this.guidBox = new StrongBox<Guid>(FormatProvider);

				this.guidBox.Store(value);
				return this.guidBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				else
				{
					if (this.falseBox == null)
						this.falseBox = new StrongBox<bool>(false, FormatProvider);
					return falseBox;
				}
			}

			private void DecrementClosingTokenCounter()
			{
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Pop();
					closingToken.Counter--;
					this.maps.Push(closingToken);
				}
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.inputStream.Dispose();
			}


			private enum MessagePackType : byte
			{
				PositiveFixIntStart = 0x00,
				PositiveFixIntEnd = 0x7f,
				FixMapStart = 0x80,
				FixMapEnd = 0x8f,
				FixArrayStart = 0x90,
				FixArrayEnd = 0x9f,
				FixStrStart = 0xa0,
				FixStrEnd = 0xbf,
				Nil = 0xc0,
				Unused = 0xc1,
				False = 0xc2,
				True = 0xc3,
				Bin8 = 0xc4,
				Bin16 = 0xc5,
				Bin32 = 0xc6,
				Ext8 = 0xc7,
				Ext16 = 0xc8,
				Ext32 = 0xc9,
				Float32 = 0xca,
				Float64 = 0xcb,
				UInt8 = 0xcc,
				UInt16 = 0xcd,
				UInt32 = 0xce,
				UInt64 = 0xcf,
				Int8 = 0xd0,
				Int16 = 0xd1,
				Int32 = 0xd2,
				Int64 = 0xd3,
				FixExt1 = 0xd4,
				FixExt2 = 0xd5,
				FixExt4 = 0xd6,
				FixExt8 = 0xd7,
				FixExt16 = 0xd8,
				Str8 = 0xd9,
				Str16 = 0xda,
				Str32 = 0xdb,
				Array16 = 0xdc,
				Array32 = 0xdd,
				Map16 = 0xde,
				Map32 = 0xdf,
				NegativeFixIntStart = 0xe0,
				NegativeFixIntEnd = 0xff
			}

			private enum MessagePackExtentionType : byte
			{
				None = 0,
				DateTime = 40,
				DateTimeOffset = 41,
				Decimal = 42
			}
		}
		#endregion

		#region Serialization: BSON
		private void ReadBson(RpgGameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach(var patchStream in patches)
				{
					using (var patchBsonReader = new BsonReader(patchStream, leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchBsonReader.ReadDocument());
					}
				}
			}

			using(var bsonReader = new BsonReader(data, leaveOpen))
			{
				bsonReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private class BsonReader : Reader, IDisposable
		{
			private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
			private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
			private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

			private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

			private struct Document
			{
				public readonly int Length;
				public readonly BsonType Type;
				public readonly int End;

				public Document(BsonType docType, int length, int end)
				{
					this.Type = docType;
					this.Length = length;
					this.End = end;
				}
			}

			private readonly Stream inputStream;
			private readonly bool leaveOpen;
			private readonly byte[] buffer;
			private readonly byte[] literalBuffer;
			private readonly EndianBitConverter bitConverter;
			private readonly Stack<Document> documents;
			private ReaderNode node;
			private int bufferOffset;
			private int bufferRead;
			private int bufferAvailable;
			private int totalBytesReaded;
			private BsonType memberType;

			private StrongBox<int> int32Box;
			private StrongBox<long> int64Box;
			private StrongBox<double> doubleBox;
			private StrongBox<decimal> decimalBox;
			private StrongBox<DateTime> dateBox;
			private StrongBox<DateTimeOffset> dateOffsetBox;
			private StrongBox<TimeSpan> timeSpanBox;
			private StrongBox<Guid> guidBox;
			private StrongBox<bool> trueBox;
			private StrongBox<bool> falseBox;

			public override int LineNumber { get { return 0; } }
			public override int ColumnNumber { get { return this.totalBytesReaded; } }
			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

			public BsonReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			{
				if (stream == null) throw new ArgumentNullException("stream");

				if (bufferSize < DEFAULT_BUFFER_SIZE)
					bufferSize = DEFAULT_BUFFER_SIZE;

				this.inputStream = stream;
				this.leaveOpen = leaveOpen;
				this.buffer = new byte[bufferSize];
				this.literalBuffer = new byte[bufferSize];
				this.bufferOffset = 0;
				this.bufferRead = 0;
				this.bufferAvailable = 0;
				this.bitConverter = EndianBitConverter.Little;
				this.documents = new Stack<Document>();
			}

			public override bool NextToken()
			{
				var length = 0;
				var end = 0;
				if (this.documents.Count == 0)
				{
					if (!this.ReadToBuffer(4, throwOnEos: false))
					{
						this.node = new ReaderNode(ReaderToken.EndOfStream);
						return false;
					}
					length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
					end = length <= 0 ? 0 : this.totalBytesReaded - this.bufferRead + length;
					var newDocument = new Document(BsonType.Document, length, end);
					this.documents.Push(newDocument);
					this.node = new ReaderNode(ReaderToken.BeginObject);
					return true;
				}

				var document = this.documents.Peek();
				if (this.memberType == BsonType.None)
				{
					this.ReadToBuffer(1, throwOnEos: true);
					memberType = (BsonType)this.buffer[this.bufferOffset];
					if (memberType != BsonType.None && document.Type == BsonType.Document)
					{
						var memberName = this.ReadCString();
						this.node = new ReaderNode(ReaderToken.Member, memberName);
						return true;
					}
					else if (memberType != BsonType.None)
					{
						this.SkipCString();
					}
				}

				var type = this.memberType;
				this.memberType = BsonType.None;
				switch (type)
				{
					case BsonType.Double:
						this.ReadToBuffer(8, throwOnEos: true);
						var doubleValue = this.bitConverter.ToDouble(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(doubleValue));
						return true;
					case BsonType.String:
						var stringValue = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, stringValue);
						return true;
					case BsonType.Array:
					case BsonType.Document:
						this.ReadToBuffer(4, throwOnEos: true);
						length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						end = length <= 0 ? 0 : this.totalBytesReaded - this.bufferRead + length;
						var newDocument = new Document(type, length, end);
						this.documents.Push(newDocument);
						this.node = new ReaderNode(type == BsonType.Document ? ReaderToken.BeginObject : ReaderToken.BeginArray);
						return true;
					case BsonType.Binary:
						const int GUID_SIZE = 16;
						const int DECIMAL_SIZE = 16;
						const int DATE_TIME_SIZE = 16;
						const int DATE_TIME_OFFSET_SIZE = 16;

						this.ReadToBuffer(5, throwOnEos: true);
						length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);

						if (length > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, length, MAX_BINARY_LENGTH);
						if (length < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var binaryType = (BsonBinaryType)this.buffer[this.bufferOffset + 4];
						switch (binaryType)
						{
							case BsonBinaryType.Decimal:
								if (length < DECIMAL_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var decimalValue = this.bitConverter.ToDecimal(this.buffer, this.bufferOffset);
								this.node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
								return true;
							case BsonBinaryType.DateTime:
								if (length < DATE_TIME_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var dateTime = new DateTime(this.bitConverter.ToInt64(this.buffer, this.bufferOffset + 1), (DateTimeKind)this.buffer[this.bufferOffset]);
								this.node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
								return true;
							case BsonBinaryType.DateTimeOffset:
								if (length < DATE_TIME_OFFSET_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");
								var ticks = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
								var offsetTicks = this.bitConverter.ToInt64(this.buffer, this.bufferOffset + 8);
								var dateTimeOffset = new DateTimeOffset(ticks, new TimeSpan(offsetTicks));
								this.node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
								return true;
							case BsonBinaryType.UUID:
								if (length != GUID_SIZE)
									throw ReaderException.ReadingBrokenDocument(this, "wrong size of binary data");

								unchecked
								{
									var guidValue = new Guid
									(
										(uint)(this.buffer[this.bufferOffset + 3] << 24 | this.buffer[this.bufferOffset + 2] << 16 | this.buffer[this.bufferOffset + 1] << 8 | this.buffer[this.bufferOffset + 0]),
										(ushort)(this.buffer[this.bufferOffset + 5] << 8 | this.buffer[this.bufferOffset + 4]),
										(ushort)(this.buffer[this.bufferOffset + 7] << 8 | this.buffer[this.bufferOffset + 6]),
										this.buffer[this.bufferOffset + 8],
										this.buffer[this.bufferOffset + 9],
										this.buffer[this.bufferOffset + 10],
										this.buffer[this.bufferOffset + 11],
										this.buffer[this.bufferOffset + 12],
										this.buffer[this.bufferOffset + 13],
										this.buffer[this.bufferOffset + 14],
										this.buffer[this.bufferOffset + 15]
									);

									this.node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
								}
								return true;
							case BsonBinaryType.Bytes:
							case BsonBinaryType.Function:
							case BsonBinaryType.BytesOld:
							case BsonBinaryType.UUIDOld:
							case BsonBinaryType.MD5:
							case BsonBinaryType.UserDefined:
							default:
								var bytes = this.ReadBytes(length, forceNewBuffer: true);
								this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
								return true;
						}
					case BsonType.Undefined:
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					case BsonType.ObjectId:
						var objectIdStr = this.ReadObjectId();
						this.node = new ReaderNode(ReaderToken.Value, objectIdStr);
						return true;
					case BsonType.Boolean:
						this.ReadToBuffer(1, throwOnEos: true);
						var boolValue = this.buffer[this.bufferOffset] > 0;
						this.node = new ReaderNode(ReaderToken.Value, this.Box(boolValue));
						return true;
					case BsonType.DateTime:
						this.ReadToBuffer(8, throwOnEos: true);
						var dateTimeMilliseconds = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(Epoch.AddTicks(checked(dateTimeMilliseconds * TimeSpan.TicksPerMillisecond))));
						return true;
					case BsonType.Null:
						this.node = new ReaderNode(ReaderToken.Null);
						return true;
					case BsonType.Regex:
						var regexPattern = this.ReadCString();
						var regexOptions = this.ReadCString();
						this.node = new ReaderNode(ReaderToken.Value, string.Concat("/", regexPattern, "/", regexOptions));
						return true;
					case BsonType.Reference:
						var reference = this.ReadUtf8String();
						var referenceId = this.ReadObjectId();
						this.node = new ReaderNode(ReaderToken.Value, reference + " -> " + referenceId);
						return true;
					case BsonType.JavaScript:
						var javascriptCode = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, javascriptCode);
						return true;
					case BsonType.JavaScriptWithScope:
						this.ReadToBuffer(4, throwOnEos: true);
						var javascriptScopedCode = this.ReadUtf8String();
						this.memberType = BsonType.Document;
						this.ReadAny(nextToken: false); // scope
						this.node = new ReaderNode(ReaderToken.Value, javascriptScopedCode);
						return true;
					case BsonType.Symbol:
						var symbolString = this.ReadUtf8String();
						this.node = new ReaderNode(ReaderToken.Value, symbolString);
						return true;
					case BsonType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						var intValue = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(intValue));
						return true;
					case BsonType.Timestamp:
						this.ReadToBuffer(8, throwOnEos: true);
						var timestampSeconds = (this.bitConverter.ToInt64(this.buffer, this.bufferOffset) & uint.MaxValue);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(Epoch.AddTicks(checked(timestampSeconds * TimeSpan.TicksPerSecond))));
						return true;
					case BsonType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						var longValue = this.bitConverter.ToInt64(this.buffer, this.bufferOffset);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(longValue));
						return true;
					case BsonType.MinKey:
						this.node = new ReaderNode(ReaderToken.Value, "min");
						return true;
					case BsonType.MaxKey:
						this.node = new ReaderNode(ReaderToken.Value, "max");
						return true;
					case BsonType.None:
						if (this.documents.Count == 0)
							goto default;

						document = this.documents.Pop();
						if (document.End != 0 && document.End != this.totalBytesReaded)
						{
							throw ReaderException.ReadingBrokenDocument(this, string.Format("invalid BSON document length '{0:##,###}' read, while actual size is '{1:##,###}'",
							document.Length, document.Length + (this.totalBytesReaded - document.End)));
						}
						this.node = new ReaderNode(document.Type == BsonType.Document ? ReaderToken.EndOfObject : ReaderToken.EndOfArray);
						return true;
					default:
						throw ReaderException.UnknownNotation(this, type.ToString());
				}
			}

			private void SkipCString()
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				var length = 0;
				var originalColumnNumber = this.totalBytesReaded;

				while (true)
				{
					while (this.bufferAvailable > 0)
					{
						var isTerminated = this.buffer[this.bufferOffset] == 0;

						length++;
						this.bufferOffset++;
						this.bufferAvailable--;

						if (isTerminated)
						{
							this.totalBytesReaded = originalColumnNumber + length; // length includes trailing zero
							return;
						}
					}

					this.bufferOffset = 0;
					this.bufferAvailable = 0;
					this.ReadToBuffer(this.buffer.Length, false);
					this.bufferRead = 0;
					if (this.bufferAvailable == 0)
						throw ReaderException.UnterminatedStringLiteral(this);
				}
			}
			private string ReadCString()
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				var literalBuffer = this.literalBuffer;
				var literalLength = 0;
				var literalOffset = 0;
				var originalColumnNumber = this.totalBytesReaded;
				while (true)
				{
					while (this.bufferAvailable > 0)
					{
						var isTerminated = this.buffer[this.bufferOffset] == 0;
						literalBuffer[literalOffset] = this.buffer[this.bufferOffset];

						literalOffset++;
						literalLength++;
						this.bufferOffset++;
						this.bufferAvailable--;

						if (isTerminated)
						{
							this.totalBytesReaded = originalColumnNumber + literalLength; // length includes trailing zero


							return Encoding.UTF8.GetString(literalBuffer, 0, literalLength - 1);
						}
						else if (literalOffset >= literalBuffer.Length)
						{
							Array.Resize(ref literalBuffer, (int)(literalBuffer.Length * 1.5));
						}
					}

					this.bufferOffset = 0;
					this.bufferAvailable = 0;
					this.ReadToBuffer(this.buffer.Length, false);
					this.bufferRead = 0;

					if (this.bufferAvailable == 0)
					{
						throw ReaderException.UnterminatedStringLiteral(this);
					}
				}
			}
			private string ReadUtf8String()
			{
				this.ReadToBuffer(4, throwOnEos: true);
				var length = this.bitConverter.ToInt32(this.buffer, this.bufferOffset);

				if (length > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, length, MAX_STRING_LENGTH);
				if (length < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of string literal");

				var strBytes = this.ReadBytes(length);


				return Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count - 1);
			}
			private string ReadObjectId()
			{
				this.ReadToBuffer(12, throwOnEos: true);

				var timeStamp = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
				var machineAndPid = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset + 4);
				var pidAndIncrement = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset + 8);
				var objectIdStr = string.Concat(timeStamp.ToString("X8"), machineAndPid.ToString("X8"), pidAndIncrement.ToString("X8"));

				return objectIdStr;
			}
			private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
			{
				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				if (this.bufferAvailable < bytesRequired)
				{
					if (this.bufferAvailable > 0)
						Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

					this.bufferOffset = 0;
					while (this.bufferAvailable < bytesRequired)
					{
						var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
						this.bufferAvailable += read;

						if (read != 0 || this.bufferAvailable >= bytesRequired)
							continue;

						if (throwOnEos)
							throw ReaderException.UnexpectedEndOfStream(this);
						else
							return false;
					}
				}

				this.bufferRead = bytesRequired;
				this.totalBytesReaded += bytesRequired;
				return true;
			}
			private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
			{
				if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException("bytesRequired");

				this.bufferAvailable -= this.bufferRead;
				this.bufferOffset += this.bufferRead;
				this.bufferRead = 0;

				if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
				{
					var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

					this.bufferAvailable -= (int)bytesRequired;
					this.bufferOffset += (int)bytesRequired;
					this.totalBytesReaded += (int)bytesRequired;

					return bytes;
				}
				else
				{
					var bytes = new byte[bytesRequired];
					var bytesOffset = 0;
					if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
					{
						var bytesToCopy = Math.Min(bytes.Length - bytesOffset, this.bufferAvailable);
						Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

						bytesOffset += bytesToCopy;
						this.bufferOffset += bytesToCopy;

						this.bufferAvailable -= bytesToCopy;
						this.totalBytesReaded += bytesToCopy;
					}

					if (this.bufferAvailable == 0)
						this.bufferOffset = 0;

					while (bytesOffset < bytes.Length)
					{
						var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

						bytesOffset += read;
						this.totalBytesReaded += read;

						if (read == 0 && bytesOffset < bytes.Length)
							throw ReaderException.UnexpectedEndOfStream(this);
					}

					return new ArraySegment<byte>(bytes, 0, bytes.Length);
				}
			}

			private object Box(DateTime value)
			{
				if (this.dateBox == null)
					this.dateBox = new StrongBox<DateTime>(FormatProvider);

				this.dateBox.Store(value);
				return this.dateBox;
			}
			private object Box(DateTimeOffset value)
			{
				if (this.dateOffsetBox == null)
					this.dateOffsetBox = new StrongBox<DateTimeOffset>(FormatProvider);

				this.dateOffsetBox.Store(value);
				return this.dateOffsetBox;
			}
			private object Box(TimeSpan value)
			{
				if (this.timeSpanBox == null)
					this.timeSpanBox = new StrongBox<TimeSpan>(FormatProvider);

				this.timeSpanBox.Store(value);
				return this.timeSpanBox;
			}
			private object Box(Guid value)
			{
				if (this.guidBox == null)
					this.guidBox = new StrongBox<Guid>(FormatProvider);

				this.guidBox.Store(value);
				return this.guidBox;
			}
			private object Box(int value)
			{
				if (this.int32Box == null)
					this.int32Box = new StrongBox<int>(FormatProvider);

				this.int32Box.Store(value);

				return this.int32Box;
			}
			private object Box(long value)
			{
				if (this.int64Box == null)
					this.int64Box = new StrongBox<long>(FormatProvider);

				this.int64Box.Store(value);

				return this.int64Box;
			}
			private object Box(double value)
			{
				if (this.doubleBox == null)
					this.doubleBox = new StrongBox<double>(FormatProvider);

				this.doubleBox.Store(value);

				return this.doubleBox;
			}
			private object Box(decimal value)
			{
				if (this.decimalBox == null)
					this.decimalBox = new StrongBox<decimal>(FormatProvider);

				this.decimalBox.Store(value);

				return this.decimalBox;
			}
			private object Box(bool value)
			{
				if (value)
				{
					if (this.trueBox == null)
						this.trueBox = new StrongBox<bool>(true, FormatProvider);
					return trueBox;
				}
				else
				{
					if (this.falseBox == null)
						this.falseBox = new StrongBox<bool>(false, FormatProvider);
					return falseBox;
				}
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.inputStream.Dispose();
			}

			public enum BsonBinaryType
			{
				Bytes = 0,
				Function = 1,
				BytesOld = 2,
				UUIDOld = 3,
				UUID = 4,
				MD5 = 5,
				UserDefined = 80,

				// 16 bytes
				Decimal = 120,
				// 16 bytes
				DateTime = 121,
				// 16 bytes
				DateTimeOffset = 122,
			}

			public enum BsonType : byte
			{
				None = 0,
				Double = 1,
				String = 2,
				Document = 3,
				Array = 4,
				Binary = 5,
				Undefined = 6,
				ObjectId = 7,
				Boolean = 8,
				DateTime = 9,
				Null = 10,
				Regex = 11,
				Reference = 12,
				JavaScript = 13,
				Symbol = 14,
				JavaScriptWithScope = 15,
				Int32 = 16,
				Timestamp = 17,
				Int64 = 18,
				MinKey = 255,
				MaxKey = 127
			}
		}
		#endregion

		#region Serialization: XML
		private void ReadXml(RpgGameData gameData, Stream data, Stream[] patches, Encoding encoding, bool leaveOpen)
		{
			if (gameData == null) throw new ArgumentNullException("gameData");
			if (data == null) throw new ArgumentNullException("data");
			if (encoding == null) throw new ArgumentNullException("encoding");

			var gameDataPatch = default(Dictionary<string, object>);
			if (patches != null)
			{
				foreach (var patchStream in patches)
				{
					using (var patchXmlReader = new XmlFormattingReader(new StreamReader(patchStream, encoding), leaveOpen))
					{
						gameDataPatch = MergeDocuments(gameDataPatch, patchXmlReader.ReadDocument());
					}
				}
			}

			using (var xmlReader = new XmlFormattingReader(new StreamReader(data, encoding), leaveOpen))
			{
				xmlReader.ReadGameData(gameData, gameDataPatch);
			}
		}

		private class XmlFormattingReader : Reader, IDisposable
		{
			private const int STATE_INITIAL = 0;
			private const int STATE_ARRAY = 1;
			private const int STATE_OBJECT = 2;
			private const int STATE_MEMBER = 3;
			private const int STATE_VALUE = 4;
			private const int STATE_ATTRIBUTE_MEMBER = 5;
			private const int STATE_ATTRIBUTE_VALUE = 6;
			private const int STATE_EMPTY = 7;

			private readonly XmlReader innerReader;
			private readonly bool leaveOpen;
			private readonly Stack<int> states;
			private string memberName;
			private ReaderNode node;

			public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }
			public override int LineNumber { get { return this.innerReader is IXmlLineInfo ? ((IXmlLineInfo)this.innerReader).LineNumber : 0; } }
			public override int ColumnNumber { get { return this.innerReader is IXmlLineInfo ? ((IXmlLineInfo)this.innerReader).LinePosition : 0; } }

			public XmlFormattingReader(TextReader reader, bool leaveOpen = false)
			{
				if (reader == null) throw new ArgumentNullException("reader");

				this.innerReader = new XmlTextReader(reader);
				this.leaveOpen = leaveOpen;
				this.states = new Stack<int>();
			}

			public override bool NextToken()
			{
				this.node = this.ReadNext();
				return this.node.Token != ReaderToken.EndOfStream;
			}

			private ReaderNode ReadNext()
			{
				var state = this.states.Count == 0 ? STATE_INITIAL : this.states.Peek();

				if (state == STATE_EMPTY)
					return this.ReadEmptyElement();

				if (state == STATE_ATTRIBUTE_MEMBER || state == STATE_ATTRIBUTE_VALUE)
					return this.ReadAttributes();

				while (this.innerReader.Read())
				{
					switch (this.innerReader.NodeType)
					{
						case XmlNodeType.Element:
							switch (this.innerReader.Name)
							{
								case XmlNotation.ValueElementName:
									if (state == STATE_OBJECT)
										goto default;
									if (state != STATE_INITIAL && state != STATE_ARRAY)
										throw this.NewUnknownNotationException();

									this.states.Push(STATE_VALUE);
									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return ReadNext();
								case XmlNotation.ArrayElementName:
									if (state == STATE_OBJECT)
										goto default;

									this.states.Push(STATE_ARRAY);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return new ReaderNode(ReaderToken.BeginArray);
								case XmlNotation.ObjectElementName:
									if (state == STATE_OBJECT)
										goto default;
									this.states.Push(STATE_OBJECT);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									if (this.innerReader.HasAttributes)
										this.states.Push(STATE_ATTRIBUTE_MEMBER);

									return new ReaderNode(ReaderToken.BeginObject);
								default:
									if (state != STATE_OBJECT)
										throw this.NewUnknownNotationException();

									this.memberName = XmlConvert.DecodeName(this.innerReader.Name);

									this.states.Push(STATE_MEMBER);

									if (this.innerReader.IsEmptyElement)
										this.states.Push(STATE_EMPTY);

									return new ReaderNode(ReaderToken.Member, this.memberName);
							}
						case XmlNodeType.EndElement:
							switch (state)
							{
								case STATE_VALUE:
									if (this.innerReader.Name != XmlNotation.ValueElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop VALUE
									return this.ReadNext();
								case STATE_MEMBER:
									this.states.Pop(); // pop MEMBER
									return this.ReadNext();
								case STATE_ARRAY:
									if (this.innerReader.Name != XmlNotation.ArrayElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop ARRAY
									return new ReaderNode(ReaderToken.EndOfArray);
								case STATE_OBJECT:
									if (this.innerReader.Name != XmlNotation.ObjectElementName)
										throw this.NewUnknownNotationException();
									this.states.Pop(); // pop OBJECT
									return new ReaderNode(ReaderToken.EndOfObject);
							}
							throw this.NewUnknownNotationException();
						case XmlNodeType.Text:
						case XmlNodeType.CDATA:
							if (state == STATE_VALUE || state == STATE_MEMBER)
								return new ReaderNode(ReaderToken.Value, this.innerReader.Value);
							throw this.NewUnknownNotationException();
						case XmlNodeType.SignificantWhitespace:
						case XmlNodeType.Whitespace:
						case XmlNodeType.Comment:
						case XmlNodeType.XmlDeclaration:
						case XmlNodeType.DocumentType:
						case XmlNodeType.Document:
							continue;
						case XmlNodeType.None:
						case XmlNodeType.EntityReference:
						case XmlNodeType.Entity:
						case XmlNodeType.EndEntity:
						case XmlNodeType.ProcessingInstruction:
						case XmlNodeType.DocumentFragment:
						case XmlNodeType.Notation:
						default:
							throw this.NewUnknownNotationException();
					}
				}

				return new ReaderNode(ReaderToken.EndOfStream);
			}

			private ReaderNode ReadEmptyElement()
			{
				this.states.Pop(); // pop EMPTY
				var state = this.states.Count > 0 ? this.states.Peek() : STATE_INITIAL;
				switch (state)
				{
					case STATE_MEMBER:
						this.states.Pop(); // pop MEMBER
						this.memberName = null;
						if (this.innerReader["nil", XmlNotation.XmlSchemaInstanceUrl] == XmlNotation.NullEntityTrue)
							return new ReaderNode(ReaderToken.Null);
						else
							return new ReaderNode(ReaderToken.Value, "");
					case STATE_VALUE:
						this.states.Pop(); // pop VALUE
						return new ReaderNode(ReaderToken.Null);
					case STATE_OBJECT:
						this.states.Pop(); // pop OBJECT
						return new ReaderNode(ReaderToken.EndOfObject);
					case STATE_ARRAY:
						this.states.Pop(); // pop ARRAY
						return new ReaderNode(ReaderToken.EndOfArray);
				}
				return this.ReadNext();
			}
			private ReaderNode ReadAttributes()
			{
				switch (this.states.Pop())
				{
					case STATE_ATTRIBUTE_MEMBER:
						while (this.innerReader.MoveToNextAttribute())
						{
							if (this.innerReader.Prefix == "xmlns" || this.innerReader.Prefix == "xsi")
								continue;

							this.states.Push(STATE_ATTRIBUTE_VALUE);
							return new ReaderNode(ReaderToken.Member, this.innerReader.Name);
						}
						break;
					case STATE_ATTRIBUTE_VALUE:
						this.states.Push(STATE_ATTRIBUTE_MEMBER);
						return new ReaderNode(ReaderToken.Value, this.innerReader.Value);
				}
				return this.ReadNext();
			}

			private Exception NewUnknownNotationException()
			{
				throw ReaderException.UnknownNotation(this, this.innerReader.NodeType.ToString() + "[" + this.innerReader.Name + "]");
			}

			public void Dispose()
			{
				if (this.leaveOpen == false)
					this.innerReader.Close();
			}

			private class XmlNotation
			{
				public const string ObjectElementName = "Object";
				public const string ArrayElementName = "Array";
				public const string ValueElementName = "Value";

				public const string XmlSchemaInstanceUrl = "http://www.w3.org/2001/XMLSchema-instance";
				public const string NullEntityTrue = "true";
			}
		}
		#endregion

		#endregion
}

#pragma warning disable 0660, 0661
	[GeneratedCode("Charon", "2019.3.7.0")]
	public abstract partial class Document
	{
#pragma warning restore 0660, 0661
		public static bool operator ==(Document value1, Document value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2,null)) return false;

			return Object.Equals(value1, value2);
		}
		public static bool operator !=(Document value1, Document value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2,null)) return true;

			return Object.Equals(value1, value2) == false;
		}

		protected internal abstract void Apply(RpgGameData.Visitor visitor);

		protected internal abstract void Init(RpgGameData gameData, string languageId);

		protected internal abstract void SetLanguage(string languageId);

		protected static bool AreEquals<T>(T value1, T value2)
		{
			if (value1 == null) return value2 == null;

			return value1.Equals(value2);
		}
		protected static bool AreEquals<T>(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2))
				return true;
			else if (value1 == null || value2 == null)
				return false;

			if (value1.Equals(value2))
				return true;

			return Enumerable.SequenceEqual(value1, value2);
		}

		protected static void EmptyIfNull<T>(ref ReadOnlyList<T> list)
		{
			if (list == null || list.Count == 0)
				list = ReadOnlyList<T>.Empty;
		}

		protected static ReadOnlyList<T> DereferenceCollection<T>(ReadOnlyList<DocumentReference<T>> collection, ref ReadOnlyList<T> dereferencedCollection) where T : Document
		{
			if (dereferencedCollection != null) {
				return dereferencedCollection;
			}

			if (collection.Count == 0) {
				dereferencedCollection = ReadOnlyList<T>.Empty;
				return dereferencedCollection;
			}

			var list = new List<T>(collection.Count);
			for(var i = 0; i < collection.Count; i++)
				list.Add(collection[i].Value);

			dereferencedCollection = new ReadOnlyList<T>(list);
			return dereferencedCollection;
		}

		protected static T CreateFormula<T>(IDictionary<string, object> expression, Func<SyntaxTreeNode, T> ctr, string entityName, string attributeName, object id)
		{
			if (ctr == null) throw new ArgumentNullException("ctr");
			if (attributeName == null) throw new ArgumentNullException("attributeName");
			if (id == null) throw new ArgumentNullException("id");

			if (expression == null)
			{
				return default(T);
			}

			var syntaxTree = default(SyntaxTreeNode);
			try
			{
				syntaxTree = new SyntaxTreeNode(expression);
				return ctr(syntaxTree);
			}
			catch (Exception createError)
			{
				var expressionError = createError;
				while (expressionError is System.Reflection.TargetInvocationException)
				{
					expressionError = createError.InnerException;
				}

				var expressionText = "<none>";
				try
				{
					if(syntaxTree != null)
					{
						expressionText = syntaxTree.ToString();
					}
				}
				catch
				{
					expressionText = "<expression rendering failed>";
				}

				throw new InvalidOperationException(string.Format("An error occurred while trying to create {0} Expression '{1}' for {2} with id '{3}':\r\n{4}", attributeName,
					expressionText, entityName, id, expressionError.Message), expressionError);
			}
		}

		protected static int GetHashCodeFor<T>(T value)
		{
			if (value == null) return 0;
			return value.GetHashCode();
		}
		protected static int GetHashCodeFor<T>(ReadOnlyList<T> value)
		{
			if (value == null)
				return 0;

			if (value.Count == 0)
				return value.GetHashCode();

			var hashCode = 0;
			foreach (var item in value)
				hashCode = unchecked(hashCode + item.GetHashCode());
			return hashCode;
		}
	}
		[GeneratedCode("Charon", "2019.3.7.0")]
		public sealed partial class DocumentReference<T> where T : Document
		{	
			[NonSerialized]
			private T value;
			[NonSerialized]
			private Func<string, object, Document> valueResolver;
			
			public object Id { get; set; }

			public T Value
			{
				get
				{
					if (this.value != null)
						return value;

					if (this.valueResolver != null)
						return this.value = (T)this.valueResolver(typeof(T).Name, this.Id);
					else
						throw new InvalidOperationException(string.Format("Broken {0} reference with id {1}. Consider calling Resolve() before using Value.", typeof(T).Name, this.Id));
				}
			}

			public static implicit operator T(DocumentReference<T> reference)
			{
				return reference.Value;
			}

			internal void Resolve(Func<string, object, Document> resolver)
			{
				if (resolver == null) throw new ArgumentNullException("resolver");

	#pragma warning disable 0162 // C# Unreachable code detected
				this.value = null;
				// ReSharper disable once ConditionIsAlwaysTrueOrFalse
				if (false)
					this.valueResolver = resolver;
				else
					this.value = (T)resolver(typeof(T).Name, this.Id);
	#pragma warning restore 0162
			}

			public override bool Equals(object value)
			{
				var other = value as DocumentReference<T>;
				if (other == null)
					return false;
				else if (Object.ReferenceEquals(this, value))
					return true;

				return Object.Equals(this.Id, other.Id);
			}

			public override int GetHashCode()
			{
				var hashCode = (this.Id != null ? this.Id.GetHashCode() : 0);
				return hashCode;
			}

			public static DocumentReference<T> Create(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var idValue = default(object);
				if (values.TryGetValue("Id", out idValue) == false || idValue == null)
				{
					return null;
				}

				return new DocumentReference<T> { Id = idValue };
			}

			public override string ToString()
			{
				return string.Format("id: {0}, entity: {1}", this.Id, typeof(T).Name);
			}
		}

		[GeneratedCode("Charon", "2019.3.7.0")]
		public sealed partial class LocalizedString : IDictionary<string, string>
		{
			private static readonly string[] DefaultLanguageIds = new string[] { "en-US" };
			private static readonly StringComparer KeyComparer = StringComparer.OrdinalIgnoreCase;

			private string[] keys;
			private string[] values;
			private string currentValue;
			private string currentLanguageId;
			private bool isReadOnly;

			public string Value { get { return this.currentValue ?? this.values.FirstOrDefault(v => v != null); } }
			public string CurrentLanguageId { get { return this.currentLanguageId; } }
			public string this[string key]
			{
				get
				{
					var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
					return languageIndex < 0 ? null : this.values[languageIndex];
				}
				set
				{
					this.ThrowIfReadOnly();
					var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
					if (languageIndex >= 0)
					{
						this.values[languageIndex] = value;
						return;
					}

					Array.Resize(ref this.keys, this.keys.Length + 1);
					Array.Resize(ref this.values, this.values.Length + 1);
					this.keys[this.keys.Length - 1] = key;
					this.values[this.keys.Length - 1] = value;
					Array.Sort(this.keys, this.values, KeyComparer);
				}
			}

			public LocalizedString()
			{
				this.keys = DefaultLanguageIds;
				this.values = new string[DefaultLanguageIds.Length];
			}

			public void SetLanguage(string languageId)
			{
				if (languageId == null) throw new ArgumentNullException("languageId");

				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, languageId, KeyComparer);
				if (languageIndex < 0)
				{
					System.Diagnostics.Debug.WriteLine(string.Format("Localized string '{0}' doesn't contains text for '{1}' language.", string.Join(", ", this.keys), languageId));
					this.currentValue = string.Empty;
				}
				else
				{
					this.currentValue = this.values[languageIndex];
				}

				this.currentLanguageId = languageId;
			}
			public void SetReadOnly()
			{
				this.isReadOnly = true;
			}

			public static implicit operator string(LocalizedString str)
			{
				if (str == null) return null;
				return str.Value;
			}

			public override bool Equals(object value)
			{
				var other = value as LocalizedString;
				if (other == null)
					return false;
				else if (object.ReferenceEquals(this, value))
					return true;
				else if (this.keys.Length != other.keys.Length)
					return false;

				for (var i = 0; i < this.keys.Length; i++)
				{
					if (KeyComparer.Equals(this.keys[i], other.keys[i]) == false)
					{
						return false;
					}

					if (string.Equals(this.values[i], other.values[i], StringComparison.OrdinalIgnoreCase) == false)
					{
						return false;
					}
				}

				return true;
			}

			public override int GetHashCode()
			{
				var hashCode = 0;
				foreach (var value in this.values)
					hashCode += unchecked((value ?? "").GetHashCode());
				return hashCode;
			}

			ICollection<string> IDictionary<string, string>.Keys { get { return this.keys; } }
			ICollection<string> IDictionary<string, string>.Values { get { return this.values; } }
			int ICollection<KeyValuePair<string, string>>.Count { get { return this.keys.Length; } }
			bool ICollection<KeyValuePair<string, string>>.IsReadOnly { get { return this.isReadOnly; } }

			void IDictionary<string, string>.Add(string key, string value)
			{
				((IDictionary<string, string>)this)[key] = value;
			}
			bool IDictionary<string, string>.ContainsKey(string key)
			{
				return Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer) >= 0;
			}
			bool IDictionary<string, string>.Remove(string key)
			{
				if (((IDictionary<string, string>)this).ContainsKey(key))
				{
					((IDictionary<string, string>)this)[key] = null;
					return true;
				}
				return false;
			}
			bool IDictionary<string, string>.TryGetValue(string key, out string value)
			{
				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, KeyComparer);
				if (languageIndex >= 0)
				{
					value = this.values[languageIndex];
					return value != null;
				}
				else
				{
					value = null;
					return false;
				}
			}

			void ICollection<KeyValuePair<string, string>>.Add(KeyValuePair<string, string> item)
			{
				((IDictionary<string, string>)this)[item.Key] = item.Value;
			}
			void ICollection<KeyValuePair<string, string>>.Clear()
			{
				this.ThrowIfReadOnly();

				Array.Clear(this.values, 0, this.values.Length);
			}
			bool ICollection<KeyValuePair<string, string>>.Contains(KeyValuePair<string, string> item)
			{
				return string.Equals(((IDictionary<string, string>)this)[item.Key], item.Value, StringComparison.Ordinal);
			}
			void ICollection<KeyValuePair<string, string>>.CopyTo(KeyValuePair<string, string>[] array, int arrayIndex)
			{
				var offset = 0;
				for (var i = arrayIndex; i < array.Length; i++)
				{
					array[i] = new KeyValuePair<string, string>(this.keys[offset], this.values[offset]);
					offset++;
				}
			}
			bool ICollection<KeyValuePair<string, string>>.Remove(KeyValuePair<string, string> item)
			{
				this.ThrowIfReadOnly();
				if (((ICollection<KeyValuePair<string, string>>)this).Contains(item))
				{
					return ((IDictionary<string, string>)this).Remove(item.Key);
				}

				return false;
			}
			IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
			{
				for (var i = 0; i < this.keys.Length; i++)
				{
					yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
				}
			}

			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				for (var i = 0; i < this.keys.Length; i++)
				{
					yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
				}
			}

			private void ThrowIfReadOnly()
			{
				if (this.isReadOnly)
					throw new InvalidOperationException("This LocalizedString is read-only and can't be changed.");
			}

			public static bool operator ==(LocalizedString value1, LocalizedString value2)
			{
				return object.Equals(value1, value2);
			}
			public static bool operator !=(LocalizedString value1, LocalizedString value2)
			{
				return object.Equals(value1, value2) == false;
			}

			public static LocalizedString Create(Dictionary<string, object> values)
			{
				if (values == null)
				{
					return null;
				}

				var value = new LocalizedString();
				foreach(var kv in values)
				{
					if (kv.Key == "notes")
					{
						continue;
					}

					value[kv.Key] = kv.Value != null ? kv.Value.ToString() : null;
				}
				return value;
			}

			public override string ToString()
			{
				return this.Value;
			}
		}
		
	[GeneratedCode("Charon", "2019.3.7.0")]
	public class ReadOnlyList<T> : IList<T>
	{
		public static readonly ReadOnlyList<T> Empty = new ReadOnlyList<T>();

		private static readonly List<T> EmptyList = new List<T>();

		private readonly List<T> list;

		private List<T> InnerList { get { return this.list ?? EmptyList; } }

		/// <inheritdoc />
		public int Count { get { return this.InnerList.Count; } }
		/// <inheritdoc />
		public bool IsReadOnly { get { return true; } }
		/// <inheritdoc />
		public T this[int index] { get { return this.InnerList[index]; } set { throw new NotSupportedException(); } }

		public ReadOnlyList()
		{
			this.list = null;
		}

		public ReadOnlyList(List<T> list)
		{
			this.list = list;
		}

		public bool Contains(T item) { return this.InnerList.Contains(item); }
		/// <inheritdoc />
		public void CopyTo(T[] array, int arrayIndex) { this.InnerList.CopyTo(array, arrayIndex); }
		public void ForEach(Action<T> action) { this.InnerList.ForEach(action); }
		public T Find(Predicate<T> match) { return this.InnerList.Find(match); }
		public bool Exists(Predicate<T> match) { return this.InnerList.Exists(match); }
		public int FindIndex(Predicate<T> match) { return this.InnerList.FindIndex(match); }
		public int FindIndex(int startIndex, Predicate<T> match) { return this.InnerList.FindIndex(startIndex, match); }
		public int FindIndex(int startIndex, int count, Predicate<T> match) { return this.InnerList.FindIndex(startIndex, count, match); }
		public T FindLast(Predicate<T> match) { return this.InnerList.FindLast(match); }
		public int FindLastIndex(Predicate<T> match) { return this.InnerList.FindLastIndex(match); }
		public int FindLastIndex(int startIndex, Predicate<T> match) { return this.InnerList.FindLastIndex(startIndex, match); }
		public int FindLastIndex(int startIndex, int count, Predicate<T> match) { return this.InnerList.FindLastIndex(startIndex, count, match); }
		public int IndexOf(T item) { return this.InnerList.IndexOf(item); }
		public int IndexOf(T item, int index) { return this.InnerList.IndexOf(item, index); }
		public int IndexOf(T item, int index, int count) { return this.InnerList.IndexOf(item, index, count); }
		public int LastIndexOf(T item) { return this.InnerList.LastIndexOf(item); }
		public int LastIndexOf(T item, int index) { return this.InnerList.LastIndexOf(item, index); }
		public int LastIndexOf(T item, int index, int count) { return this.InnerList.LastIndexOf(item, index, count); }
		public bool TrueForAll(Predicate<T> match) { return this.InnerList.TrueForAll(match); }
		public List<T> GetRange(int index, int count) { return this.InnerList.GetRange(index, count); }
		public List<T> FindAll(Predicate<T> match) { return this.InnerList.FindAll(match); }
		public T[] ToArray() { return this.InnerList.ToArray(); }
		public List<T> ToList() { return new List<T>(this.InnerList); }
		public List<TOutput> ConvertAll<TOutput>(Converter<T, TOutput> converter) { return this.InnerList.ConvertAll(converter); }

		public List<T>.Enumerator GetEnumerator()
		{
			return this.InnerList.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerList.GetEnumerator();
		}
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerList.GetEnumerator();
		}

		public override bool Equals(object obj)
		{
			var otherList = obj as ReadOnlyList<T>;
			if (Object.ReferenceEquals(this, obj))
				return true;
			else if (otherList != null && this.Count == otherList.Count)
				return Enumerable.SequenceEqual(this.list, otherList.list);
			else
				return Object.Equals(this.list, obj);
		}
		public override int GetHashCode()
		{
			return this.InnerList.GetHashCode();
		}

		public static bool operator ==(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return false;

			return value1.Equals(value2);
		}
		public static bool operator !=(ReadOnlyList<T> value1, ReadOnlyList<T> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return true;

			return value1.Equals(value2) == false;
		}

		#region NotSupported
		/// <inheritdoc />
		public void Insert(int index, T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public bool Remove(T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void Add(T item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		public void Clear()
		{
			throw new NotSupportedException();
		}
		#endregion

		public static ReadOnlyList<T> Create(List<T> list)
		{
			if (list == null)
			{
				return Empty;
			}
			else
			{
				return new ReadOnlyList<T>(list);
			}
		}

		public override string ToString()
		{
			return this.InnerList.Count.ToString();
		}
	}

	[GeneratedCode("Charon", "2019.3.7.0")]
	public class ReadOnlyDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>
	{
		public static readonly ReadOnlyDictionary<KeyT, ValueT> Empty = new ReadOnlyDictionary<KeyT, ValueT>();

		private static readonly Dictionary<KeyT, ValueT> EmptyDictionary = new Dictionary<KeyT, ValueT>();

		private readonly Dictionary<KeyT, ValueT> dictionary;

		private Dictionary<KeyT, ValueT> InnerDictionary { get { return this.dictionary ?? EmptyDictionary; } }
		/// <inheritdoc />
		public int Count { get { return this.InnerDictionary.Count; } }
		/// <inheritdoc />
		public bool IsReadOnly { get { return true; } }
		public ValueT this[KeyT key] { get { return this.dictionary[key]; } set { throw new NotSupportedException();} }
		public Dictionary<KeyT, ValueT>.KeyCollection Keys { get { return this.InnerDictionary.Keys; } }
		public Dictionary<KeyT, ValueT>.ValueCollection Values { get { return this.InnerDictionary.Values; } }
		/// <inheritdoc />
		ICollection<ValueT> IDictionary<KeyT, ValueT>.Values { get { return this.Values; } }
		/// <inheritdoc />
		ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys { get { return this.Keys; } }
		public IEqualityComparer<KeyT> Comparer { get { return this.InnerDictionary.Comparer; } }

		public ReadOnlyDictionary()
		{
			this.dictionary = null;
		}

		public ReadOnlyDictionary(Dictionary<KeyT, ValueT> dictionary)
		{
			this.dictionary = dictionary;
		}
		/// <inheritdoc />
		public bool Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return ((ICollection<KeyValuePair<KeyT, ValueT>>)this.InnerDictionary).Contains(item);
		}
		public void CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			((ICollection<KeyValuePair<KeyT, ValueT>>)this.InnerDictionary).CopyTo(array, arrayIndex);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.InnerDictionary.ContainsKey(key);
		}
		public bool ContainsValue(ValueT value)
		{
			return this.InnerDictionary.ContainsValue(value);
		}
		public Dictionary<KeyT, ValueT> ToDictionary()
		{
			return new Dictionary<KeyT, ValueT>(this.InnerDictionary);
		}
		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.InnerDictionary.TryGetValue(key, out value);
		}
	
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerDictionary.GetEnumerator();
		}
		public Dictionary<KeyT, ValueT>.Enumerator GetEnumerator()
		{
			return this.InnerDictionary.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			// ReSharper disable once HeapView.BoxingAllocation
			return this.InnerDictionary.GetEnumerator();
		}

		public override bool Equals(object obj)
		{
			var otherReadOnlyDictionary = obj as ReadOnlyDictionary<KeyT, ValueT>;
			var otherDictionary = obj as Dictionary<KeyT, ValueT>;
			if (Object.ReferenceEquals(this, obj))
				return true;
			else if (otherReadOnlyDictionary != null && this.Count == otherReadOnlyDictionary.Count)
				return Enumerable.SequenceEqual(this.dictionary, otherReadOnlyDictionary.dictionary);
			else if (otherDictionary != null && this.Count == otherDictionary.Count)
				return Enumerable.SequenceEqual(this.dictionary, otherDictionary);
			else
				return Object.Equals(this.dictionary, obj);
		}
		public override int GetHashCode()
		{
			return this.InnerDictionary.GetHashCode();
		}

		public static bool operator ==(ReadOnlyDictionary<KeyT, ValueT> value1, ReadOnlyDictionary<KeyT, ValueT> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return true;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return false;

			return value1.Equals(value2);
		}
		public static bool operator !=(ReadOnlyDictionary<KeyT, ValueT> value1, ReadOnlyDictionary<KeyT, ValueT> value2)
		{
			if (Object.ReferenceEquals(value1, value2)) return false;
			if (Object.ReferenceEquals(value1, null) || Object.ReferenceEquals(value2, null)) return true;

			return value1.Equals(value2) == false;
		}

		#region NotSupported

		/// <inheritdoc />
		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			throw new NotSupportedException();
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.Clear()
		{
			throw new NotSupportedException();
		}

		/// <inheritdoc />
		void IDictionary<KeyT, ValueT>.Add(KeyT key, ValueT value)
		{
			throw new NotSupportedException();
		}
		/// <inheritdoc />
		bool IDictionary<KeyT, ValueT>.Remove(KeyT key)
		{
			throw new NotSupportedException();
		}

		#endregion

		public static ReadOnlyDictionary<KeyT, ValueT> Create(Dictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null)
			{
				return Empty;
			}
			else
			{
				return new  ReadOnlyDictionary<KeyT, ValueT>(dictionary);
			}
		}

		public override string ToString()
		{
			return this.InnerDictionary.Count.ToString();
		}
	}

}

